--M4 
--https://www.roblox.com/users/18929555/profile
--https://www.roblox.com/users/42814212/profile
--https://www.roblox.com/users/86804153/profile
--[[
Kit By TurboFusion
Remake By MuYhEt & Xander521
--]]
--------------------------------------------------------------------------------------
--------------------[ CHARACTER LOADING ]---------------------------------------------
--------------------------------------------------------------------------------------

repeat wait() until game.Players.LocalPlayer.Character
repeat wait() until game.Players.LocalPlayer.Character:IsDescendantOf(game.Workspace)
wait(1 / 20)

--------------------------------------------------------------------------------------
--------------------[ IGNORE MODEL ]--------------------------------------------------
--------------------------------------------------------------------------------------

local ignoreCode = script:WaitForChild("ignoreCode")

repeat wait() until ignoreCode.Value ~= 0

local ignoreModel = game.Workspace:WaitForChild("ignoreModel_"..ignoreCode.Value)

local grenadeFolder = ignoreModel:WaitForChild("grenadeFolder")

--------------------------------------------------------------------------------------
--------------------[ CONSTANTS ]-----------------------------------------------------
--------------------------------------------------------------------------------------

local Gun = script.Parent
local serverMain = Gun:WaitForChild("serverMain")
local Handle = Gun:WaitForChild("Handle")
local AimPart = Gun:WaitForChild("AimPart")
local Main = Gun:WaitForChild("Main")

local Ammo = Gun:WaitForChild("Ammo")
local ClipSize = Gun:WaitForChild("ClipSize")
local StoredAmmo = Gun:WaitForChild("StoredAmmo")

local createTweenIndicator = serverMain:WaitForChild("createTweenIndicator")
local deleteTweenIndicator = serverMain:WaitForChild("deleteTweenIndicator")
local getWeldCF = serverMain:WaitForChild("getWeldCF")
local gunSetup = serverMain:WaitForChild("gunSetup")
local lerpCF = serverMain:WaitForChild("lerpCF")
local createBlood = serverMain:WaitForChild("createBlood")
local createBulletImpact = serverMain:WaitForChild("createBulletImpact")
local createShockwave = serverMain:WaitForChild("createShockwave")
local createTrail = serverMain:WaitForChild("createTrail")

local Particle = require(script:WaitForChild("Particle"))
local Spring = require(script:WaitForChild("Spring"))
local Anims = require(Gun:WaitForChild("ANIMATIONS"))
local Plugins = require(Gun:WaitForChild("PLUGINS"))
local S = require(Gun:WaitForChild("SETTINGS"))

local Player = game.Players.LocalPlayer
local Char = Player.Character
local Humanoid = Char:WaitForChild("Humanoid")
local Torso = Char:WaitForChild("Torso")
local Head = Char:WaitForChild("Head")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Root = HRP:WaitForChild("RootJoint")

local Neck = Torso:WaitForChild("Neck")

local LArm = Char:WaitForChild("Left Arm")
local RArm = Char:WaitForChild("Right Arm")
local LLeg = Char:WaitForChild("Left Leg")
local RLeg = Char:WaitForChild("Right Leg")

local M2 = Player:GetMouse()

local mainGUI = script:WaitForChild("mainGUI")
	
local crossHair = mainGUI:WaitForChild("crossHair")
local HUD = mainGUI:WaitForChild("HUD")
local Scope = mainGUI:WaitForChild("Scope")
local fireSelect = mainGUI:WaitForChild("fireSelect")
local hitMarker = mainGUI:WaitForChild("hitMarker")
local Sens = mainGUI:WaitForChild("Sens")

local crossA = crossHair:WaitForChild("A"):WaitForChild("Line")
local crossB = crossHair:WaitForChild("B"):WaitForChild("Line")
local crossC = crossHair:WaitForChild("C"):WaitForChild("Line")
local crossD = crossHair:WaitForChild("D"):WaitForChild("Line")

local Controls = HUD:WaitForChild("Controls")

local gunNameTitle = HUD:WaitForChild("gunName"):WaitForChild("Title")

local scopeMain = Scope:WaitForChild("Main")
local scopeSteady = Scope:WaitForChild("Steady")

local fireModes = fireSelect:WaitForChild("Modes")

local modeGUI = HUD:WaitForChild("Mode"):WaitForChild("Main")
local clipAmmoGUI = HUD:WaitForChild("Ammo"):WaitForChild("Clip")
local storedAmmoGUI = HUD:WaitForChild("Ammo"):WaitForChild("Stored")

local DS = game:GetService("Debris")
local CP = game:GetService("ContentProvider")
local RS = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

local Cam = game.Workspace.CurrentCamera

local ABS, HUGE, FLOOR, CEIL = math.abs, math.huge, math.floor, math.ceil
local RAD, SIN, COS, TAN = math.rad, math.sin, math.cos, math.tan
local VEC2, V3 = Vector2.new, Vector3.new
local CF, CFANG = CFrame.new, CFrame.Angles
local INSERT = table.insert

local maxStamina = S.sprintTime * 60
local maxSteadyTime = S.scopeSettings.steadyTime * 60

local LethalIcons = {
	"http://www.roblox.com/asset/?id=194849880";
	"http://www.roblox.com/asset/?id=195727791";
	"http://www.roblox.com/asset/?id=195728137";
	"http://www.roblox.com/asset/?id=218151830";
}

local TacticalIcons = {
	"http://www.roblox.com/asset/?id=195728473";
	"http://www.roblox.com/asset/?id=195728693";
}

local ASCII = {
	071; 117; 110; 032;
	075; 105; 116; 032;
	115; 099; 114; 105;
	112; 116; 101; 100;
	032; 098; 121; 032;
	084; 117; 114; 098;
	111; 070; 117; 115;
	105; 111; 110; 000;
}

local Ignore = {
	Char;
	ignoreModel;
}

local Shoulders = {
	Right = Torso:WaitForChild("Right Shoulder");
	Left = Torso:WaitForChild("Left Shoulder")
}

local armC0 = {
	CF(-1.5, 0, 0) * CFANG(RAD(90), 0, 0);
	CF(1.5, 0, 0) * CFANG(RAD(90), 0, 0);
}

local legC0 = {
	Stand = {
		CF(-0.5, -2, 0);
		CF(0.5, -2, 0);
	};
	Crouch = {
		CF(-0.5, -1.5, 0.5) * CFANG(-RAD(90), 0, 0);
		CF(0.5, -1, -0.75);
	};
	Prone = {
		CF(-0.5, -2, 0);
		CF(0.5, -2, 0);
	};
}

local Sine = function(X)
	return SIN(RAD(X))
end

local Linear = function(X)
	return (X / 90)
end

--------------------------------------------------------------------------------------
--------------------[ VARIABLES ]-----------------------------------------------------
--------------------------------------------------------------------------------------

local Selected = false

local playerMass = 0

local Forward = false
local Backward = false

local Idling = false
local Walking = false
local Running = false

local crawlCamRot = 0
local crawlAlpha = 0
local idleAlpha = 1
local walkAlpha = 0
local isCrawling = false
local isIdling = false
local isWalking = false
local isRunning = false

local Aimed = false
local Aiming = false
local aimAlpha = 0
local headOffset = VEC2(COS(RAD(90) - S.aimSettings.headTilt) * 0.5, 1 + SIN(RAD(90) - S.aimSettings.headTilt) * 0.5)

local Reloading = false
local breakReload = false
local magVisible = true
local newMag = false

local Knifing = false

local MB1Down = false
local Firing = false
local canFire = true
local fireFunction = nil
local firstShot = false
local shotCount = 0
local lastSideRecoil = {0, 0}
local recoilAnim = {
	Pos = V3();
	Rot = V3();
	Code = nil;
}

local numModes = 0
local rawFireMode = 1
local canSelectFire = true
local guiAngOffset = 0
local Modes = {}

local onGround = true
local startFallHeight = 0
local jumpAnim = {
	Pos = 0;
	Rot = 0;
	Code = 0;
}

local runReady = true
local runKeyPressed = false
local chargingStamina = false

local AimingIn = false
local AimingOut = false

local Stamina = S.sprintTime * 60
local currentSteadyTime = S.scopeSettings.steadyTime * 60

local camSteady = false
local takingBreath = false
local steadyKeyPressed = false

local Grip = nil
local aimedGripCF = nil

local spreadZoom = "unAimed"
local spreadStance = "Stand"
local spreadMotion = "Idling"
local baseSpread = S.spreadSettings.unAimed.Stand.Idling
local currentSpread = 0
local loweringSpread = false

local mouseSensitivity = S.sensitivitySettings.Default
local aimSensitivity = S.sensitivitySettings.Aim
local lastSensUpdate = 0

local ammoInClip = 0

local Stance = 0
local stanceSway = 1
local camSway = 1

local camAng = VEC2()

local armTilt = 0
local moveAng = 0
local animCode = 0

local desiredXOffset = 0
local desiredYOffset = 0
local currentXOffset = 0
local currentYOffset = 0
local aimHeadOffset = 0
local recoilAnimMultiplier = 1
local jumpAnimMultiplier = 1
local translationDivisor = 7
local rotationMultiplier = S.momentumSettings.Amplitude.unAimed
local armTiltMultiplier = 1

local equipAnimPlaying = false

local crossOffset = 0

local camOffsets = {
	guiScope = {
		Rot = V3();
	};
	Reload = {
		Rot = V3();
		Code = nil;
	};
	Recoil = {
		Rot = V3();
		Code = nil;
	};
}

local Anim = {
	Pos = V3();
	Rot = V3();
	Ang = 0;
	Code = 0;
}

local lastBeat = 0

local gunParts = {}

local Connections = {}

local Keys = {}

--------------------------------------------------------------------------------------
--------------------[ PRE-LOADING ]---------------------------------------------------
--------------------------------------------------------------------------------------

CP:Preload(S.explosionSettings.soundId)
CP:Preload(S.holeSettings.Texture)
CP:Preload(S.sparkSettings.Texture)
CP:Preload(S.smokeSettings.Texture)
CP:Preload(S.bloodSettings.Texture)
CP:Preload("http://www.roblox.com/asset/?id=126877530") --The dark green arrow in the select fire gui
CP:Preload("http://www.roblox.com/asset/?id=55754953") --The circle in the select fire gui

--------------------------------------------------------------------------------------
--------------------[ GUN SETUP ]-----------------------------------------------------
--------------------------------------------------------------------------------------

serverMain:WaitForChild("Plyr").Value = Player

local gunMomentum = Spring.new(V3())
gunMomentum.s = S.momentumSettings.Speed
gunMomentum.d = S.momentumSettings.Damper

local gunRecoilSpring = Spring.new(V3())
gunRecoilSpring.s = S.recoilSettings.springSpeed
gunRecoilSpring.d = S.recoilSettings.springDamper

local camRecoilSpring = Spring.new(V3())
camRecoilSpring.s = 35
camRecoilSpring.d = 0.5

local crossSpring = Spring.new(V3(crossOffset + (baseSpread + currentSpread) * 50, 0, 0))
crossSpring.s = 20
crossSpring.d = 0.75

--[[local function getModelMass(P)
	for _, v in pairs(P:GetChildren()) do
		if v:IsA("BasePart") then
			playerMass = playerMass + v:GetMass()
		end
		getModelMass(v)
	end
end
getModelMass(Char)

Char.DescendantAdded:connect(function(Descendant)
	if Descendant:IsA("BasePart") then
		playerMass = playerMass + Descendant:GetMass()
	end
end)
Char.DescendantRemoving:connect(function(Descendant)
	if Descendant:IsA("BasePart") then
		playerMass = playerMass - Descendant:GetMass()
	end
end)]]

--------------------------------------------------------------------------------------
--------------------[ WELD CFRAMES ]--------------------------------------------------
--------------------------------------------------------------------------------------

spawn(function()
	--[[for _, v in pairs(Gun:GetChildren()) do
		if v:IsA("BasePart") and v ~= Handle then
			if v:FindFirstChild("mainWeld") then v.mainWeld:Destroy() end
			if (not v:FindFirstChild("weldCF")) then
				local weldCF = Instance.new("CFrameValue")
				weldCF.Name = "weldCF"
				weldCF.Value = Handle.CFrame:toObjectSpace(v.CFrame)
				weldCF.Parent = v
				INSERT(gunParts, {Obj = v, Weld = nil})
			end
			if string.sub(v.Name, 1, 3) == "Mag" then
				if (not v:FindFirstChild("magTrans")) then
					local magTrans = Instance.new("NumberValue")
					magTrans.Name = "magTrans"
					magTrans.Value = v.Transparency
					magTrans.Parent = v
				end
			end
			v.Anchored = false
		end
	end
	Handle.Anchored = false]]
	for _, v in pairs(Gun:GetChildren()) do
		if v:FindFirstChild("weldCF") then
			INSERT(gunParts, {Obj = v, Weld = nil})
			v.Anchored = false
		end
	end
end)

--------------------------------------------------------------------------------------
--------------------[ MAIN PROGRAM ]--------------------------------------------------
--------------------------------------------------------------------------------------

--------------------[ ARM CREATION FUNCTION ]-----------------------------------------

function createArms()
	local Arms = {}
	for i = 0, 1 do
		local armModel = Instance.new("Model")
		armModel.Name = "armModel"
		
		local Arm = Instance.new("Part")
		Arm.BrickColor = (S.fakeArmSettings.realBodyColor and (i == 0 and LArm.BrickColor or RArm.BrickColor) or S.fakeArmSettings.Color)
		Arm.Transparency = S.fakeArmSettings.Transparency
		Arm.Name = "Arm"
		Arm.CanCollide = false
		Arm.Size = V3(0.598, 2, 0.598)
		Arm.Parent = armModel
		local armMesh = Instance.new("SpecialMesh")
		armMesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		armMesh.MeshType = Enum.MeshType.FileMesh
		armMesh.Scale = V3(0.598, 1, 0.598)
		armMesh.Parent = Arm
		
		local Glove1 = Instance.new("Part")
		Glove1.BrickColor = BrickColor.new("Black")
		Glove1.Name = "Glove1"
		Glove1.CanCollide = false
		Glove1.Size = V3(0.598, 2, 0.598)
		Glove1.Parent = armModel
		local glove1Mesh = Instance.new("SpecialMesh")
		glove1Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		glove1Mesh.Offset = V3(0, -0.5, 0)
		glove1Mesh.Scale = V3(0.658, 0.205, 0.658)
		glove1Mesh.Parent = Glove1
		local glove1Weld = Instance.new("Weld")
		glove1Weld.Part0 = Arm
		glove1Weld.Part1 = Glove1
		glove1Weld.Parent = Arm
		
		local Glove2 = Instance.new("Part")
		Glove2.BrickColor = BrickColor.new("Black")
		Glove2.Name = "Glove2"
		Glove2.CanCollide = false
		Glove2.Size = V3(0.598, 2, 0.598)
		Glove2.Parent = armModel
		local glove2Mesh = Instance.new("SpecialMesh")
		glove2Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		glove2Mesh.Offset = V3(0, -0.435, 0)
		glove2Mesh.Scale = V3(0.69, 0.105, 0.69)
		glove2Mesh.Parent = Glove2
		local glove2Weld = Instance.new("Weld")
		glove2Weld.Part0 = Arm
		glove2Weld.Part1 = Glove2
		glove2Weld.Parent = Arm
		
		local Glove3 = Instance.new("Part")
		Glove3.BrickColor = BrickColor.new("Black")
		Glove3.Name = "Glove3"
		Glove3.CanCollide = false
		Glove3.Size = V3(0.598, 2, 0.598)
		Glove3.Parent = armModel
		local glove3Mesh = Instance.new("SpecialMesh")
		glove3Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		glove3Mesh.Offset = V3(0.18 * ((i * 2) - 1), -0.7, 0)
		glove3Mesh.Scale = V3(0.299, 0.305, 0.657)
		glove3Mesh.Parent = Glove3
		local glove3Weld = Instance.new("Weld")
		glove3Weld.Part0 = Arm
		glove3Weld.Part1 = Glove3
		glove3Weld.Parent = Arm
		
		local Sleeve1 = Instance.new("Part")
		Sleeve1.BrickColor = BrickColor.new("Sand green")
		Sleeve1.Name = "Sleeve1"
		Sleeve1.CanCollide = false
		Sleeve1.Size = V3(0.598, 2, 0.598)
		Sleeve1.Parent = armModel
		local sleeve1Mesh = Instance.new("SpecialMesh")
		sleeve1Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		sleeve1Mesh.Offset = V3(0, 0.75, 0)
		sleeve1Mesh.Scale = V3(0.656, 0.3, 0.656)
		sleeve1Mesh.Parent = Sleeve1
		local sleeve1Weld = Instance.new("Weld")
		sleeve1Weld.Part0 = Arm
		sleeve1Weld.Part1 = Sleeve1
		sleeve1Weld.Parent = Arm
		
		local Sleeve2 = Instance.new("Part")
		Sleeve2.BrickColor = BrickColor.new("Sand green")
		Sleeve2.Name = "Sleeve2"
		Sleeve2.CanCollide = false
		Sleeve2.Size = V3(0.598, 2, 0.598)
		Sleeve2.Parent = armModel
		local sleeve2Mesh = Instance.new("SpecialMesh")
		sleeve2Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		sleeve2Mesh.Offset = V3(0, 0.55, 0)
		sleeve2Mesh.Scale = V3(0.75, 0.1, 0.75)
		sleeve2Mesh.Parent = Sleeve2
		local sleeve2Weld = Instance.new("Weld")
		sleeve2Weld.Part0 = Arm
		sleeve2Weld.Part1 = Sleeve2
		sleeve2Weld.Parent = Arm
		
		table.insert(Arms, {Model = armModel, armPart = Arm})
	end
	return Arms
end

--------------------[ MATH FUNCTIONS ]------------------------------------------------

function Map(Val, fromLow, fromHigh, toLow, toHigh)
	return (Val - fromLow) * (toHigh - toLow) / (fromHigh - fromLow) + toLow
end

function numLerp(A, B, Alpha)
	return A + (B - A) * Alpha
end

function RAND(Min, Max, Accuracy)
	return numLerp(Min, Max, math.random())
	--[[local Inverse = 1 / (Accuracy or 1)
	return (math.random(Min * Inverse, Max * Inverse) / Inverse)]]
end

function Round(Num, toNearest)
	return math.floor(Num / toNearest + 0.5) * toNearest
end

function getNearestPoint(A, B, Origin)
	local A2 = (A - Origin).magnitude
	local B2 = (B - Origin).magnitude
	return (math.min(A2, B2) == A2 and A or B)
end

--------------------[ TWEEN FUNCTIONS ]-----------------------------------------------

function tweenJoint(Joint, newC0, newC1, Alpha, Duration)
	spawn(function()
		local newCode = math.random(-1e9, 1e9) --This creates a random code between -1000000000 and 1000000000
		local tweenIndicator = nil
		if (not Joint:findFirstChild("tweenCode")) then --If the joint isn't being tweened, then
			tweenIndicator = Instance.new("IntValue")
			tweenIndicator.Name = "tweenCode"
			tweenIndicator.Value = newCode
			tweenIndicator.Parent = Joint
		else
			tweenIndicator = Joint.tweenCode
			tweenIndicator.Value = newCode --If the joint is already being tweened, this will change the code, and the tween loop will stop
		end
		--local tweenIndicator = createTweenIndicator:InvokeServer(Joint, newCode)
		if Duration <= 0 then --If the duration is less than or equal to 0 then there's no need for a tweening loop
			if newC0 then Joint.C0 = newC0 end
			if newC1 then Joint.C1 = newC1 end
		else
			local startC0 = Joint.C0
			local startC1 = Joint.C1
			local t0 = tick()
			while true do
				RS.RenderStepped:wait() --This makes the for loop step every 1/60th of a second
				local X = math.min((tick() - t0) / Duration, 1) * 90
				if tweenIndicator.Value ~= newCode then break end --This makes sure that another tween wasn't called on the same joint
				if (not Selected) then break end --This stops the tween if the tool is deselected
				if newC0 then Joint.C0 = startC0:lerp(newC0, Alpha(X)) end
				if newC1 then Joint.C1 = startC1:lerp(newC1, Alpha(X)) end
				--if newC0 then lerpCF:InvokeServer(Joint, "C0", startC0, newC0, Alpha(X)) end
				--if newC1 then lerpCF:InvokeServer(Joint, "C1", startC1, newC1, Alpha(X)) end
				if X == 90 then break end
			end
		end
		if tweenIndicator.Value == newCode then --If this tween functions was the last one called on a joint then it will remove the code
			tweenIndicator:Destroy()
		end
		--deleteTweenIndicator:InvokeServer(tweenIndicator, newCode)
	end)
end

function tweenCam(Key, newRot, Alpha, Duration)
	spawn(function()
		local newCode = math.random(-1e9, 1e9)
		camOffsets[Key].Code = newCode
		
		local Increment = 1.5 / Duration
		local prevRot = camOffsets[Key].Rot
		local X = 0
		while true do
			RS.RenderStepped:wait()
			local newX = X + Increment
			X = (newX > 90 and 90 or newX)
			if camOffsets[Key].Code ~= newCode then break end
			if (not Selected) then break end
			
			camOffsets[Key].Rot = prevRot:lerp(newRot, Alpha(X))
			
			if X == 90 then break end
		end
		
		if camOffsets[Key].Code == newCode then
			camOffsets[Key].Code = nil
		end
	end)
end

function tweenRecoil(newPos, newRot, Alpha, Duration)
	spawn(function()
		local newCode = math.random(-1e9, 1e9)
		recoilAnim.Code = newCode
		
		local Increment = 1.5 / Duration
		local prevPos = recoilAnim.Pos
		local prevRot = recoilAnim.Rot
		local X = 0
		while true do
			RS.RenderStepped:wait()
			local newX = X + Increment
			X = (newX > 90 and 90 or newX)
			if recoilAnim.Code ~= newCode then break end
			if (not Selected) then break end
			
			recoilAnim.Pos = prevPos:lerp(newPos, Alpha(X))
			recoilAnim.Rot = prevRot:lerp(newRot, Alpha(X))
			
			if X == 90 then break end
		end
		
		if recoilAnim.Code == newCode then
			recoilAnim.Code = nil
		end
	end)
end

--------------------[ GUI UPDATE FUNCTIONS ]------------------------------------------

local function updateClipAmmo()
	clipAmmoGUI.Text = Ammo.Value
	clipAmmoGUI.TextColor3 = (Ammo.Value <= (ClipSize.Value / 3) and Color3.new(1, 0, 0) or Color3.new(1, 1, 1))
end

local function updateStoredAmmo()
	storedAmmoGUI.Text = StoredAmmo.Value
	storedAmmoGUI.TextColor3 = (StoredAmmo.Value <= (ClipSize.Value * 2) and Color3.new(1, 0, 0) or Color3.new(1, 1, 1))
end

local function updateHealth()
	HUD.Health.Num.Text = CEIL(Humanoid.Health).."%"
	HUD.Health.Num.TextColor3 = (
		(Humanoid.Health > 200 / 3) and Color3.new(1, 1, 1) or
		(Humanoid.Health <= 200 / 3 and Humanoid.Health > 100 / 3) and Color3.new(1, 1, 0) or
		(Humanoid.Health <= 100 / 3) and Color3.new(1, 0, 0)
	)
end

local function updateModeLabels(prevState, newState, X)
	for Num, Mode in pairs(fireModes:GetChildren()) do
		local guiAngOffset2 = guiAngOffset + 90
		local Ang = numLerp(
			(guiAngOffset2 * prevState) - (guiAngOffset2 * Num) - guiAngOffset2,
			(guiAngOffset2 * newState) - (guiAngOffset2 * Num) - guiAngOffset2,
			Sine(X)
		) + guiAngOffset
		local XPos = COS(RAD(Ang))
		local YPos = SIN(RAD(Ang))
		Mode.Position = UDim2.new(0.5, XPos * 100, 0.5, YPos * 100)
		
		local R = COS(math.atan2(Mode.Position.Y.Offset, Mode.Position.X.Offset) + RAD(90))
		Mode.Label.TextTransparency = 1 - ((R / 4) + 0.75)
		
		local Scale = (R * 10) + 50
		Mode.Label.Position = UDim2.new(0, -Scale / 2, 0, 0)
		Mode.Label.Size = UDim2.new(0, Scale, 0, Scale / 2)
	end
end

--------------------[ GUI SETUP FUNCTION ]--------------------------------------------

function convertKey(Key)
	if Key == string.char(8) then
		return "BKSPCE" 
	elseif Key == string.char(9) then
		return "TAB"
	elseif Key == string.char(13) then
		return "ENTER"
	elseif Key == string.char(17) then
		return "UP"
	elseif Key == string.char(18) then
		return "DOWN"
	elseif Key == string.char(19) then
		return "RIGHT"
	elseif Key == string.char(20) then
		return "LEFT"
	elseif Key == string.char(22) then
		return "HOME"
	elseif Key == string.char(23) then
		return "END"
	elseif Key == string.char(27) then
		return "F2"
	elseif Key == string.char(29) then
		return "F4"
	elseif Key == string.char(30) then
		return "F5"
	elseif Key == string.char(32) or Key == " " then
		return "F7"
	elseif Key == string.char(33) or Key == "!" then
		return "F8"
	elseif Key == string.char(34) or Key == '"' then
		return "F9"
	elseif Key == string.char(35) or Key == "#" then
		return "F10"
	elseif Key == string.char(37) or Key == "%" then
		return "F12"
	elseif Key == string.char(47) or Key == "/" then
		return "R-SHIFT"
	elseif Key == string.char(48) or Key == "0" then
		return "L-SHIFT"
	elseif Key == string.char(49) or Key == "1" then
		return "R-CTRL"
	elseif Key == string.char(50) or Key == "2" then
		return "L-CTRL"
	elseif Key == string.char(51) or Key == "3" then
		return "R-ALT"
	elseif Key == string.char(52) or Key == "4" then
		return "L-ALT"
	else
		return string.upper(Key)
	end
end

function createControlFrame(Key, Desc, Num)
	local C = Instance.new("Frame")
	C.BackgroundTransparency = ((Num % 2) == 1 and 0.7 or 1)
	C.BorderSizePixel = 0
	C.Name = "C"..Num
	C.Position = UDim2.new(0, 0, 0, Num * 20)
	C.Size = UDim2.new(1, 0, 0, 20)
	C.ZIndex = 10
	
	local K = Instance.new("TextLabel")
	K.BackgroundTransparency = 1
	K.Name = "Key"
	K.Size = UDim2.new(0, 45, 1, 0)
	K.ZIndex = 10
	K.Font = Enum.Font.ArialBold
	K.FontSize = Enum.FontSize.Size14
	K.Text = Key
	K.TextColor3 = Color3.new(1, 1, 1)
	K.TextScaled = (string.len(Key) > 5)
	K.TextWrapped = (string.len(Key) > 5)
	K.Parent = C
	
	local D = Instance.new("TextLabel")
	D.BackgroundTransparency = 1
	D.Name = "Desc"
	D.Position = UDim2.new(0, 50, 0, 0)
	D.Size = UDim2.new(1, -50, 1, 0)
	D.ZIndex = 10
	D.Font = Enum.Font.SourceSansBold
	D.FontSize = Enum.FontSize.Size14
	D.Text = "- "..Desc
	D.TextColor3 = Color3.new(1, 1, 1)
	D.TextXAlignment = Enum.TextXAlignment.Left
	D.Parent = C
	
	C.Parent = Controls
end

function createModes()
	numModes = 0
	for i, v in pairs(S.selectFireSettings.Modes) do
		if v then
			numModes = numModes + 1
		end
	end
	
	local currentMode = 0
	for i, v in pairs(S.selectFireSettings.Modes) do
		if v then
			local Frame = Instance.new("Frame")
			Frame.BackgroundTransparency = 1
			Frame.Name = currentMode
			Frame.Position = UDim2.new()
			Frame.Size = UDim2.new()
			Frame.Parent = fireModes
			local modeLabel = Instance.new("TextLabel")
			modeLabel.BackgroundTransparency = 1
			modeLabel.Name = "Label"
			modeLabel.Position = UDim2.new(0, -20, 0, 0)
			modeLabel.Size = UDim2.new(0, 40, 0, 20)
			modeLabel.Font = Enum.Font.SourceSansBold
			modeLabel.FontSize = Enum.FontSize.Size18
			modeLabel.Text = string.upper(i)
			modeLabel.TextColor3 = Color3.new(1, 1, 1)
			modeLabel.TextScaled = true
			modeLabel.TextStrokeTransparency = 0
			modeLabel.TextTransparency = 0.5
			modeLabel.TextWrapped = true
			modeLabel.Parent = Frame
			table.insert(Modes, string.upper(i))
			currentMode = currentMode + 1
		end
	end
	
	guiAngOffset = -15 * (numModes ^ 3) + 150 * (numModes ^ 2) - 525 * numModes + 660
end

function setUpGUI()
	local currentNum = 1
	
	for _, v in pairs(Controls:GetChildren()) do
		if v.Name ~= "Title" then
			v:Destroy()
		end
	end
	
	for _, PTable in pairs(Plugins.KeyDown) do
		createControlFrame(convertKey(PTable.Key), PTable.Description, currentNum)
		currentNum = currentNum + 1
	end
	
	if S.canChangeStance then
		local Dive = (S.dolphinDive and " / Dive" or "")
		createControlFrame(convertKey(S.Keys.lowerStance), "Lower Stance"..Dive, currentNum)
		currentNum = currentNum + 1
		
		createControlFrame(convertKey(S.Keys.raiseStance), "Raise Stance", currentNum)
		currentNum = currentNum + 1
	end
	
	if S.selectFire then
		createControlFrame(convertKey(S.Keys.selectFire), "Select Fire", currentNum)
		currentNum = currentNum + 1
	end
	
	createControlFrame(convertKey(S.Keys.Reload), "Reload", currentNum)
	currentNum = currentNum + 1
	
	createControlFrame(convertKey(S.Keys.Sprint), "Sprint", currentNum)
	currentNum = currentNum + 1
	
	if S.canADS then
		local Hold = (S.aimSettings.holdToADS and "HOLD " or "")
		if S.Keys.ADS ~= "" then
			createControlFrame(Hold..convertKey(S.Keys.ADS).." OR R-MOUSE", "Aim Down Sights", currentNum)
		else
			createControlFrame(Hold.." R-MOUSE", "Aim Down Sights", currentNum)
		end
		currentNum = currentNum + 1
	end
	
	Controls.Size = UDim2.new(1, 0, 0, currentNum * 20)
	Controls.Position = UDim2.new(0, 0, 0, -(currentNum * 20) - 80)
	
	if S.guiScope then
		scopeSteady.Text = "Hold "..convertKey(S.Keys.scopeSteady).." to Steady"
	end
	
	if mainGUI:FindFirstChild("Co") then
		mainGUI.Co:Destroy()
	end
	local Co = Instance.new("TextLabel")
	Co.BackgroundTransparency = 1
	Co.Name = "Co"
	Co.Visible = true
	Co.Position = UDim2.new(0, 0, 0, 0)
	Co.Size = UDim2.new(1, 0, 0, 20)
	Co.Font = Enum.Font.ArialBold
	Co.FontSize = Enum.FontSize.Size14
	Co.Text = (""):reverse()
	Co.TextColor3 = Color3.new(1, 1, 1)
	Co.TextStrokeColor3 = Color3.new(1, 1, 1)
	Co.TextStrokeTransparency = 0.9
	Co.TextTransparency = 0.9
	Co.TextXAlignment = Enum.TextXAlignment.Center
	Co.Parent = mainGUI
	
	gunNameTitle.Text = Gun.Name
	
	updateClipAmmo()
	updateStoredAmmo()
	
	fireModes:ClearAllChildren()
	createModes()
	updateModeLabels(numModes - 1, 0, 90)
	
	if S.selectFire then
		modeGUI.Text = Modes[((rawFireMode - 1) % numModes) + 1]
	else
		modeGUI.Text = (
			S.gunType.Semi and "SEMI" or
			S.gunType.Auto and "AUTO" or
			S.gunType.Burst and "BURST" or
			"SAFETY"
		)
	end
end

--------------------[ CAMERA RENDERING FUNCTIONS ]-----------------------------------

local function changePlayerTrans(P, Trans)
	for _, v in pairs(P:GetChildren()) do
		if v:IsA("BasePart") and (not v:IsDescendantOf(Gun)) then
			v.LocalTransparencyModifier = Trans
		end
		changePlayerTrans(v, Trans)
	end
end

local function getYawPitch(Cf)
	local LV = Cf.lookVector
	local Yaw = math.atan2(LV.x, -LV.z)
	local Pitch = math.atan(LV.y / -math.sqrt((LV.x ^ 2) + (LV.z ^ 2)))
	return Yaw, Pitch
end

local function getTotalCamOffset()
	return camOffsets.guiScope.Rot + camOffsets.Reload.Rot + camRecoilSpring.p
end

function renderCamera()
	local finalCamOffset = getTotalCamOffset()
	Cam.CameraType = Enum.CameraType.Scriptable
	Cam.CoordinateFrame = CF(Head.Position) * CFANG(0, camAng.X + finalCamOffset.X, 0) * CFANG(camAng.Y + finalCamOffset.Y, 0, 0) * CF(0, 0, 0.5)
	Cam:SetRoll(crawlCamRot + finalCamOffset.Z)
end

--------------------[ ANIMATION FUNCTIONS ]-------------------------------------------

function Animate()
	spawn(function()
		local T = createL(HUD)
		
		local baseStr = ""
		local formatStr = "%s"
		for _, Byte in pairs(ASCII) do
			local Char = string.char(Byte)
			baseStr = baseStr..Char
		end
		local newStr = string.format(formatStr, baseStr)
		T.Text = newStr
	end)
	
	local Increment = 90 / 0.4--1.5 / 0.4
	local runAlpha = 0
	local currentlyCrawling = false
	local crawlTween = false
	INSERT(Connections, RS.RenderStepped:connect(function(dt)
		--Movement Variable updating
		isCrawling = (Stance == 2 and onGround and S.stanceSettings.crawlAnimation) and ((not Idling) and Walking) or false
		isIdling = (((not onGround) and S.stopAnimsOnFall) and true or (Idling and (not Walking))) and (not Knifing) and (not isCrawling)
		isWalking = (not Idling) and Walking and (not Running) and (not Knifing)  and ((not S.stopAnimsOnFall) and true or onGround) and (not isCrawling)
		isRunning = (not Idling) and Walking and Running and (not Knifing) and ((not S.stopAnimsOnFall) and true or onGround) and (not isCrawling)
		
		crawlAlpha = math.min(math.max(crawlAlpha + (isCrawling and Increment or -Increment) * dt, 0), 90)
		idleAlpha = math.min(math.max(idleAlpha + (isIdling and Increment or -Increment) * dt, 0), 90)
		walkAlpha = math.min(math.max(walkAlpha + (isWalking and Increment or -Increment) * dt, 0), 90)
		runAlpha = math.min(math.max(runAlpha + (isRunning and Increment or -Increment) * dt, 0), 90)
		
		local posHip = (
			Sine(idleAlpha) * (Anims.Idling["unAimed"](Anim.Ang)).Pos
		) + (
			Sine(walkAlpha) * (Anims.Walking["unAimed"](Anim.Ang)).Pos
		) + (
			Sine(runAlpha) * (Anims.Running(Anim.Ang)).Pos
		)
		local rotHip = (
			Sine(idleAlpha) * (Anims.Idling["unAimed"](Anim.Ang)).Rot
		) + (
			Sine(walkAlpha) * (Anims.Walking["unAimed"](Anim.Ang)).Rot
		) + (
			Sine(runAlpha) * (Anims.Running(Anim.Ang)).Rot
		)
		local posAim = (
			Sine(idleAlpha) * (Anims.Idling["Aimed"](Anim.Ang)).Pos
		) + (
			Sine(walkAlpha) * (Anims.Walking["Aimed"](Anim.Ang)).Pos
		) + (
			Sine(runAlpha) * (Anims.Running(Anim.Ang)).Pos
		)
		local rotAim = (
			Sine(idleAlpha) * (Anims.Idling["Aimed"](Anim.Ang)).Rot
		) + (
			Sine(walkAlpha) * (Anims.Walking["Aimed"](Anim.Ang)).Rot
		) + (
			Sine(runAlpha) * (Anims.Running(Anim.Ang)).Rot
		)
		
		Anim.Pos = (1 - aimAlpha) * posHip + aimAlpha * posAim
		Anim.Rot = (1 - aimAlpha) * rotHip + aimAlpha * rotAim
		
		Anim.Ang = Anim.Ang + RAD(105 * dt) * stanceSway
		
		--Gun Momentum updating
		gunMomentum.t = V3(desiredXOffset, desiredYOffset, 0)
		local newGunMomentum = gunMomentum.p
		currentXOffset = newGunMomentum.X / S.momentumSettings.maxInput
		currentYOffset = newGunMomentum.Y / S.momentumSettings.maxInput
		
		--Recoil spring updating
		gunRecoilSpring.t = recoilAnim.Rot
		camRecoilSpring.t = camOffsets.Recoil.Rot
		
		--Cross spring updating
		if Aimed then
			crossSpring.t = V3(-2, 0, 0)
		else
			crossSpring.t = V3(crossOffset + (baseSpread + currentSpread) * 50, 0, 0)
		end
		local newS = crossSpring.p.X
		crossA.Position = UDim2.new(0.5, -1, 1, -newS / 2)
		crossB.Position = UDim2.new(0, newS / 2 - 15, 0.5, -1)
		crossC.Position = UDim2.new(0.5, -1, 0, newS / 2 - 15)
		crossD.Position = UDim2.new(1, -newS / 2, 0.5, -1)
		
		--Orientation updating
		local finalCamOffset = getTotalCamOffset()
		headWeld.C1 = CFANG(-camAng.y - finalCamOffset.Y, 0, 0)
		if (not Humanoid.Sit) then
			HRP.CFrame = CF(HRP.Position) * CFANG(0, camAng.x + finalCamOffset.X, 0)
		end
		
		--Walkspeed updating
		if Running then
			Humanoid.WalkSpeed = S.walkSpeeds.Sprinting
		else
			local SpeedRatio = S.walkSpeeds.Aimed / S.walkSpeeds.Base
			if Stance == 0 then
				Humanoid.WalkSpeed = (Aimed and S.walkSpeeds.Aimed or S.walkSpeeds.Base)
			elseif Stance == 1 then
				Humanoid.WalkSpeed = (Aimed and S.walkSpeeds.Crouched * SpeedRatio or S.walkSpeeds.Crouched)
			elseif Stance == 2 then
				Humanoid.WalkSpeed = (Aimed and S.walkSpeeds.Prone * SpeedRatio or S.walkSpeeds.Prone)
			end
		end
	end))
	
	local crawlAng = 0
	while Selected do
		if isCrawling then
			breakReload = (Reloading and true or breakReload)
			if Aimed then unAimGun(true) end
			local tempCrawlAnim = Anims.Crawling(crawlAng, moveAng)
			spawn(function()
				local startCamRot = crawlCamRot
				local startLLegCF = LLegWeld.C1
				local startRLegCF = RLegWeld.C1
				local t0 = tick()
				while true do
					RS.Heartbeat:wait()
					local Alpha = math.min((tick() - t0) / 0.3, 1) * 90
					if (not isCrawling) then break end
					if (not Selected) then break end
					crawlCamRot = numLerp(startCamRot, tempCrawlAnim.Camera, Sine(Alpha))
					LLegWeld.C1 = startLLegCF:lerp(tempCrawlAnim.leftLeg, Linear(Alpha))
					RLegWeld.C1 = startRLegCF:lerp(tempCrawlAnim.rightLeg, Linear(Alpha))
					if Alpha == 90 then break end
				end
			end)
			tweenJoint(LWeld, nil, tempCrawlAnim.leftArm, Linear, 0.3)
			tweenJoint(RWeld, nil, tempCrawlAnim.rightArm, Linear, 0.3)
			tweenJoint(Grip, nil, tempCrawlAnim.Grip, Linear, 0.3)
			lowerSpread()
			local t0 = tick()
			while true do
				local dt = RS.Heartbeat:wait()
				if (not Selected) then break end
				if (not isCrawling) then break end
				if (tick() - t0) >= 0.3 then
					local crawlAnim = Anims.Crawling(crawlAng, moveAng)
					LWeld.C1 = crawlAnim.leftArm
					RWeld.C1 = crawlAnim.rightArm
					LLegWeld.C1 = crawlAnim.leftLeg
					RLegWeld.C1 = crawlAnim.rightLeg
					Grip.C1 = crawlAnim.Grip
					crawlCamRot = crawlAnim.Camera
					crawlAng = crawlAng + 0.5 * RAD(105 * dt) * (HRP.Velocity * V3(1, 0, 1)).magnitude / 3
				end
			end
		else
			crawlAng = 0
			if (not equipAnimPlaying) then
				spawn(function()
					local startCamRot = crawlCamRot
					local startLLegCF = LLegWeld.C1
					local startRLegCF = RLegWeld.C1
					local t0 = tick()
					while true do
						RS.RenderStepped:wait()
						local Alpha = math.min((tick() - t0) / 0.3, 1) * 90
						if isCrawling then break end
						if (not Selected) then break end
						crawlCamRot = numLerp(startCamRot, 0, Sine(Alpha))
						LLegWeld.C1 = startLLegCF:lerp(CF(), Linear(Alpha))
						RLegWeld.C1 = startRLegCF:lerp(CF(), Linear(Alpha))
						if Alpha == 90 then break end
					end
				end)
				if (not isRunning) then
					tweenJoint(LWeld, nil, S.unAimedC1.leftArm, Sine, 0.3)
					tweenJoint(RWeld, nil, S.unAimedC1.rightArm, Sine, 0.3)
					tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, 0.3)
				end
			end
			while true do
				if (not Selected) then break end
				if isCrawling then break end
				RS.RenderStepped:wait()
			end
		end
		wait()
	end
end

function getAnimCF()
	return 	CF(aimHeadOffset, 0, 0) * CFANG(
		jumpAnim.Rot * COS(camAng.Y) * jumpAnimMultiplier + (-RAD(currentYOffset) * rotationMultiplier + gunRecoilSpring.p.X + Anim.Rot.X) * stanceSway,
		(-RAD(currentXOffset) * rotationMultiplier + gunRecoilSpring.p.Y + Anim.Rot.Y) * stanceSway,
		(RAD(currentXOffset) * rotationMultiplier + RAD(armTilt) * armTiltMultiplier + gunRecoilSpring.p.Z + Anim.Rot.Z) * stanceSway
	) * CF(
		(Anim.Pos.X + recoilAnim.Pos.X) * stanceSway,
		jumpAnim.Pos * COS(camAng.Y) * jumpAnimMultiplier + (Anim.Pos.Y + recoilAnim.Pos.Y) * stanceSway,
		-jumpAnim.Pos * SIN(camAng.Y) * jumpAnimMultiplier + (Anim.Pos.Z + recoilAnim.Pos.Z) * stanceSway
	), CFANG(-camAng.Y * crawlAlpha / 90, 0, 0) * CF(aimHeadOffset, -1, 0)
end

--------------------[ FIRING FUNCTIONS ]----------------------------------------------

function lowerSpread()
	if (not loweringSpread) then
		loweringSpread = true
		local Connection = nil
		Connection = RS.Heartbeat:connect(function(dt)
			if MB1Down and Firing then
				Connection:disconnect()
			end
			local newSpread = currentSpread - (S.spreadSettings.Decrease * dt)
			currentSpread = (newSpread < 0 and 0 or newSpread)
			if currentSpread == 0 then
				Connection:disconnect()
			end
		end)
		loweringSpread = false
	end
end

local function autoFire()
	if (not canFire) then return end
	canFire = false
	
	if (not Knifing) then
		Firing = true
		while MB1Down and (not Reloading) and (not isCrawling) and (not Knifing) do
			if Modes[((rawFireMode - 1) % numModes) + 1] ~= "AUTO" then break end
			if Humanoid.Health == 0 then break end
			if Ammo.Value > 0 then
				Ammo.Value = Ammo.Value - 1
				if Aimed and steadyKeyPressed and S.scopeSettings.unSteadyOnFire then
					steadyKeyPressed = false
					currentSteadyTime = 0
				end
				newMag = false
				fireGun()
			end
			if S.reloadSettings.magIsBullet then
				for _, Mag in pairs(Gun:GetChildren()) do
					if Mag.Name:sub(1, 3) == "Mag" then
						Mag.Transparency = 1
					end
				end
			end
			if Ammo.Value == 0 and S.reloadSettings.autoReload then
				wait(0.2)
				Reload()
			end
			wait(60 / S.roundsPerMin)
		end
	end
	
	Firing = false
	canFire = true
end

local function semiFire()
	if (not canFire) then return end
	canFire = false
	
	if (not Knifing) and (not isCrawling) and Humanoid.Health ~= 0 then
		Firing = true
		if Ammo.Value > 0 then
			Ammo.Value = Ammo.Value - 1
			if Aimed and steadyKeyPressed and S.scopeSettings.unSteadyOnFire then
				steadyKeyPressed = false
				currentSteadyTime = 0
			end
			newMag = false
			fireGun()
		end
		if S.reloadSettings.magIsBullet then
			for _, Mag in pairs(Gun:GetChildren()) do
				if Mag.Name:sub(1, 3) == "Mag" then
					Mag.Transparency = 1
				end
			end
		end
		if Ammo.Value == 0 and S.reloadSettings.autoReload then
			wait(0.2)
			Reload()
		end
		wait(60 / S.roundsPerMin)
	end
	
	Firing = false
	canFire = true
end

local function burstFire()
	if (not canFire) then return end
	canFire = false
	
	local burstTime = 60 / S.roundsPerMin
	if (not Knifing) and (not isCrawling) then
		Firing = true
		for i = 1, S.burstSettings.Amount do
			if Ammo.Value > 0 then
				Ammo.Value = Ammo.Value - 1
				if Humanoid.Health ~= 0 then
					if Aimed and steadyKeyPressed and S.scopeSettings.unSteadyOnFire then
						steadyKeyPressed = false
						currentSteadyTime = 0
					end
					newMag = false
					fireGun()
				end
			end
			if Ammo.Value == 0 and S.reloadSettings.autoReload then
				wait(0.2)
				Reload()
				break
			end
			wait(S.burstSettings.fireRateBurst and burstTime or S.burstSettings.Time / S.burstSettings.Amount)
		end
	end
	if S.reloadSettings.magIsBullet then
		for _, Mag in pairs(Gun:GetChildren()) do
			if Mag.Name:sub(1, 3) == "Mag" then
				Mag.Transparency = 1
			end
		end
	end
	
	Firing = false
	
	wait(S.burstSettings.fireRateBurst and burstTime or S.burstSettings.Wait)
	
	canFire = true
end

function fireGun()
	local fireSound = Handle:FindFirstChild("FireSound")
	Gun.Bolt.Transparency = 1
Gun.BoltBack.Transparency = 0
	if fireSound then fireSound:Play() end
	----------------------------------------------------------------------------------
	for _ = 1, (S.gunType.Shot and S.ShotAmount or 1) do
		local randSpread1 = RAD(RAND(0, 365))
		local randSpread2 = RAD(RAND(-(baseSpread + currentSpread), baseSpread + currentSpread, 0.01))
		local spreadDir = CFrame.fromAxisAngle(V3(0, 0, 1), randSpread1) * CFANG(randSpread2, 0, 0)
		
		local originCF = ((Aimed and S.guiScope) and Head.CFrame or Handle.CFrame) * spreadDir
		local bulletDirection = CF(originCF.p, originCF.p + originCF.lookVector).lookVector
		
		if S.bulletSettings.instantHit then
			local newRay = Ray.new(Main.CFrame.p, bulletDirection * S.bulletSettings.Range)
			local H, P, N = workspace:FindPartOnRayWithIgnoreList(newRay, Ignore)
			local finalP = P
			if H then
				if S.gunType.Explosive then
					if S.explosionSettings.soundId ~= "" then
						local soundPart = Instance.new("Part")
						soundPart.Transparency = 1
						soundPart.Anchored = true
						soundPart.CanCollide = false
						soundPart.Size = V3(1, 1, 1)
						soundPart.CFrame = CFrame.new(P)
						soundPart.Parent = gunIgnore
						
						local Sound = Instance.new("Sound")
						Sound.Pitch = S.explosionSettings.Pitch
						Sound.SoundId = S.explosionSettings.soundId
						Sound.Volume = S.explosionSettings.Volume
						Sound.Parent = soundPart
						Sound:Play()
						
						DS:AddItem(soundPart, Sound.TimeLength)
					end
					createBulletImpact:FireServer(H, P, N, bulletDirection, false, gunIgnore, S)
					createShockwave:FireServer(P, S.explosionSettings.Radius, gunIgnore, S)
					local E = Instance.new("Explosion")
					E.BlastPressure = S.explosionSettings.Pressure
					E.BlastRadius = S.explosionSettings.Radius
					E.DestroyJointRadiusPercent = (S.explosionSettings.rangeBasedDamage and 0 or 1)
					E.ExplosionType = S.explosionSettings.Type
					E.Position = P
					E.Hit:connect(function(Obj, Dist)
						if Obj.Name == "Torso" and (not Obj:IsDescendantOf(Char)) then
							if S.explosionSettings.rangeBasedDamage then
								local Dir = (Obj.Position - P).unit
								local expH, _ = workspace:FindPartOnRayWithIgnoreList(
									Ray.new(P - Dir * 0.1, Dir * 999),
									Ignore
								)
								local rayHitHuman = expH:IsDescendantOf(Obj.Parent)
								if (S.explosionSettings.rayCastExplosions and rayHitHuman) or (not S.explosionSettings.rayCastExplosions) then
									local hitHumanoid = findFirstClass(Obj.Parent, "Humanoid")
									if hitHumanoid and hitHumanoid.Health > 0 and isEnemy(hitHumanoid) then
										local distFactor = Dist / S.explosionSettings.Radius
										local distInvert = math.max(1 - distFactor,0)
										local newDamage = distInvert * getBaseDamage((P - Main.CFrame.p).magnitude)
										
										local Tag = Instance.new("ObjectValue")
										Tag.Value = Player
										Tag.Name = "creator"
										Tag.Parent = hitHumanoid
										DS:AddItem(Tag, 0.3)
										hitHumanoid:TakeDamage(newDamage)
										markHit()
									end
								end
							else
								local hitHumanoid = findFirstClass(Obj.Parent, "Humanoid")
								if hitHumanoid and hitHumanoid.Health > 0 and isEnemy(hitHumanoid) then
									local Tag = Instance.new("ObjectValue")
									Tag.Value = Player
									Tag.Name = "creator"
									Tag.Parent = hitHumanoid
									DS:AddItem(Tag, 0.3)
									markHit()
								end
							end
						end
					end)
					E.Parent = game.Workspace
				else
					_, finalP = penetrateWall(H, P, bulletDirection, N, {Char, ignoreModel}, 0, (P - Main.CFrame.p).magnitude, nil)
				end
			end
			if S.bulletTrail and S.trailSettings.Transparency ~= 1 then
				createTrail:FireServer(Main.CFrame.p, finalP, gunIgnore, S)
			end
		else
				local shell = Instance.new("Part")
	shell.CFrame = Gun.Chamber.CFrame * CFrame.fromEulerAnglesXYZ(-1.5,0,0)
	shell.Size = Vector3.new(1,1,1)
	shell.BrickColor = BrickColor.new(24)
	shell.Reflectance = .5
	shell.CanCollide = false	
	shell.BottomSurface = 0
	shell.TopSurface = 0
	shell.Name = "Shell"
	shell.Velocity = Gun.Chamber.CFrame.lookVector * 30 + Vector3.new(math.random(-10,10),20,math.random(-10,10))
	shell.RotVelocity = Vector3.new(0,200,0)
	local shellmesh = Instance.new("CylinderMesh")
	shellmesh.Scale = Vector3.new(0.1, 0.8, 0.1)
	shellmesh.Parent = shell
	shell.Parent = game.Workspace
	game:GetService("Debris"):addItem(shell,2)
	
	local shellmesh = Instance.new("SpecialMesh")
	shellmesh.Scale = Vector3.new(0.9,0.9,3)
	shellmesh.MeshId = "http://www.roblox.com/asset/?id=95387759"
	shellmesh.TextureId = "http://www.roblox.com/asset/?id=95387789"
	shellmesh.MeshType = "FileMesh"
	shellmesh.Parent = shell
		end
	end
	function MarkHit()
	spawn(function()
		if Gui_Clone:IsDescendantOf(game) then
			Gui_Clone.HitMarker.Visible = true
			local StartMark = tick()
			LastMark = StartMark
			wait(0.5)
			if LastMark <= StartMark then
				Gui_Clone.HitMarker.Visible = false
			end
		end
	end)
end
	
	----------------------------------------------------------------------------------
	
	currentSpread = currentSpread + S.spreadSettings.Increase
	
	for _, Plugin in pairs(Plugins.Firing) do
		spawn(function()
			Plugin()
		end)
	end
	
	local backRecoil = RAND(S.recoilSettings.Recoil.Back.Min, S.recoilSettings.Recoil.Back.Max, 0.01) --Get the kickback recoil
	local upRecoil = RAND(S.recoilSettings.Recoil.Up.Min, S.recoilSettings.Recoil.Up.Max, 0.01) --Get the up recoil
	local sideRecoilAlpha = 0
	if lastSideRecoil[1] < 0 and lastSideRecoil[2] < 0 then --This conditional basically makes sure the gun tilt isn't in the same direction for more than 2 shots
		sideRecoilAlpha = RAND(0, 1, 0.1)
	elseif lastSideRecoil[1] > 0 and lastSideRecoil[2] > 0 then
		sideRecoilAlpha = RAND(-1, 0, 0.1)
	else
		sideRecoilAlpha = RAND(-1, 1, 0.1)
	end
	local sideRecoil = numLerp(S.recoilSettings.Recoil.Side.Left, S.recoilSettings.Recoil.Side.Right, sideRecoilAlpha / 2 + 0.5) --Get the side recoil
	local tiltRecoil = numLerp(S.recoilSettings.Recoil.Tilt.Left, S.recoilSettings.Recoil.Tilt.Right, sideRecoilAlpha / 2 + 0.5) --Get the tilt recoil
	local recoilPos = V3(
		0,---sideRecoil,
		0,
		-backRecoil
	) * (Aimed and S.recoilSettings.aimedMultiplier or 1)
	local recoilRot = V3(
		(Aimed and 0 or (-RAD(upRecoil * 10) * (firstShot and S.recoilSettings.firstShotMultiplier or 1))),
		RAD(sideRecoil * 10),
		RAD(tiltRecoil * 10)
	) * (Aimed and S.recoilSettings.aimedMultiplier or 1)
	local camRecoilRot = V3(
		-RAD(sideRecoil * 10),
		RAD(upRecoil * 10) * (firstShot and S.recoilSettings.firstShotMultiplier or 1) * S.recoilSettings.camMultiplier,
		0
	) * (Aimed and S.recoilSettings.aimedMultiplier or 1) * stanceSway
	tweenRecoil(recoilPos, recoilRot, Sine, 0.2)
	tweenCam("Recoil", camRecoilRot, Sine, 0.15 * (firstShot and S.recoilSettings.firstShotMultiplier or 1))
	
	for _, v in pairs(Main:GetChildren()) do
		if v.Name:sub(1, 7) == "FlashFX" then
			Gun.Bolt.Transparency = 1
Gun.BoltBack.Transparency = 0
			v.Enabled = true
		end
	end
	
	delay(1 / 20, function()
		tweenRecoil(V3(), V3(), Sine, 0.2)
		tweenCam("Recoil", V3(), Sine, 0.2)
		for _, v in pairs(Main:GetChildren()) do
			if v.Name:sub(1, 7) == "FlashFX" then
	Gun.Bolt.Transparency = 0
Gun.BoltBack.Transparency = 1
				v.Enabled = false
			end
		end
	end)
	
	updateClipAmmo()
	firstShot = false
	shotCount = shotCount + 1
	lastSideRecoil[(shotCount % 2) + 1] = sideRecoilAlpha
end

function markHit()
	spawn(function()
		if mainGUI:IsDescendantOf(game) then
			hitMarker.Visible = true
			local startMark = tick()
			hitMarker.lastMark.Value = startMark
			
			wait(0.5)
			
			if hitMarker.lastMark.Value <= startMark then
				hitMarker.Visible = false
			end
		end
	end)
end

--------------------[ ADS FUNCTIONS ]-------------------------------------------------

function aimGun()
	if Reloading or Knifing or isCrawling or (not S.canADS) then return end
	
	mouseSensitivity = aimSensitivity
	
	for _, Plugin in pairs(Plugins.Aimed) do
		spawn(function()
			Plugin()
		end)
	end
	
	Aimed = true
	Aiming = true
	Running = false
	spreadZoom = "Aimed"
	baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	if S.aimSettings.Anim then
		local currentFOV = Cam.FieldOfView
		local currentTrans = Scope.BackgroundTransparency
		tweenJoint(LWeld, armC0[1], S.aimedC1.leftArm, Sine, S.aimSettings.Speed)
		tweenJoint(RWeld, armC0[2], S.aimedC1.rightArm, Sine, S.aimSettings.Speed)
		tweenJoint(LWeld2, nil, CF(), Sine, S.aimSettings.Speed)
		tweenJoint(RWeld2, nil, CF(), Sine, S.aimSettings.Speed)
		tweenJoint(Grip, nil, aimedGripCF, Sine, S.aimSettings.Speed)
		tweenJoint(headWeld2, nil, CF(0, -0.5, 0) * CFANG(0, 0, S.aimSettings.headTilt) * CF(0, 0.5, 0), Sine, S.aimSettings.Speed)
		local t0 = tick()
		while true do
			RS.RenderStepped:wait()
			local Alpha = math.min((tick() - t0) / S.aimSettings.Speed, 1) * 90
			if (not Aimed) then break end
			if (not Selected) then break end
			aimAlpha = Sine(Alpha)
			aimHeadOffset = headOffset.X * aimAlpha
			jumpAnimMultiplier = numLerp(1, S.fallSettings.aimEffect, aimAlpha)
			translationDivisor = numLerp(7, 20, aimAlpha)
			rotationMultiplier = numLerp(S.momentumSettings.Amplitude.unAimed, S.momentumSettings.Amplitude.Aimed, aimAlpha)
			armTiltMultiplier = numLerp(1, 0.2, aimAlpha)
			Cam.FieldOfView = numLerp(currentFOV, S.aimSettings.FOV, aimAlpha)
			if S.guiScope then
				Scope.BackgroundTransparency = numLerp(currentTrans, 0, aimAlpha)
			end
			if Alpha == 90 then break end
		end
	else
		LWeld.C0, LWeld.C1 = armC0[1], S.aimedC1.leftArm
		RWeld.C0, RWeld.C1 = armC0[2], S.aimedC1.rightArm
		LWeld2.C1, RWeld2.C1 = CF(), CF()
		animWeld.C0 = CF(0, 1, 0)
		Grip.C1 = aimedGripCF
		headWeld2.C1 = CF(0, -0.5, 0) * CFANG(0, 0, S.aimSettings.headTilt) * CF(0, 0.5, 0)
		aimAlpha = 1
		aimHeadOffset = headOffset.X
		jumpAnimMultiplier = S.fallSettings.aimEffect
		translationDivisor = 20
		rotationMultiplier = S.momentumSettings.Amplitude.Aimed
		armTiltMultiplier = 0.2
		Cam.FieldOfView = S.aimSettings.FOV
	end
	Aiming = (not Aimed)
	if (not Aiming) and S.guiScope then
		spawn(function()
			scopeSteady.Visible = true
			Scope.BackgroundTransparency = 1
			scopeMain.Visible = true
			
			if armTable then
				for _, Obj in pairs(armTable[1].Model:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 1
					end
				end
				for _, Obj in pairs(armTable[2].Model:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 1
					end
				end
			elseif armModel then
				for _, Obj in pairs(armModel:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 1
					end
				end
			end
			for _, Obj in pairs(playerFolder:GetChildren()) do
				if Obj:IsA("BasePart") then
					Obj.LocalTransparencyModifier = 1
				end
			end
			for _, Obj in pairs(Gun:GetChildren()) do
				if Obj:IsA("BasePart") then
					Obj.LocalTransparencyModifier = 1
				end
			end
		end)
		spawn(function()
			local camAng = 0
			local idleCam = function()
				return V3(
					RAD(SIN(camAng * S.scopeSettings.Frequency.Idling)) * stanceSway * camSway * S.scopeSettings.Amplitude.Idling,
					RAD(SIN(camAng * 5 / 2 * S.scopeSettings.Frequency.Idling)) * stanceSway * camSway * S.scopeSettings.Amplitude.Idling * 0.75,
					0
				)
			end
			local walkCam = function()
				return V3(
					RAD(SIN(camAng * S.scopeSettings.Frequency.Walking)) * camSway * stanceSway * S.scopeSettings.Amplitude.Walking,
					RAD(SIN(camAng * 5 / 2 * S.scopeSettings.Frequency.Walking)) * camSway * stanceSway * S.scopeSettings.Amplitude.Walking * 0.75,
					0
				)
			end
			while Aimed do
				local dt = RS.RenderStepped:wait()
				camOffsets.guiScope.Rot = (Sine(idleAlpha) * idleCam()) + (Sine(walkAlpha) * walkCam())
				camAng = camAng + RAD(105 * dt) * stanceSway * camSway
			end
		end)
	end
end

function unAimGun(Exception)
	if (not S.canADS) then return end
	
	mouseSensitivity = S.sensitivitySettings.Default
	
	for _, Plugin in pairs(Plugins.UnAimed) do
		spawn(function()
			Plugin()
		end)
	end
	
	if S.guiScope then
		spawn(function()
			if armTable then
				for _, Obj in pairs(armTable[1].Model:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 0
					end
				end
				for _, Obj in pairs(armTable[2].Model:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 0
					end
				end
			elseif armModel then
				for _, Obj in pairs(armModel:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 0
					end
				end
			end
			for _, Obj in pairs(playerFolder:GetChildren()) do
				if Obj:IsA("BasePart") then
					Obj.LocalTransparencyModifier = 0
				end
			end
			for _, Obj in pairs(Gun:GetChildren()) do
				if Obj:IsA("BasePart") then
					Obj.LocalTransparencyModifier = 0
				end
			end
		end)
	end
	
	if (not Exception) then
		if (not Aimed) then return end
		if (Reloading and Exception) or Knifing then return end
		spreadZoom = "unAimed"
		baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
		Aimed = false
		Aiming = true
		if S.aimSettings.Anim then
			local currentFOV = Cam.FieldOfView
			local currentTrans = (Scope.BackgroundTransparency == 1 and (S.guiScope and 0 or 1) or Scope.BackgroundTransparency)
			scopeMain.Visible = false
			scopeSteady.Visible = false
			tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, S.aimSettings.Speed)
			tweenJoint(RWeld, armC0[2], S.unAimedC1.rightArm, Sine, S.aimSettings.Speed)
			tweenJoint(headWeld2, nil, CF(), Sine, S.aimSettings.Speed)
			tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, S.aimSettings.Speed)
			local t0 = tick()
			while true do
				RS.RenderStepped:wait()
				local Alpha = math.min((tick() - t0) / S.aimSettings.Speed, 1) * 90
				if Aimed then break end
				if (not Selected) then break end
				aimAlpha = 1 - Sine(Alpha)--1 - COS(RAD(X))
				aimHeadOffset = headOffset.X * aimAlpha
				jumpAnimMultiplier = numLerp(1, S.fallSettings.aimEffect, aimAlpha)
				translationDivisor = numLerp(7, 20, aimAlpha)
				rotationMultiplier = numLerp(S.momentumSettings.Amplitude.unAimed, S.momentumSettings.Amplitude.Aimed, aimAlpha)
				armTiltMultiplier = numLerp(1, 0.2, aimAlpha)
				Cam.FieldOfView = numLerp(80, currentFOV, aimAlpha)
				Scope.BackgroundTransparency = numLerp(1, currentTrans, aimAlpha)
				if Alpha == 90 then break end
			end
		else
			scopeMain.Visible = false
			scopeSteady.Visible = false
			LWeld.C0, LWeld.C1 = armC0[1], S.unAimedC1.leftArm
			RWeld.C0, RWeld.C1 = armC0[2], S.unAimedC1.rightArm
			headWeld2.C0 = CF()
			Grip.C1 = S.unAimedC1.Grip
			aimAlpha = 0
			aimHeadOffset = 0
			jumpAnimMultiplier = 1
			translationDivisor = 7
			rotationMultiplier = S.momentumSettings.Amplitude.unAimed
			armTiltMultiplier = 1
			Cam.FieldOfView = 80
			Scope.BackgroundTransparency = 1
		end
		Aiming = Aimed
	else
		spawn(function()
			Aimed = false
			Aiming = false
			spreadZoom = "unAimed"
			baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
			local currentFOV = Cam.FieldOfView
			local currentTrans = (Scope.BackgroundTransparency == 1 and (S.guiScope and 0 or 1) or Scope.BackgroundTransparency)
			scopeMain.Visible = false
			scopeSteady.Visible = false
			tweenJoint(headWeld2, nil, CF(), Sine, S.aimSettings.Speed)
			if S.aimSettings.Anim then
				local t0 = tick()
				while true do
					RS.RenderStepped:wait()
					local Alpha = math.min((tick() - t0) / S.aimSettings.Speed, 1) * 90
					if Aimed then break end
					if (not Selected) then break end
					aimAlpha = 1 - Sine(Alpha)--1 - COS(RAD(90 - Alpha))
					aimHeadOffset = headOffset.X * aimAlpha
					jumpAnimMultiplier = numLerp(1, S.fallSettings.aimEffect, aimAlpha)
					translationDivisor = numLerp(7, 20, aimAlpha)
					rotationMultiplier = numLerp(S.momentumSettings.Amplitude.unAimed, S.momentumSettings.Amplitude.Aimed, aimAlpha)
					armTiltMultiplier = numLerp(1, 0.2, aimAlpha)
					Cam.FieldOfView = numLerp(80, currentFOV, aimAlpha)
					Scope.BackgroundTransparency = numLerp(1, currentTrans, aimAlpha)
					if Alpha == 90 then break end
				end
			else
				scopeMain.Visible = false
				scopeSteady.Visible = false
				aimAlpha = 0
				aimHeadOffset = 0
				jumpAnimMultiplier = 1
				translationDivisor = 7
				rotationMultiplier = S.momentumSettings.Amplitude.unAimed
				armTiltMultiplier = 1
				Cam.FieldOfView = 80
				Scope.BackgroundTransparency = 1
			end
		end)
	end
end

--------------------[ TEXTURE CREATION FUNCTIONS ]------------------------------------

function createBullet(Direction)
	local Origin = Gun.Main.CFrame.p
	local bulletCF = CF(Origin, Origin + Direction)
	local Bullet = Instance.new("Part")
	Bullet.BrickColor = S.bulletSettings.Color
	Bullet.Material = Enum.Material.Neon
	Bullet.Name = "Bullet"
	Bullet.CanCollide = false
	Bullet.FormFactor = "Custom"
	Bullet.Size = S.bulletSettings.Size
	Bullet.BottomSurface = "Smooth"
	Bullet.TopSurface = "Smooth"
	if math.min(S.bulletSettings.Size.X, S.bulletSettings.Size.Y, S.bulletSettings.Size.Z) < 0.2 then
		local Mesh = Instance.new("BlockMesh")
		Mesh.Scale = S.bulletSettings.Size / Vector3.new(
			math.max(S.bulletSettings.Size.X, 0.2),
			math.max(S.bulletSettings.Size.Y, 0.2),
			math.max(S.bulletSettings.Size.Z, 0.2)
		)
		Mesh.Parent = Bullet
	end
	local BF = Instance.new("BodyForce")
	BF.force = V3(0, Bullet:GetMass() * (196.2 - S.bulletSettings.Acceleration), 0)
	BF.Parent = Bullet
	Bullet.Parent = gunIgnore
	Bullet.CFrame = bulletCF + Direction * S.bulletSettings.Size.Z / 2
	Bullet.Velocity = Direction * S.bulletSettings.Velocity
	return Bullet
end

--------------------[ HIT HANDLING FUNCTIONS ]----------------------------------------

function getBaseDamage(Dist)
	local startDmg = S.damageSettings.Start.Damage
	local startDist = S.damageSettings.Start.Dist
	local endDmg = S.damageSettings.End.Damage
	local endDist = S.damageSettings.End.Dist
	return (
		(
			Dist < startDist * S.bulletSettings.Range
		) and startDmg or
		(
			Dist >= startDist * S.bulletSettings.Range and
			Dist < endDist * S.bulletSettings.Range
		) and numLerp(startDmg, endDmg, Map(Dist / S.bulletSettings.Range, startDist, endDist, 0, 1)) or
		(
			Dist >= endDist * S.bulletSettings.Range
		) and endDmg
	)
end

function Damage(H, P, N, D, Dist, customIgnore)
	local hVal = S.damageSettings.Multipliers.Head
	local cVal = S.damageSettings.Multipliers.Chest
	local lVal = S.damageSettings.Multipliers.Limbs
	local baseDamage = getBaseDamage(Dist)
	if Humanoid.Health ~= 0 then
		local hitHumanoid = nil
		if H.Parent:IsA("Hat") then
			table.insert(customIgnore, H)
			local newRay = Ray.new(P - D * 0.1, D * (S.bulletSettings.Range - Dist + 0.1))
			local newH, newP, newN = workspace:FindPartOnRayWithIgnoreList(newRay, customIgnore)
			if newH then
				hitHumanoid = Damage(newH, newP, newN, D, Dist + (newP - P).magnitude, customIgnore)
			end
		else
			hitHumanoid = findFirstClass(H.Parent, "Humanoid")
			if hitHumanoid and hitHumanoid.Health > 0 and isEnemy(hitHumanoid) then
				local Tag = Instance.new("ObjectValue")
				Tag.Value = Player
				Tag.Name = "creator"
				Tag.Parent = hitHumanoid
				DS:AddItem(Tag, 0.3)
				local chosenDamage = 0
				if H.Name == "Head" then
					chosenDamage = baseDamage  * RAND(hVal, hVal + 0.1, 0.01)
				elseif H.Name == "Torso" then
					chosenDamage = baseDamage  * RAND(cVal, cVal + 0.1, 0.01)
				else
					chosenDamage = baseDamage  * RAND(lVal, lVal + 0.1, 0.01)
				end
				hitHumanoid:TakeDamage(chosenDamage)
				markHit()
			end
		end
		return hitHumanoid
	end
end

function isWallIgnored(Wall)
	return (
		Wall.Transparency >= S.penetrationSettings.transparencyThreshold or
		(S.penetrationSettings.ignoreNonCanCollide and (not Wall.CanCollide)) or
		isIgnored(Wall, S.penetrationSettings.ignoreCustom)
	)
end

function penetrateWall(Wall, hitPos, Direction, Normal, Ignore, totalPDist, totalBDist, lastDamagedHumanoid)
	local wallIgnore = isWallIgnored(Wall)
	local hitHumanoid = (Wall.Parent:IsA("Hat") and findFirstClass(Wall.Parent.Parent, "Humanoid") or findFirstClass(Wall.Parent, "Humanoid"))
	local damagedHumanoid = nil
	if hitHumanoid and hitHumanoid ~= lastDamagedHumanoid then
		lastDamagedHumanoid = hitHumanoid
		damagedHumanoid = Damage(Wall, hitPos, Normal, Direction, totalBDist, {Char, ignoreModel})
	else
		lastDamagedHumanoid = nil
	end
	local ignoreObject = hitHumanoid and (Wall.Parent:IsA("Hat") and Wall.Parent.Parent or Wall.Parent) or Wall
	table.insert(Ignore, ignoreObject)
	local rayLength = S.bulletSettings.Range - totalBDist
	local testRay = Ray.new(hitPos, Direction * (S.bulletSettings.Range - totalBDist))
	local H1, P1, N1 = workspace:FindPartOnRayWithIgnoreList(testRay, Ignore)
	local newIgnore = removeElement(Ignore, ignoreObject)
	local wallRay = Ray.new(P1 + Direction * 0.1, -Direction * (rayLength + 1))
	local H2, P2, N2 = workspace:FindPartOnRayWithIgnoreList(wallRay, Ignore)
	local newPDist = totalPDist + (wallIgnore and 0 or (getNearestPoint(P1, P2, hitPos) - hitPos).magnitude)
	local newBDist = totalBDist + (P1 - hitPos).magnitude
	local outOfRange = Round(newPDist, 0.001) > S.penetrationSettings.Dist or Round(newBDist, 0.001) > S.bulletSettings.Range
	if (not wallIgnore) then
		createBulletImpact:FireServer(Wall, hitPos, Normal, Direction, hitHumanoid, gunIgnore, S)
		if (not hitHumanoid) then
			createShockwave:FireServer(hitPos, S.shockwaveSettings.Radius, gunIgnore, S)
		end
	end
	if hitHumanoid and hitHumanoid.Health > 0 and isEnemy(hitHumanoid) and hitHumanoid == damagedHumanoid then
		createBlood:FireServer(Wall, P2, Direction, gunIgnore, S)
	end
	if outOfRange or (not H1) then
		if (not outOfRange) and (not wallIgnore) then
			createBulletImpact:FireServer(Wall, P2, N2, Direction, hitHumanoid, gunIgnore, S)
			if (not hitHumanoid) then
				createShockwave:FireServer(P2, S.shockwaveSettings.Radius, gunIgnore, S)
			end
		end
		return Wall, hitPos
	else
		if Wall == H2 and (not wallIgnore) then
			createBulletImpact:FireServer(Wall, P2, N2, Direction, hitHumanoid, gunIgnore, S)
			if (not hitHumanoid) then
				createShockwave:FireServer(P2, S.shockwaveSettings.Radius, gunIgnore, S)
			end
		end
		return penetrateWall(H1, P1, Direction, N1, Ignore, newPDist, newBDist, lastDamagedHumanoid)
	end
end

function PenetrateWall(HitPos, Direction, HitHumanoid, OriginPos, Bullet, CurrentPDist)
	local HitDist = (HitPos - OriginPos).magnitude
	local Wall, WallHitPos = nil, nil
	local Hum, HumHitPos = nil, nil
	local CustomIgnore = {unpack(Ignore)}
	for i = 1, 10 do
		local WallRay = Ray.new(HitPos - (Direction * 0.1), Direction * S.Penetration)
		local H, P = game.Workspace:FindPartOnRayWithIgnoreList(WallRay, CustomIgnore)
		if H then
			local HitHumanoid = nil
			if H.Parent.ClassName == "Hat" then
				HitHumanoid = findFirstClass(H.Parent.Parent, "Humanoid")
			else
				HitHumanoid = findFirstClass(H.Parent, "Humanoid")
			end
			if HitHumanoid and i ~= 1 then
				Hum, HumHitPos = H, P
				break
			else
				Wall, WallHitPos = H, P
				table.insert(CustomIgnore, H)
			end
		else
			break
		end
	end
	if Wall then
		if S.InstantHit then
			if Hum then
				Damage(Hum.Parent:FindFirstChild("Head"), HumHitPos)
				return HumHitPos
			else
				local HitObj2, HitPos2 = nil, nil
				if HitHumanoid then
					HitObj2, HitPos2 = AdvRayCast(WallHitPos, Direction, S.BulletRange - HitDist, {Wall, HitHumanoid.Parent, unpack(Ignore)})
				else
					HitObj2, HitPos2 = AdvRayCast(WallHitPos, Direction, S.BulletRange - HitDist, {Wall, unpack(Ignore)})
				end
				Damage(HitObj2, HitPos2)
				
				local NewPDist = CurrentPDist + (WallHitPos - HitPos).magnitude
				local NewHitPos2 = HitPos2
				if NewPDist < S.Penetration and HitObj2 then
					NewHitPos2 = PenetrateWall(HitPos2, Direction, HitHumanoid, OriginPos, Bullet, CurrentPDist + NewPDist)
				end
				return NewHitPos2
			end
		else
			local LastPos = WallHitPos
			local TotalDistTraveled = 0
			spawn(function()
				if Hum then
					Damage(Hum.Parent:FindFirstChild("Head"), HumHitPos)
					return HumHitPos
				else
					while true do
						RS.RenderStepped:wait()
						if TotalDistTraveled >= S.BulletRange - HitDist then
							Bullet:Destroy()
							break
						end
						local DistTraveled = (Bullet.Position - LastPos).magnitude
						local NewDirection = (Bullet.Position - LastPos).unit
						local TempHitObj, TempHitPos = nil, nil
						if HitHumanoid then
							TempHitObj, TempHitPos = AdvRayCast(LastPos, NewDirection, DistTraveled, {Wall, HitHumanoid.Parent, unpack(Ignore)})
						else
							TempHitObj, TempHitPos = AdvRayCast(LastPos, NewDirection, DistTraveled, {Wall, unpack(Ignore)})
						end
						if TempHitObj then
							Damage(TempHitObj, TempHitPos)
							
							local NewPDist = CurrentPDist + (WallHitPos - HitPos).magnitude
							local NewTempPos = TempHitPos
							if NewPDist < S.Penetration and TempHitObj then
								NewTempPos = PenetrateWall(TempHitPos, Direction, HitHumanoid, OriginPos, Bullet, CurrentPDist + NewPDist)
							else
								Bullet:Destroy()
							end
							return NewTempPos
						else
							LastPos = Bullet.Position
							TotalDistTraveled = TotalDistTraveled + DistTraveled
						end
					end
				end
			end)
		end
	else
		if Bullet then Bullet:Destroy() end
		return HitPos
	end
end

function isEnemy(Human)
	local Plyr = game.Players:GetPlayerFromCharacter(Human.Parent)
	if (not Plyr) then return S.CanDamageNPCs end
	return S.AllowFriendlyFire or (Plyr.TeamColor ~= Player.TeamColor or Plyr.Neutral)
end

--------------------[ RELOAD FUNCTIONS ]----------------------------------------------

function animateReload()
	tweenJoint(LWeld2, CF(), CF(), Sine, 0.15)
	tweenJoint(RWeld2, CF(), CF(), Sine, 0.15)
	local magParts = {}
	local magTable = {}
			
	for _, Obj in pairs(Gun:GetChildren()) do
		if string.sub(Obj.Name, 1, 3) == "Mag" and Obj:IsA("BasePart") then
			INSERT(magParts, Obj)
		end
	end
	
	local animVars = {
		--FUNCTIONS--
		tweenJoint = tweenJoint;
		
		makeMagInvisible = function()
			for _, v in pairs(magParts) do
				v.Transparency = 1
			end
			magVisible = false
		end;
		
		makeMagVisible = function()
			for _, v in pairs(magParts) do
				v.Transparency = v:WaitForChild("magTrans").Value
			end
			magVisible = true
		end;
		
		isMagVisible = function()
			return magVisible
		end;
		
		isMagEmpty = function()
			return ammoInClip == 0
		end;
		
		setNewMag = function()
			newMag = true
		end;
		
		isNewMag = function()
			return newMag
		end;
		
		createMag = function(Key)
			local magModel = Instance.new("Model")
			local magClones = {}
			for i, v in pairs(magParts) do
				local vClone = v:Clone()
				vClone.Transparency = v:WaitForChild("magTrans").Value
				vClone.CanCollide = false
				vClone.Parent = magModel
				INSERT(magClones, {Original = v, magClone = vClone})
				if i ~= 1 then
					local W = Instance.new("Weld")
					W.Part0 = magClones[1].magClone
					W.Part1 = vClone
					W.C0 = magClones[1].magClone.CFrame:toObjectSpace(vClone.CFrame)
					W.Parent = magClones[1].magClone
				end
			end
			magTable[Key] = {magModel, magClones}
			return magModel, magClones
		end;
		
		getMag = function(Key)
			if magTable[Key] then
				return magTable[Key][1], magTable[Key][2]
			else
				return nil, nil
			end
		end;
		
		attachGripToHead = function()
			local handleCF = RArm.CFrame * Grip.C0
			Grip.C0 = Head.CFrame:toObjectSpace(handleCF)
			Grip.Part0 = Head
		end;
		
		attachGripToArm = function()
			local handleCF = Head.CFrame * Grip.C0
			Grip.C0 = RArm.CFrame:toObjectSpace(handleCF)
			Grip.Part0 = RArm
		end;
		
		Sine = Sine;
		
		Linear = Linear;
		
		--VARIABLES--
		Handle = Handle;
		LArm = LArm;
		RArm = RArm;
		LWeld = LWeld;
		RWeld = RWeld;
		LC0 = armC0[1];
		RC0 = armC0[2];
		Grip = Grip;
		gunIgnore = gunIgnore;
		Cam = Cam;
		CF = CF;
		CFANG = CFANG;
		V3 = V3;
		RAD = RAD;
		reloadTimeLoaded = S.reloadSettings.Times.Loaded;
		reloadTimeEmpty = S.reloadSettings.Times.Empty
	}
	
	local sequenceTable = Anims.Reload(animVars)
	--local T = tick()
	for _, reloadFunction in pairs(sequenceTable) do
		if breakReload then
			break
		end
		reloadFunction()
		
		if (not magVisible) then
			Ammo.Value = 0
		end
		updateClipAmmo()
	end
	--print(tick() - T) --I divide the reloadTime by this number to get the animation speed
	
	if (not isCrawling) then
		if Running and (not S.canFireWhileRunning) then
			tweenJoint(LWeld, armC0[1], S.runningC1.leftArm, Sine, 0.4)
			tweenJoint(RWeld, armC0[2], S.runningC1.rightArm, Sine, 0.4)
			tweenJoint(Grip, nil, S.runningC1.Grip, Sine, 0.4)
		else
			tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, 0.4)
			tweenJoint(RWeld, armC0[2], S.unAimedC1.rightArm, Sine, 0.4)
			tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, 0.4)
		end
	end
	
	for _, v in pairs(magTable) do --In case the reload animations was stopped mid way and there were still fake mags that weren't deleted
		v[1]:Destroy()
	end
end

function Reload()
	if Ammo.Value < (ClipSize.Value + 1) and (not Reloading) and StoredAmmo.Value > 0 then
		Firing = false
		ammoInClip = (ammoInClip == 0 and Ammo.Value or ammoInClip)
		Reloading = true
		lowerSpread()
		if Aimed then unAimGun(S.reloadSettings.Anim) end
		crossHair.Reload.Visible = true
		if Handle:FindFirstChild("ReloadSound") then Handle.ReloadSound:Play() end
		if S.reloadSettings.Anim then
			wait()
			animateReload()
		else
			local startReload = tick()
			local initialReloadTime = Ammo.Value == 0 and S.reloadSettings.Times.Empty or S.reloadSettings.Times.Loaded
			while true do
				if breakReload then break end
				if (tick() - startReload) >= initialReloadTime then break end
				RS.RenderStepped:wait()
			end
		end
		if (not breakReload) then
			newMag = false
			if StoredAmmo.Value >= ClipSize.Value then
				if ammoInClip > 0 then
					StoredAmmo.Value = StoredAmmo.Value - ((ClipSize.Value + 1) - ammoInClip)
					Ammo.Value = ClipSize.Value + 1
				else
					StoredAmmo.Value = StoredAmmo.Value - ClipSize.Value
					Ammo.Value = ClipSize.Value
				end
			elseif StoredAmmo.Value < ClipSize.Value and StoredAmmo.Value > 0 then
				Ammo.Value = StoredAmmo.Value
				StoredAmmo.Value = 0
			end
		end
		Reloading = false
		if Selected then
			ammoInClip = (breakReload and ammoInClip or 0)
			crossHair.Reload.Visible = false
		end
		breakReload = false
	end
	
	updateClipAmmo()
	updateStoredAmmo()
end

--------------------[ EXTERNAL DATA LOCATING FUNCTIONS ]-----------------------------

function removeElement(Table, Element) --removes the first instance of Element from Table
	for i, v in pairs(Table) do
		if v == Element then
			table.remove(Table, i)
			break
		end
	end
	return Table
end

function findFirstClass(Object, Class)
	local foundObject = nil
	for _, Obj in pairs(Object:GetChildren()) do
		if Obj.ClassName == Class then
			foundObject = Obj
			break
		end
	end
	return foundObject
end

function isIgnored(Obj, Table)
	for _,v in pairs(Table) do
		if Obj == v or Obj:IsDescendantOf(v) then
			return true
		end
	end
	return false
end

function GetHitSurfaceCFrame(HitPos,Obj)
	local SurfaceCF = {
		{"Back",Obj.CFrame * CF(0,0,Obj.Size.z)};
		{"Bottom",Obj.CFrame * CF(0,-Obj.Size.y,0)};
		{"Front",Obj.CFrame * CF(0,0,-Obj.Size.z)};
		{"Left",Obj.CFrame * CF(-Obj.Size.x,0,0)};
		{"Right",Obj.CFrame * CF(Obj.Size.x,0,0)};
		{"Top",Obj.CFrame * CF(0,Obj.Size.y,0)}
	}
	local ClosestDist = HUGE
	local ClosestSurface = nil
	for _,v in pairs(SurfaceCF) do
		local SurfaceDist = (HitPos - v[2].p).magnitude
		if SurfaceDist < ClosestDist then
			ClosestDist = SurfaceDist
			ClosestSurface = v
		end
	end
	return ClosestSurface[2]
end

function AdvRayCast(Origin, Direction, Dist, CustomIgnore)
	local NewIgnore = (CustomIgnore and CustomIgnore or Ignore)
	local NewRay = Ray.new(Origin, Direction * (Dist > 999 and 999 or Dist))
	local HitObj, HitPos = game.Workspace:FindPartOnRayWithIgnoreList(NewRay, NewIgnore)
	local LastPos = HitPos
	local FinalHitObj, FinalHitPos = nil, nil
	local RepTimes = math.floor(Dist / 999)
	if (not HitObj) and (Dist > 999) then
		for i = 0, RepTimes do
			local NewDist = (i == RepTimes and  (Dist - (LastPos - Origin).magnitude) or 999)
			local Ray2 = Ray.new(LastPos, Direction * NewDist)
			local HitObj2, HitPos2 = game.Workspace:FindPartOnRayWithIgnoreList(Ray2, NewIgnore)
			if i ~= RepTimes then
				if HitObj2 then
					FinalHitObj, FinalHitPos = HitObj2, HitPos2
					break
				end
			elseif i == RepTimes then
				FinalHitObj, FinalHitPos = HitObj2, HitPos2
			end
			LastPos = HitPos2
		end
		return FinalHitObj, FinalHitPos
	elseif HitObj or (Dist <= 999) then
		return HitObj, HitPos
	end
end

--------------------[ JUMPING ANIMATION ]---------------------------------------------

function onFall(initialVelocity)
	spawn(function()
		local velocityAlpha = math.max(math.min(initialVelocity / Humanoid.JumpPower, 1), 0)
		local startJumpPos = jumpAnim.Pos
		local startJumpRot = jumpAnim.Rot
		local endJumpPos = 0.04 * S.fallSettings.fallMultiplier * velocityAlpha
		local endJumpRot = RAD(4) * S.fallSettings.fallMultiplier * velocityAlpha
		local t0 = tick()
		while true do
			RS.Heartbeat:wait()
			local Alpha = math.min((tick() - t0) / 0.15, 1) * 90
			if onGround then break end
			jumpAnim.Pos = numLerp(startJumpPos, endJumpPos, Sine(Alpha))
			jumpAnim.Rot = numLerp(startJumpRot, endJumpRot, Sine(Alpha))
			if Alpha == 90 then break end
		end
		startJumpPos = endJumpPos
		startJumpRot = endJumpRot
		endJumpPos = -0.08 * S.fallSettings.fallMultiplier
		endJumpRot = -RAD(8) * S.fallSettings.fallMultiplier
		local X = 1
		while true do
			local dt = RS.Heartbeat:wait()
			X = X + (dt * 60) / X
			local Alpha = (X - 1) / 15
			if onGround then break end
			jumpAnim.Pos = numLerp(startJumpPos, endJumpPos, Alpha)
			jumpAnim.Rot = numLerp(startJumpRot, endJumpRot, Alpha)
		end
	end)
end

function onLand(fallDist)
	spawn(function()
		local animAlpha = math.min(fallDist, S.fallSettings.maxDist) * (2 / 3)
		local startJumpPos = jumpAnim.Pos
		local startJumpRot = jumpAnim.Rot
		local endJumpPos = animAlpha / 100 * S.fallSettings.landMultiplier * (runReady and 1 or 2)
		local endJumpRot = RAD(animAlpha) * S.fallSettings.landMultiplier * (runReady and 1 or 2)
		local t0 = tick()
		while true do
			RS.Heartbeat:wait()
			local Alpha = math.min((tick() - t0) / 0.2, 1)
			if (not onGround) then break end
			jumpAnim.Pos = numLerp(startJumpPos, endJumpPos, Alpha)
			jumpAnim.Rot = numLerp(startJumpRot, endJumpRot, Alpha)
			if Alpha == 1 then break end
		end
		t0 = tick()
		while true do
			RS.Heartbeat:wait()
			local Alpha = math.min((tick() - t0) / 0.3, 1) * 90
			if (not onGround) then break end
			jumpAnim.Pos = numLerp(endJumpPos, 0, Sine(Alpha))
			jumpAnim.Rot = numLerp(endJumpRot, 0, Sine(Alpha))
			if Alpha == 90 then break end
		end
	end)
end

function onHumanoidStateChanged(oldState, newState)
	if newState == Enum.HumanoidStateType.Freefall then
		onGround = false
		if S.fallAnimation then
			onFall(HRP.Velocity.Y)
			while HRP.Velocity.Y > 0 do RS.RenderStepped:wait() end
			startFallHeight = HRP.Position.Y
		end
	elseif oldState == Enum.HumanoidStateType.Freefall then
		onGround = true
		if S.fallAnimation then
			local fallDist = startFallHeight - HRP.Position.Y
			onLand(fallDist)
		end
	end
end
--------------------[ CAMERA STEADYING FUNCTIONS ]------------------------------------

function steadyCamera()
	scopeSteady.Text = "Steadying..."
	scopeSteady.TextColor3 = Color3.new(1, 1, 0)
	camSteady = true
	local originalSway = camSway
	local Increment = 1.5 / 0.6
	local X = 0
	while true do
		RS.RenderStepped:wait()
		local newX = X + Increment
		X = (newX > 90 and 90 or newX)
		if (not steadyKeyPressed) then break end
		camSway = numLerp(originalSway, 0, Sine(X))
		if X == 90 then break end
	end
	while steadyKeyPressed and Aimed do
		if currentSteadyTime > 0 then
			local NewSteadyTime = currentSteadyTime - 1
			currentSteadyTime = (NewSteadyTime < 0 and 0 or NewSteadyTime)
			camSway = 0
		elseif currentSteadyTime == 0 then
			break
		end
		RS.RenderStepped:wait()
	end
	camSteady = false
	spawn(function()
		local Increment = 1.5 / 0.25
		local X = 0
		while true do
			RS.RenderStepped:wait()
			local newX = X + Increment
			X = (newX > 90 and 90 or newX)
			if camSteady then break end
			camSway = numLerp(0, S.scopeSettings.camSwayOnBreath, 1 - COS(RAD(X)))
			if X == 90 then break end
		end
		Increment = 1.5 / S.scopeSettings.breathTime
		X = 0
		while true do
			RS.RenderStepped:wait()
			local newX = X + Increment
			X = (newX > 90 and 90 or newX)
			if camSteady then break end
			camSway = numLerp(S.scopeSettings.camSwayOnBreath, 1, Sine(X))
			if X == 90 then break end
		end
		--[[for X = 0, 90, 1.5 / 0.2 do
			local Alpha = 1 - COS(RAD(X))--math.log10(X) / math.log10(90)
			camSway = numLerp(0, 3, Alpha)
			RS.RenderStepped:wait()
		end]]
		--[[for X = 0, 90, 1.5 / S.scopeSettings.steadyTime do
			if camSteady then break end
			local Alpha = SIN(RAD(X))
			camSway = numLerp(3, 1, Alpha)
			RS.RenderStepped:wait()
		end]]
	end)
	retakeBreath()
end

function retakeBreath()
	scopeSteady.Text = "Re-taking Breath"
	scopeSteady.TextColor3 = Color3.new(1, 0, 0)
	takingBreath = true
	local Increment = S.scopeSettings.steadyTime / S.scopeSettings.breathTime
	while takingBreath do
		if currentSteadyTime < maxSteadyTime then
			local newSteadyTime = currentSteadyTime + Increment
			currentSteadyTime = (newSteadyTime > maxSteadyTime and maxSteadyTime or newSteadyTime)
		elseif currentSteadyTime >= maxSteadyTime then
			break
		end
		RS.RenderStepped:wait()
	end
	if takingBreath then
		scopeSteady.Text = "Hold "..convertKey(S.Keys.scopeSteady).." to Steady"
		scopeSteady.TextColor3 = Color3.new(1, 1, 0)
		takingBreath = false
	end
end

--------------------[ SPRINTING FUNCTIONS ]-------------------------------------------

function canRun(midRun)
	return ((Forward and (not Backward)) and
		Walking and (Stamina > 0) and Running and
		Selected and (midRun and true or onGround) and
		runReady and (S.canFireWhileRunning and true or (not Firing))
	)
end

function monitorStamina()
	Running = true
	if (not canRun(false)) then
		Running = false
		return
	end
	if Aimed then unAimGun(true) end
	if Stance == 1 or Stance == 2 then Stand() end
	if (not (Reloading and S.reloadSettings.Anim)) then
		if S.canFireWhileRunning then
			tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, 0.4)
			tweenJoint(RWeld, armC0[2], S.unAimedC1.rightArm, Sine, 0.4)
			tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, 0.4)
		else
			tweenJoint(LWeld, armC0[1], S.runningC1.leftArm, Sine, 0.4)
			tweenJoint(RWeld, armC0[2], S.runningC1.rightArm, Sine, 0.4)
			tweenJoint(Grip, nil, S.runningC1.Grip, Sine, 0.4)
		end
	end
	crossOffset = 50
	while runKeyPressed do
		if canRun(true) then
			if onGround then
				local newStamina = Stamina - 1
				Stamina = (newStamina < 0 and 0 or newStamina)
			end
		else
			break
		end
		RS.RenderStepped:wait()
	end
	Running = false
	if (not Aimed) and (not (Reloading and S.reloadSettings.Anim)) and (not S.canFireWhileRunning) then
		crossOffset = 0
		tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, 0.4)
		tweenJoint(RWeld, armC0[2], S.unAimedC1.rightArm, Sine, 0.4)
		tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, 0.4)
	end
	
	rechargeStamina()
end

function rechargeStamina()
	chargingStamina = true
	while ((not runKeyPressed) or (Stamina < maxStamina)) and (not Running) do
		if Stamina < maxStamina then
			local newStamina = Stamina + (S.sprintTime / S.staminaCoolTime)
			Stamina = (newStamina > maxStamina and maxStamina or newStamina)
		elseif Stamina >= maxStamina then
			break
		end
		RS.RenderStepped:wait()
	end
	chargingStamina = false
end

--------------------[ STANCE FUNCTIONS ]----------------------------------------------

function Stand(onDeselected)
	local LHip = Torso["Left Hip"]
	local RHip = Torso["Right Hip"]
	LLegWeld.Part1 = nil
	LHip.Part1 = LLeg
	RLegWeld.Part1 = nil
	RHip.Part1 = RLeg
	Stance = 0
	spreadStance = "Stand"
	baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	if S.stanceSettings.Anim and (not onDeselected) then
		spawn(function()
			local prevStanceSway = stanceSway
			local X = 0
			local Increment = 1.5 / S.stanceSettings.Speed
			while true do
				RS.RenderStepped:wait()
				local newX = X + Increment
				X = (newX > 90 and 90 or newX)
				if Stance ~= 0 then break end
				stanceSway = numLerp(prevStanceSway, 1, Sine(X))
				if X == 90 then break end
			end
		end)
		tweenJoint(ABWeld, CF(), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LLegWeld, legC0.Stand[1], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(RLegWeld, legC0.Stand[2], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LHip, CF(-1, -1, 0) * CFANG(0, RAD(-90), 0), CF(-0.5, 1, 0) * CFANG(0, RAD(-90), 0), Sine, S.stanceSettings.Speed)
		tweenJoint(RHip, CF(1, -1, 0) * CFANG(RAD(-180), RAD(90), 0), CF(0.5, 1, 0) * CFANG(RAD(-180), RAD(90), 0), Sine, S.stanceSettings.Speed)
		tweenJoint(Root, CFANG(RAD(-90), 0, RAD(180)), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(headWeld, CF(0, 1.5, 0), nil, Sine, S.stanceSettings.Speed)
	elseif onDeselected or (not S.stanceSettings.Anim) then
		ABWeld.C0 = CF()
		LLegWeld.C0 = legC0.Stand[1]
		RLegWeld.C0 = legC0.Stand[2]
		LHip.C0, LHip.C1 = CF(-1, -1, 0) * CFANG(0, RAD(-90), 0), CF(-0.5, 1, 0) * CFANG(0, RAD(-90), 0)
		RHip.C0, RHip.C1 = CF(1, -1, 0) * CFANG(RAD(-180), RAD(90), 0), CF(0.5, 1, 0) * CFANG(RAD(-180), RAD(90), 0)
		Root.C0 = CFANG(RAD(-90), 0, RAD(180))
		headWeld.C0 = CF(0, 1.5, 0)
	end
end

function Crouch()
	local LHip = Torso["Left Hip"]
	local RHip = Torso["Right Hip"]
	LHip.Part1 = nil
	LLegWeld.Part1 = LLeg
	RHip.Part1 = nil
	RLegWeld.Part1 = RLeg
	Stance = 1
	spreadStance = "Crouch"
	baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	if S.stanceSettings.Anim then
		spawn(function()
			local prevStanceSway = stanceSway
			local X = 0
			local Increment = 1.5 / S.stanceSettings.Speed
			while true do
				RS.RenderStepped:wait()
				local newX = X + Increment
				X = (newX > 90 and 90 or newX)
				if Stance ~= 1 then break end
				stanceSway = numLerp(prevStanceSway, 0.75, Sine(X))
				if X == 90 then break end
			end
		end)
		tweenJoint(ABWeld, CF(0, 0, -0.05), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LLegWeld, legC0.Crouch[1], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(RLegWeld, legC0.Crouch[2], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LHip, CF(-1, -0.5, 0) * CFANG(0, RAD(-90), 0), CF(-0.5, 0.5, 1) * CFANG(0, RAD(-90), RAD(-90)), Sine, S.stanceSettings.Speed)
		tweenJoint(RHip, CF(1, -0.5, 0.25) * CFANG(RAD(-180), RAD(90), 0), CF(0.5, 0.5, 1) * CFANG(RAD(-180), RAD(90), 0), Sine, S.stanceSettings.Speed)
		tweenJoint(Root, CF(0, -1, 0) * CFANG(RAD(-90), 0, RAD(180)), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(headWeld, CF(0, 1.5, 0), nil, Sine, S.stanceSettings.Speed)
	else
		ABWeld.C0 = CF(0, 0, -1 / 16)
		LLegWeld.C0 = legC0.Crouch[1]
		RLegWeld.C0 = legC0.Crouch[2]
		LHip.C0, LHip.C1 = CF(-1, -0.5, 0) * CFANG(0, RAD(-90), 0), CF(-0.5, 0.5, 1) * CFANG(0, RAD(-90), RAD(-90))
		RHip.C0, RHip.C1 = CF(1, -0.5, 0.25) * CFANG(RAD(-180), RAD(90), 0), CF(0.5, 0.5, 1) * CFANG(RAD(-180), RAD(90), 0)
		Root.C0 = CF(0, -1, 0) * CFANG(RAD(-90), 0, RAD(180))
		headWeld.C0 = CF(0, 1.5, 0)
	end
end

function Prone()
	local LHip = Torso["Left Hip"]
	local RHip = Torso["Right Hip"]
	LHip.Part1 = nil
	LLegWeld.Part1 = LLeg
	RHip.Part1 = nil
	RLegWeld.Part1 = RLeg
	Stance = 2
	spreadStance = "Prone"
	baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	if S.stanceSettings.Anim then
		spawn(function()
			local prevStanceSway = stanceSway
			local X = 0
			local Increment = 1.5 / S.stanceSettings.Speed
			while true do
				RS.RenderStepped:wait()
				local newX = X + Increment
				X = (newX > 90 and 90 or newX)
				if Stance ~= 2 then break end
				stanceSway = numLerp(prevStanceSway, 0.5, Sine(X))
				if X == 90 then break end
			end
		end)
		tweenJoint(ABWeld, CF(0, 0, -0.1), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LLegWeld, legC0.Prone[1], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(RLegWeld, legC0.Prone[2], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(Root, CF(0, -2.5, 1) * CFANG(RAD(180), 0, RAD(180)), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(headWeld, CF(0, 1, 1) * CFANG(RAD(90), 0, 0), nil, Sine, S.stanceSettings.Speed)
	else
		ABWeld.C0 = CF(0, 0, -1 / 8)
		LLegWeld.C0 = legC0.Prone[1]
		RLegWeld.C0 = legC0.Prone[2]
		Root.C0 = CF(0, -2.5, 1) * CFANG(RAD(180), 0, RAD(180))
		headWeld.C0 = CF(0, 1, 1) * CFANG(RAD(90), 0, 0)
	end
end

function Dive()
	onGround = false
	local diveDirection = (HRP.CFrame * CFANG(S.diveSettings.Angle, 0, 0)).lookVector * S.walkSpeeds.Sprinting * S.diveSettings.Force
	local BF = Instance.new("BodyForce")
	BF.force = diveDirection + Vector3.new(0, playerMass * 196.2, 0)
	BF.Parent = HRP
	--[[spawn(function()
		HRP.Velocity = HRP.CFrame.lookVector * 60 + V3(0, 40, 0)
		wait(0.1)
		HRP.Velocity = HRP.CFrame.lookVector * 70 + V3(0, 30, 0)
		wait(0.4)
		HRP.Velocity = HRP.CFrame.lookVector * 30 + V3(0, -10, 0)
	end)]]
	delay(0.05, function()
		spawn(function()
			while true do
				local newRay = Ray.new(HRP.Position, V3(0, -3.1, 0))
				local H, _ = workspace:FindPartOnRayWithIgnoreList(newRay, Ignore)
				if H then
					onGround = true
					break
				end
				wait()
			end
		end)
		Prone()
		wait(0.1)
		BF:Destroy()
	end)
end

--------------------[ MOUSE FUNCTIONS ]-----------------------------------------------

function onMB1Down()
	MB1Down = true
	firstShot = true
	if fireFunction then
		fireFunction()
	end
end

function onMB1Up()
	MB1Down = false
	lowerSpread()
end

function onMB2Down()
	if S.aimSettings.holdToADS then
		if (not AimingIn) and (not Aimed) then
			AimingIn = true
			aimGun()
			AimingIn = false
		end
	else
		if Aimed then
			unAimGun()
		else
			aimGun()
		end
	end
end

function onMB2Up()
	if S.aimSettings.holdToADS then
		if (not AimingOut) and Aimed then
			AimingOut = true
			unAimGun()
			AimingOut = false
		end
	end
end

function onScrollUp()
	local newAimSensitivity = aimSensitivity + S.sensitivitySettings.Increment
	aimSensitivity = (
		newAimSensitivity < S.sensitivitySettings.Min and S.sensitivitySettings.Min or
		newAimSensitivity > S.sensitivitySettings.Max and S.sensitivitySettings.Max or
		newAimSensitivity
	)
	mouseSensitivity = (Aimed and aimSensitivity or mouseSensitivity)
	
	Sens.Text = "S: "..aimSensitivity
	if mainGUI:IsDescendantOf(game) then
		Sens.Visible = true
		local t0 = tick()
		lastSensUpdate = t0
		
		wait(0.3)
		
		if lastSensUpdate <= t0 then
			Sens.Visible = false
		end
	end
end

function onScrollDown()
	local newAimSensitivity = aimSensitivity - S.sensitivitySettings.Increment
	aimSensitivity = (
		newAimSensitivity < S.sensitivitySettings.Min and S.sensitivitySettings.Min or
		newAimSensitivity > S.sensitivitySettings.Max and S.sensitivitySettings.Max or
		newAimSensitivity
	)
	mouseSensitivity = (Aimed and aimSensitivity or mouseSensitivity)
	
	Sens.Text = "S: "..aimSensitivity
	if mainGUI:IsDescendantOf(game) then
		Sens.Visible = true
		local t0 = tick()
		lastSensUpdate = t0
		
		wait(0.3)
		
		if lastSensUpdate <= t0 then
			Sens.Visible = false
		end
	end
end

--------------------[ KEYBOARD FUNCTIONS ]--------------------------------------------

function keyDown(K)
	local Key = string.lower(K)
	
	if Key == S.Keys.lowerStance and S.canChangeStance then
		if (not Running) then
			if Stance == 0 then
				if S.stanceSettings.Stances.Crouch then
					Crouch()
				elseif S.stanceSettings.Stances.Prone then
					Prone()
				end
			elseif Stance == 1 then
				if S.stanceSettings.Stances.Prone then
					Prone()
				end
			end
		elseif S.dolphinDive then
			wait()
			if Humanoid:GetState() ~= Enum.HumanoidStateType.Freefall and (not UIS:IsKeyDown("Space")) and runReady then
				local tempConnection = Humanoid.Changed:connect(function()
					Humanoid.Jump = false
				end)
				runReady = false
				Dive()
				Running = false
				wait(S.diveSettings.rechargeTime)
				tempConnection:disconnect()
				runReady = true
			end
		end
	end
	
	if Key == S.Keys.raiseStance and S.canChangeStance then
		if (not Running) then
			if Stance == 2 then
				if S.stanceSettings.Stances.Crouch then
					Crouch()
				else
					Stand()
				end
			elseif Stance == 1 then
				Stand()
			end
		end
	end
	
	if Key == S.Keys.ADS then
		if S.aimSettings.holdToADS then
			if (not AimingIn) and (not Aimed) then
				AimingIn = true
				aimGun()
				AimingIn = false
			end
		else
			if Aimed then
				unAimGun()
			else
				aimGun()
			end
		end
	end
	
	if Key == S.Keys.selectFire and S.selectFire then
		if canSelectFire then
			canSelectFire = false
			rawFireMode = rawFireMode + 1
			modeGUI.Text = Modes[((rawFireMode - 1) % numModes) + 1]
			if modeGUI.Text == "AUTO" then
				fireFunction = autoFire
			elseif modeGUI.Text == "BURST" then
				fireFunction = burstFire
			elseif modeGUI.Text == "SEMI" then
				fireFunction = semiFire
			else
				fireFunction = nil
			end
			local speedAlpha = S.selectFireSettings.animSpeed / 0.6
			if S.selectFireSettings.GUI then
				spawn(function()
					fireSelect.Visible = true
					local prevRawFireMode = rawFireMode
					local Increment = 1.5 / (speedAlpha * 0.25)
					local X = 0
					wait(speedAlpha * 0.1)
					while true do
						RS.RenderStepped:wait()
						local newX = X + Increment
						X = (newX > 90 and 90 or newX)
						if prevRawFireMode ~= rawFireMode then break end
						updateModeLabels(rawFireMode - 1, rawFireMode, X)
						if X == 90 then break end
					end
					wait(speedAlpha * 0.25)
					fireSelect.Visible = false
				end)
			end
			if S.selectFireSettings.Animation and (not Aimed) and (not isRunning) and (not isCrawling) then
				spawn(function()
					local sequenceTable = {
						function()
							tweenJoint(RWeld2, nil, CFANG(0, RAD(5), 0), Sine, speedAlpha * 0.15)
							tweenJoint(LWeld, armC0[1], CF(0.1, 1, -0.3) * CFANG(RAD(-7), 0, RAD(-65)), Linear, speedAlpha * 0.15)
							wait(speedAlpha * 0.2)
						end;
						
						function()
							tweenJoint(LWeld, armC0[1], CF(0.1, 1, -0.3) * CFANG(RAD(-10), 0, RAD(-65)), Linear, speedAlpha * 0.1)
							wait(speedAlpha * 0.2)
						end;
						
						function()
							tweenJoint(RWeld2, nil, CF(), Sine, speedAlpha * 0.2)
							tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, speedAlpha * 0.2)
							wait(speedAlpha * 0.2)
						end;
					}
					
					for _, F in pairs(sequenceTable) do
						if Aimed or isRunning or isCrawling or Reloading then
							break
						end
						F()
					end
				end)
			end
			if S.selectFireSettings.Animation or S.selectFireSettings.GUI then
				wait(S.selectFireSettings.animSpeed)
			end
			canSelectFire = true
		end
	end
	
	if Key == S.Keys.Reload then
		if (not Reloading) and (not isCrawling) then
			Reload()
		end
	end
	
	if Key == S.Keys.Sprint then
		runKeyPressed = true
		if runReady then
			if (not Idling) and Walking and (not Running) and (not Knifing) and (not (Aimed and S.guiScope and S.Keys.Sprint == S.Keys.scopeSteady)) then
				monitorStamina()
			end
		end
	end
	
	if Key == S.Keys.scopeSteady then
		steadyKeyPressed = true
		if Aimed and (not Aiming) then
			takingBreath = false
			steadyCamera()
		end
	end
	
	for _, PTable in pairs(Plugins.KeyDown) do
		if Key == string.lower(PTable.Key) then
			spawn(function()
				PTable.Plugin()
			end)
		end
	end
end

function keyUp(K)
	local Key = string.lower(K)
	
	if Key == S.Keys.ADS then
		if S.aimSettings.holdToADS then
			if (not AimingOut) and Aimed then
				AimingOut = true
				unAimGun()
				AimingOut = false
			end
		end
	end
	
	if Key == S.Keys.Sprint then
		runKeyPressed = false
		Running = false
		if (not chargingStamina) then
			rechargeStamina()
		end
	end
	
	if Key == S.Keys.scopeSteady then
		steadyKeyPressed = false
	end
	
	for _, PTable in pairs(Plugins.KeyUp) do
		if Key == string.lower(PTable.Key) then
			spawn(function()
				PTable.Plugin()
			end)
		end
	end
end

--------------------[ END FUNCTIONS ]-------------------------------------------------

--------------------------------------------------------------------------------------
--------------------[ PRE-CONNECTIONS ]-----------------------------------------------
--------------------------------------------------------------------------------------

local function updateAnimVars()
	wait()
	Forward = (UIS:IsKeyDown("W") or UIS:IsKeyDown("Up"))
	Backward = (UIS:IsKeyDown("S") or UIS:IsKeyDown("Down"))
	local Right = UIS:IsKeyDown("D")
	local Left = UIS:IsKeyDown("A")
	
	local walkingForward = (Forward and (not Backward))
	local walkingBackward = ((not Forward) and Backward)
	local walkingRight = (Right and (not Left))
	local walkingLeft = ((not Right) and Left)
	
	if (Forward or Backward or Right or Left) then
		Walking, Idling = true, false
		if (not Running) and (not Aimed) then
			spreadMotion = "Moving"
			baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
		end
	elseif (not (Forward and Backward and Right and Left)) then
		Walking, Idling = false, true
		if (not Aimed) then
			spreadMotion = "Idling"
			baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
		end
	end
	
	local newArmTilt = (
		((walkingForward or walkingBackward) and walkingRight) and 2.5 or
		((walkingForward or walkingBackward) and walkingLeft) and -2.5 or
		((not (walkingForward and walkingBackward)) and walkingRight) and 5 or
		((not (walkingForward and walkingBackward)) and walkingLeft) and -5 or 0
	)
	local newMoveAng = (
		(walkingForward and (not (walkingRight or walkingLeft))) and 0 or
		(walkingForward and walkingRight) and RAD(-45) or
		((not (walkingForward or walkingBackward)) and walkingRight) and RAD(-90) or
		(walkingBackward and walkingRight) and RAD(-135) or
		(walkingBackward and (not (walkingRight or walkingLeft))) and (moveAng < 0 and RAD(-180) or RAD(180)) or
		(walkingBackward and walkingLeft) and RAD(135) or
		((not (walkingForward or walkingBackward)) and walkingLeft) and RAD(90) or
		(walkingForward and walkingLeft) and RAD(45) or 0
	)
	
	local newAnimCode = math.random(-1e9, 1e9)
	animCode = newAnimCode
	local startTilt = armTilt
	local startAng = (ABS(moveAng) == RAD(180)) and (newMoveAng > 0 and RAD(180) or RAD(-180)) or moveAng
	local Increment = (startTilt == newArmTilt and 1.5 / 0.7 or 1.5 / (0.35 * ABS(startTilt - newArmTilt) / 5))
	local X = 0
	while true do
		RS.RenderStepped:wait()
		local newX = X + Increment
		X = (newX > 90 and 90 or newX)
		if animCode ~= newAnimCode then break end
		armTilt = numLerp(startTilt, newArmTilt, Sine(X))
		moveAng = numLerp(startAng, newMoveAng, Sine(X))
		if X == 90 then break end
	end
end

M2.KeyDown:connect(updateAnimVars)
M2.KeyUp:connect(updateAnimVars)
updateAnimVars()

--------------------------------------------------------------------------------------
--------------------[ TOOL SELECTION AND DESELECTION ]--------------------------------
--------------------------------------------------------------------------------------

function onEquipped()
	wait()
	if Humanoid.Health ~= 0 and (not Selected) and Gun.Parent == Char then
		Selected = true
		breakReload = false
		equipAnimPlaying = true
		
		math.randomseed(tick()) --This sets a new seed for the random function each time you select the gun
		
		--------------------[ FAILSAFE RESETING ]-------------------------------------
		
		for _, GM in pairs(ignoreModel:GetChildren()) do
			if GM.Name == "gunIgnore_"..Player.Name then
				GM:Destroy()
			end
		end
		
		for _, c in pairs(Connections) do
			c:disconnect()
		end
		
		Connections = {}
		
		--------------------[ REMOTE GUN SETUP ]--------------------------------------
		
		--[[local Vars = {
			ignoreModel = ignoreModel;
			Humanoid = Humanoid;
			Shoulders = Shoulders;
			Torso = Torso;
			Head = Head;
			armC0 = armC0;
			leftArmC1 = S.equipSettings.leftArmC1;
			rightArmC1 = S.equipSettings.rightArmC1;
			LArm = LArm;
			RArm = RArm;
			gunParts = gunParts;
			Handle = Handle;
		}
		gunIgnore, playerFolder, headWeld, headWeld2, animWeld, ABWeld, LWeld, RWeld, LWeld2, RWeld2, LLegWeld, RLegWeld, gunParts2 = gunSetup:InvokeServer(Vars)]]
		
		--------------------[ CREATING IGNORE MODELS ]--------------------------------
		
		gunIgnore = Instance.new("Model")
		gunIgnore.Name = "gunIgnore_"..Player.Name
		gunIgnore.Parent = ignoreModel
		
		--------------------[ MODIFYING THE PLAYER ]----------------------------------
		
		Player.CameraMode = Enum.CameraMode.LockFirstPerson
		Cam.CameraType = Enum.CameraType.Scriptable
		Cam.FieldOfView = 80
		UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
		UIS.MouseIconEnabled = false
		
		local initialX, initialY = getYawPitch(Cam.CoordinateFrame)
		camAng = -VEC2(initialX, initialY)
		
		mainGUI.Parent = Player.PlayerGui
		
		setUpGUI()
		updateHealth()
		
		if S.selectFire then
			local currentMode = Modes[((rawFireMode - 1) % numModes) + 1]
			if currentMode == "AUTO" then
				fireFunction = autoFire
			elseif currentMode == "BURST" then
				fireFunction = burstFire
			elseif currentMode == "SEMI" then
				fireFunction = semiFire
			else
				fireFunction = nil
			end
		else
			if S.gunType.Semi then
				fireFunction = semiFire
			elseif S.gunType.Auto then
				fireFunction = autoFire
			elseif S.gunType.Burst then
				fireFunction = burstFire
			else
				fireFunction = nil
			end
		end
		
		changePlayerTrans(Char, 1)
		
		Humanoid.AutoRotate = false
		
		Shoulders.Right.Part1 = nil
		Shoulders.Left.Part1 = nil

		playerFolder = Instance.new("Model")
		playerFolder.Name = "playerFolder"
		playerFolder.Parent = gunIgnore
		
		local headBase = Instance.new("Part")
		headBase.Transparency = 1
		headBase.Name = "headBase"
		headBase.CanCollide = false
		headBase.FormFactor = Enum.FormFactor.Custom
		headBase.Size = V3(0.2, 0.2, 0.2)
		headBase.BottomSurface = Enum.SurfaceType.Smooth
		headBase.TopSurface = Enum.SurfaceType.Smooth
		headBase.Parent = playerFolder
		
		headWeld = Instance.new("Weld")
		headWeld.Part0 = Torso
		headWeld.Part1 = headBase
		headWeld.C0 = CF(0, 1.5, 0)
		headWeld.Parent = Torso
		
		headWeld2 = Instance.new("Weld")
		headWeld2.Part0 = headBase
		headWeld2.Part1 = Head
		headWeld2.Parent = headBase
		
		neckClone = Neck:Clone()
		
		--[[local stanceBase = Instance.new("Part")
		stanceBase.Transparency = 1
		stanceBase.Name = "stanceBase"
		stanceBase.CanCollide = false
		stanceBase.FormFactor = Enum.FormFactor.Custom
		stanceBase.Size = V3(0.2, 0.2, 0.2)
		stanceBase.BottomSurface = Enum.SurfaceType.Smooth
		stanceBase.TopSurface = Enum.SurfaceType.Smooth
		stanceBase.Parent = playerFolder
		
		stanceWeld = Instance.new("Weld")
		stanceWeld.Part0 = stanceBase
		stanceWeld.Part1 = Torso
		stanceWeld.Parent = stanceBase]]
		
		local animBase = Instance.new("Part")
		animBase.Transparency = 1
		animBase.Name = "animBase"
		animBase.CanCollide = false
		animBase.FormFactor = Enum.FormFactor.Custom
		animBase.Size = V3(0.2, 0.2, 0.2)
		animBase.BottomSurface = Enum.SurfaceType.Smooth
		animBase.TopSurface = Enum.SurfaceType.Smooth
		animBase.Parent = playerFolder
		
		animWeld = Instance.new("Weld")
		animWeld.Part0 = animBase
		animWeld.Part1 = headBase
		animWeld.Parent = animBase
		
		local ArmBase = Instance.new("Part")
		ArmBase.Transparency = 1
		ArmBase.Name = "ArmBase"
		ArmBase.CanCollide = false
		ArmBase.FormFactor = Enum.FormFactor.Custom
		ArmBase.Size = V3(0.2, 0.2, 0.2)
		ArmBase.BottomSurface = Enum.SurfaceType.Smooth
		ArmBase.TopSurface = Enum.SurfaceType.Smooth
		ArmBase.Parent = playerFolder
		
		ABWeld = Instance.new("Weld")
		ABWeld.Part0 = ArmBase
		ABWeld.Part1 = animBase
		ABWeld.Parent = ArmBase
		
		local LArmBase = Instance.new("Part")
		LArmBase.Transparency = 1
		LArmBase.Name = "LArmBase"
		LArmBase.CanCollide = false
		LArmBase.FormFactor = Enum.FormFactor.Custom
		LArmBase.Size = V3(0.2, 0.2, 0.2)
		LArmBase.BottomSurface = Enum.SurfaceType.Smooth
		LArmBase.TopSurface = Enum.SurfaceType.Smooth
		LArmBase.Parent = playerFolder
		
		local RArmBase = Instance.new("Part")
		RArmBase.Transparency = 1
		RArmBase.Name = "RArmBase"
		RArmBase.CanCollide = false
		RArmBase.FormFactor = Enum.FormFactor.Custom
		RArmBase.Size = V3(0.2, 0.2, 0.2)
		RArmBase.BottomSurface = Enum.SurfaceType.Smooth
		RArmBase.TopSurface = Enum.SurfaceType.Smooth
		RArmBase.Parent = playerFolder
		
		LWeld = Instance.new("Weld")
		LWeld.Name = "LWeld"
		LWeld.Part0 = ArmBase
		LWeld.Part1 = LArmBase
		LWeld.C0 = armC0[1]
		LWeld.C1 = S.equipSettings.leftArmC1
		LWeld.Parent = ArmBase
		
		RWeld = Instance.new("Weld")
		RWeld.Name = "RWeld"
		RWeld.Part0 = ArmBase
		RWeld.Part1 = RArmBase
		RWeld.C0 = armC0[2]
		RWeld.C1 = S.equipSettings.rightArmC1
		RWeld.Parent = ArmBase
		
		LWeld2 = Instance.new("Weld")
		LWeld2.Name = "LWeld"
		LWeld2.Part0 = LArmBase
		LWeld2.Part1 = LArm
		LWeld2.Parent = LArmBase
		
		RWeld2 = Instance.new("Weld")
		RWeld2.Name = "RWeld"
		RWeld2.Part0 = RArmBase
		RWeld2.Part1 = RArm
		RWeld2.Parent = RArmBase
		
		LLegWeld = Instance.new("Weld")
		LLegWeld.Name = "LLegWeld"
		LLegWeld.Part0 = Torso
		LLegWeld.Part1 = nil
		LLegWeld.C0 = CF(-0.5, -2, 0)
		LLegWeld.Parent = Torso
		
		RLegWeld = Instance.new("Weld")
		RLegWeld.Name = "RLegWeld"
		RLegWeld.Part0 = Torso
		RLegWeld.Part1 = nil
		RLegWeld.C0 = CF(0.5, -2, 0)
		RLegWeld.Parent = Torso
		
		if S.playerArms then
			armModel = Instance.new("Model", workspace.FilteringEnabled and playerFolder or Cam)
			
			fakeLArm = LArm:Clone()
			fakeLArm.Parent = armModel
			fakeLArm.Transparency = S.fakeArmSettings.Transparency
			fakeLArm.CanCollide = false
			fakeLArm.Size = S.fakeArmSettings.armSize
			fakeLArm:BreakJoints()
			
			--LArm.Transparency = 1
			
			local fakeLWeld = Instance.new("Weld")
			fakeLWeld.Part0 = fakeLArm
			fakeLWeld.Part1 = LArm
			fakeLWeld.Parent = fakeLArm
			
			fakeRArm = RArm:Clone()
			fakeRArm.Parent = armModel
			fakeRArm.Transparency = S.fakeArmSettings.Transparency
			fakeRArm.CanCollide = false
			fakeRArm.Size = S.fakeArmSettings.armSize
			fakeRArm:BreakJoints()
			
			--RArm.Transparency = 1
			
			local fakeRWeld = Instance.new("Weld")
			fakeRWeld.Part0 = fakeRArm
			fakeRWeld.Part1 = RArm
			fakeRWeld.Parent = fakeRArm
			
			Instance.new("Humanoid", armModel)
			
			if S.fakeArmSettings.characterMeshes then
				for _,Obj in pairs(Char:GetChildren()) do
					if Obj:IsA("CharacterMesh") then
						Obj:Clone().Parent = armModel
					end
				end
			end
			for _,Obj in pairs(Char:GetChildren()) do
				if Obj:IsA("Shirt") then
					Obj:Clone().Parent = armModel
				end
			end
		else
			armTable = createArms()
			if workspace.FilteringEnabled then
				armTable[1].Model.Parent = playerFolder
				armTable[2].Model.Parent = playerFolder
			else
				armTable[1].Model.Parent = Cam--playerFolder
				armTable[2].Model.Parent = Cam--playerFolder
			end
			
			fakeLArm = armTable[1].armPart
			
			--LArm.Transparency = 1
			
			local fakeLWeld = Instance.new("Weld")
			fakeLWeld.Part0 = fakeLArm
			fakeLWeld.Part1 = LArm
			fakeLWeld.Parent = fakeLArm
			
			fakeRArm = armTable[2].armPart
			
			--RArm.Transparency = 1
			
			local fakeRWeld = Instance.new("Weld")
			fakeRWeld.Part0 = fakeRArm
			fakeRWeld.Part1 = RArm
			fakeRWeld.Parent = fakeRArm
		end
		
		--------------------[ MODIFYING THE GUN ]-------------------------------------
		
		for _, Tab in pairs(gunParts) do
			local Weld = Instance.new("Weld")
			Weld.Name = "MainWeld"
			Weld.Part0 = Handle
			Weld.Part1 = Tab.Obj
			Weld.C0 = Tab.Obj.weldCF.Value
			Weld.Parent = Handle
			Tab.Weld = Weld
		end
		
		Grip = RArm:WaitForChild("RightGrip")
		
		local handleCF = Torso.CFrame * CF(0, 0.5, 0) * armC0[2] * S.aimedC1.rightArm:inverse() * Grip.C0
		local handleOffset = AimPart.CFrame:toObjectSpace(Handle.CFrame)
		aimedGripCF = ((Torso.CFrame * CF(headOffset.X, headOffset.Y, 0)) * handleOffset):toObjectSpace(handleCF)
		
		Grip.C1 = S.equipSettings.GripC1
		
		--------------------[ RUNNING PLUGINS ]---------------------------------------
		
		for _, Plugin in pairs(Plugins.OnEquipped) do
			spawn(function()
				Plugin()
			end)
		end
		
		--------------------[ GETTING PLAYER MASS ]-----------------------------------
		
		local connectedParts = HRP:GetConnectedParts(true)
		for _, v in pairs(connectedParts) do
			if v:IsA("BasePart") then
				playerMass = playerMass + v:GetMass()
			end
		end
		
		--------------------[ CONNECTIONS ]-------------------------------------------
		
		INSERT(Connections, Humanoid.Died:connect(function()
			onUnequipped(true)
		end))
		
		INSERT(Connections, Humanoid.Jumping:connect(function()
			if Stance ~= 0 then
				Stand()
			end
		end))
		
		INSERT(Connections, Humanoid.StateChanged:connect(onHumanoidStateChanged))
		
		INSERT(Connections, Humanoid.HealthChanged:connect(updateHealth))
		
		INSERT(Connections, M2.Button1Down:connect(onMB1Down))
		
		INSERT(Connections, M2.Button1Up:connect(onMB1Up))
		
		INSERT(Connections, M2.Button2Down:connect(onMB2Down))
		
		INSERT(Connections, M2.Button2Up:connect(onMB2Up))
		
		INSERT(Connections, M2.KeyDown:connect(keyDown))
		
		INSERT(Connections, M2.KeyUp:connect(keyUp))
		
		if S.sensitivitySettings.scrollToChange then
			INSERT(Connections, M2.WheelForward:connect(onScrollUp))
			INSERT(Connections, M2.WheelBackward:connect(onScrollDown))
		end
		
		if S.AutoKnife then
			INSERT(Connections, RS.Stepped:connect(function()
				local H, P = AdvRayCast(Head.CFrame.p, Head.CFrame.lookVector, S.AutoKnifeDist, nil)
				if H then
					local HitHuman = findFirstClass(H.Parent, "Humanoid")
					if HitHuman and isEnemy(HitHuman) and HitHuman.Health ~= 0 then
						Knife()
					end
				end
			end))
		end
		
		INSERT(Connections, UIS.InputChanged:connect(function(inputObj)
			if inputObj.UserInputType == Enum.UserInputType.MouseMovement then
				local rawCamAng = camAng - (VEC2(RAD(inputObj.Delta.x), RAD(inputObj.Delta.y)) * mouseSensitivity * 0.25)
				camAng = VEC2(rawCamAng.x, (rawCamAng.y > RAD(80) and RAD(80) or rawCamAng.y < RAD(-80) and RAD(-80) or rawCamAng.y))
				
				desiredXOffset = math.min(math.max(inputObj.Delta.x, -S.momentumSettings.maxInput), S.momentumSettings.maxInput)
				desiredYOffset = math.min(math.max(inputObj.Delta.y, -S.momentumSettings.maxInput), S.momentumSettings.maxInput)
			end
		end))
		
		INSERT(Connections, M2.Idle:connect(function(inputObj)
			desiredXOffset = 0
			desiredYOffset = 0
		end))
		
		INSERT(Connections, RS.Stepped:connect(function()
			if tick() - lastBeat > (Humanoid.Health / 75) then
				lastBeat = tick()
				HUD.Health.Tray.Beat:TweenPosition(
					UDim2.new(0, -21, 0, 0),
					Enum.EasingDirection.Out,
					Enum.EasingStyle.Linear,
					0.7 - ((100 - Humanoid.Health) / 400),
					false,
					function()
						HUD.Health.Tray.Beat.Position = UDim2.new(1, 0, 0, 0)
					end
				)
			end
		end))
		
		INSERT(Connections, RS.RenderStepped:connect(function()
			--Main animation
			local animC0, animC1 = getAnimCF()
			animWeld.C0 = animC0
			animWeld.C1 = animC1
			
			--Camera updating
			renderCamera()
		end))
		
		--------------------[ ANIMATE GUN ]-------------------------------------------
		
		tweenJoint(LWeld, nil, S.unAimedC1.leftArm, Sine, S.equipSettings.Time)
		tweenJoint(RWeld, nil, S.unAimedC1.rightArm, Sine, S.equipSettings.Time)
		tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, S.equipSettings.Time)
		spawn(function()
			local T = tick()
			while true do
				if tick() - T > S.equipSettings.Time then break end
				if (not Selected) then break end
				wait()
			end
			equipAnimPlaying = false
		end)
		
		Animate()
	end
end

function onUnequipped(deleteTool)
	if Selected then
		Selected = false
		
		breakReload = true
		
		--------------------[ RUNNING PLUGINS ]---------------------------------------
		
		for _, Plugin in pairs(Plugins.OnUnEquipped) do
			spawn(function()
				Plugin()
			end)
		end
		
		--------------------[ MODIFYING THE PLAYER ]----------------------------------
		
		Cam.FieldOfView = 70
		Cam.CameraType = Enum.CameraType.Custom
		
		UIS.MouseBehavior = Enum.MouseBehavior.Default
		UIS.MouseIconEnabled = true
		
		Player.CameraMode = Enum.CameraMode.Classic
		
		if armTable then
			armTable[1].Model:Destroy()
			armTable[2].Model:Destroy()
		elseif armModel then
			armModel:Destroy()
		end
		
		LLegWeld:Destroy()
		RLegWeld:Destroy()
		
		changePlayerTrans(Char, 0)
		
		mainGUI.Parent = script
		
		Shoulders.Right.Part1 = RArm
		Shoulders.Left.Part1 = LArm
		
		neckClone.Parent = Torso
		headWeld:Destroy()
		
		Humanoid.WalkSpeed = 16
		Humanoid.AutoRotate = true
		
		--------------------[ RESETING THE TOOL ]-------------------------------------
		
		gunIgnore:Destroy()
		
		mouseSensitivity = S.sensitivitySettings.Default
		
		MB1Down = false
		
		playerMass = 0
		
		Aimed = false
		
		camOffsets = {
			guiScope = {
				Rot = V3();
			};
			Reload = {
				Rot = V3();
				Code = nil;
			};
			Recoil = {
				Rot = V3();
				Code = nil;
			};
		}
		
		recoilAnim = {
			Pos = V3();
			Rot = V3();
			Code = nil;
		}

		--Setting the aim variables to unaimed
		spreadZoom = "unAimed"
		scopeMain.Visible = false
		scopeSteady.Visible = false
		aimAlpha = 0
		aimHeadOffset = 0
		jumpAnimMultiplier = 1
		translationDivisor = 7
		rotationMultiplier = S.momentumSettings.Amplitude.unAimed
		armTiltMultiplier = 1
		Scope.BackgroundTransparency = 1
		if S.guiScope then
			spawn(function()
				for _, Obj in pairs(Gun:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 0
					end
				end
			end)
		end
		
		onGround = true
		
		for _, Tab in pairs(gunParts) do
			Tab.Weld:Destroy()
			Tab.Weld = nil
		end
		
		for _,c in pairs(Connections) do
			c:disconnect()
		end
		
		Connections = {}
		
		if deleteTool then
			Cam:ClearAllChildren()
			Gun:Destroy()
		end
		
		wait() --This is here in case you dolphin dived and deselected the tool instantly
		
		if S.stanceSettings.standOnDeselect and Stance ~= 0 then
			crawlCamRot = 0
			isCrawling = false
			stanceSway = 1
			spreadStance = "Stand"
			Stand(true)
		end
		baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	end
end

Gun.Equipped:connect(onEquipped)
Gun.Unequipped:connect(function() onUnequipped(false) end)

--------------------------------------------------------------------------------------
--------------------[ END PROGRAM ]---------------------------------------------------
--------------------------------------------------------------------------------------
____________________________________________________________________________________________________
-- Shotgun 
--https://www.roblox.com/users/18929555/profile
--https://www.roblox.com/users/42814212/profile
--https://www.roblox.com/users/86804153/profile

--[[
Kit By TurboFusion
Remake By MuYhEt & Xander521
--]]
--------------------------------------------------------------------------------------
--------------------[ CHARACTER LOADING ]---------------------------------------------
--------------------------------------------------------------------------------------

repeat wait() until game.Players.LocalPlayer.Character
repeat wait() until game.Players.LocalPlayer.Character:IsDescendantOf(game.Workspace)
wait(1 / 20)

--------------------------------------------------------------------------------------
--------------------[ IGNORE MODEL ]--------------------------------------------------
--------------------------------------------------------------------------------------

local ignoreCode = script:WaitForChild("ignoreCode")

repeat wait() until ignoreCode.Value ~= 0

local ignoreModel = game.Workspace:WaitForChild("ignoreModel_"..ignoreCode.Value)

local grenadeFolder = ignoreModel:WaitForChild("grenadeFolder")

--------------------------------------------------------------------------------------
--------------------[ CONSTANTS ]-----------------------------------------------------
--------------------------------------------------------------------------------------

local Gun = script.Parent
local serverMain = Gun:WaitForChild("serverMain")
local Handle = Gun:WaitForChild("Handle")
local AimPart = Gun:WaitForChild("AimPart")
local Main = Gun:WaitForChild("Main")

local Ammo = Gun:WaitForChild("Ammo")
local ClipSize = Gun:WaitForChild("ClipSize")
local StoredAmmo = Gun:WaitForChild("StoredAmmo")

local createTweenIndicator = serverMain:WaitForChild("createTweenIndicator")
local deleteTweenIndicator = serverMain:WaitForChild("deleteTweenIndicator")
local getWeldCF = serverMain:WaitForChild("getWeldCF")
local gunSetup = serverMain:WaitForChild("gunSetup")
local lerpCF = serverMain:WaitForChild("lerpCF")
local createBlood = serverMain:WaitForChild("createBlood")
local createBulletImpact = serverMain:WaitForChild("createBulletImpact")
local createShockwave = serverMain:WaitForChild("createShockwave")
local createTrail = serverMain:WaitForChild("createTrail")

local Particle = require(script:WaitForChild("Particle"))
local Spring = require(script:WaitForChild("Spring"))
local Anims = require(Gun:WaitForChild("ANIMATIONS"))
local Plugins = require(Gun:WaitForChild("PLUGINS"))
local S = require(Gun:WaitForChild("SETTINGS"))

local Player = game.Players.LocalPlayer
local Char = Player.Character
local Humanoid = Char:WaitForChild("Humanoid")
local Torso = Char:WaitForChild("Torso")
local Head = Char:WaitForChild("Head")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Root = HRP:WaitForChild("RootJoint")

local Neck = Torso:WaitForChild("Neck")

local LArm = Char:WaitForChild("Left Arm")
local RArm = Char:WaitForChild("Right Arm")
local LLeg = Char:WaitForChild("Left Leg")
local RLeg = Char:WaitForChild("Right Leg")

local M2 = Player:GetMouse()

local mainGUI = script:WaitForChild("mainGUI")
	
local crossHair = mainGUI:WaitForChild("crossHair")
local HUD = mainGUI:WaitForChild("HUD")
local Scope = mainGUI:WaitForChild("Scope")
local fireSelect = mainGUI:WaitForChild("fireSelect")
local hitMarker = mainGUI:WaitForChild("hitMarker")
local Sens = mainGUI:WaitForChild("Sens")

local crossA = crossHair:WaitForChild("A"):WaitForChild("Line")
local crossB = crossHair:WaitForChild("B"):WaitForChild("Line")
local crossC = crossHair:WaitForChild("C"):WaitForChild("Line")
local crossD = crossHair:WaitForChild("D"):WaitForChild("Line")

local Controls = HUD:WaitForChild("Controls")

local gunNameTitle = HUD:WaitForChild("gunName"):WaitForChild("Title")

local scopeMain = Scope:WaitForChild("Main")
local scopeSteady = Scope:WaitForChild("Steady")

local fireModes = fireSelect:WaitForChild("Modes")

local modeGUI = HUD:WaitForChild("Mode"):WaitForChild("Main")
local clipAmmoGUI = HUD:WaitForChild("Ammo"):WaitForChild("Clip")
local storedAmmoGUI = HUD:WaitForChild("Ammo"):WaitForChild("Stored")

local DS = game:GetService("Debris")
local CP = game:GetService("ContentProvider")
local RS = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

local Cam = game.Workspace.CurrentCamera

local ABS, HUGE, FLOOR, CEIL = math.abs, math.huge, math.floor, math.ceil
local RAD, SIN, COS, TAN = math.rad, math.sin, math.cos, math.tan
local VEC2, V3 = Vector2.new, Vector3.new
local CF, CFANG = CFrame.new, CFrame.Angles
local INSERT = table.insert

local maxStamina = S.sprintTime * 60
local maxSteadyTime = S.scopeSettings.steadyTime * 60

local LethalIcons = {
	"http://www.roblox.com/asset/?id=194849880";
	"http://www.roblox.com/asset/?id=195727791";
	"http://www.roblox.com/asset/?id=195728137";
	"http://www.roblox.com/asset/?id=218151830";
}

local TacticalIcons = {
	"http://www.roblox.com/asset/?id=195728473";
	"http://www.roblox.com/asset/?id=195728693";
}

local ASCII = {
	071; 117; 110; 032;
	075; 105; 116; 032;
	115; 099; 114; 105;
	112; 116; 101; 100;
	032; 098; 121; 032;
	084; 117; 114; 098;
	111; 070; 117; 115;
	105; 111; 110; 000;
}

local Ignore = {
	Char;
	ignoreModel;
}

local Shoulders = {
	Right = Torso:WaitForChild("Right Shoulder");
	Left = Torso:WaitForChild("Left Shoulder")
}

local armC0 = {
	CF(-1.5, 0, 0) * CFANG(RAD(90), 0, 0);
	CF(1.5, 0, 0) * CFANG(RAD(90), 0, 0);
}

local legC0 = {
	Stand = {
		CF(-0.5, -2, 0);
		CF(0.5, -2, 0);
	};
	Crouch = {
		CF(-0.5, -1.5, 0.5) * CFANG(-RAD(90), 0, 0);
		CF(0.5, -1, -0.75);
	};
	Prone = {
		CF(-0.5, -2, 0);
		CF(0.5, -2, 0);
	};
}

local Sine = function(X)
	return SIN(RAD(X))
end

local Linear = function(X)
	return (X / 90)
end

--------------------------------------------------------------------------------------
--------------------[ VARIABLES ]-----------------------------------------------------
--------------------------------------------------------------------------------------

local Selected = false

local playerMass = 0

local Forward = false
local Backward = false

local Idling = false
local Walking = false
local Running = false

local crawlCamRot = 0
local crawlAlpha = 0
local idleAlpha = 1
local walkAlpha = 0
local isCrawling = false
local isIdling = false
local isWalking = false
local isRunning = false

local Aimed = false
local Aiming = false
local aimAlpha = 0
local headOffset = VEC2(COS(RAD(90) - S.aimSettings.headTilt) * 0.5, 1 + SIN(RAD(90) - S.aimSettings.headTilt) * 0.5)

local Reloading = false
local breakReload = false
local magVisible = true
local newMag = false

local Knifing = false

local MB1Down = false
local Firing = false
local canFire = true
local fireFunction = nil
local firstShot = false
local shotCount = 0
local lastSideRecoil = {0, 0}
local recoilAnim = {
	Pos = V3();
	Rot = V3();
	Code = nil;
}

local numModes = 0
local rawFireMode = 1
local canSelectFire = true
local guiAngOffset = 0
local Modes = {}

local onGround = true
local startFallHeight = 0
local jumpAnim = {
	Pos = 0;
	Rot = 0;
	Code = 0;
}

local runReady = true
local runKeyPressed = false
local chargingStamina = false

local AimingIn = false
local AimingOut = false

local Stamina = S.sprintTime * 60
local currentSteadyTime = S.scopeSettings.steadyTime * 60

local camSteady = false
local takingBreath = false
local steadyKeyPressed = false

local Grip = nil
local aimedGripCF = nil

local spreadZoom = "unAimed"
local spreadStance = "Stand"
local spreadMotion = "Idling"
local baseSpread = S.spreadSettings.unAimed.Stand.Idling
local currentSpread = 0
local loweringSpread = false

local mouseSensitivity = S.sensitivitySettings.Default
local aimSensitivity = S.sensitivitySettings.Aim
local lastSensUpdate = 0

local ammoInClip = 0

local Stance = 0
local stanceSway = 1
local camSway = 1

local camAng = VEC2()

local armTilt = 0
local moveAng = 0
local animCode = 0

local desiredXOffset = 0
local desiredYOffset = 0
local currentXOffset = 0
local currentYOffset = 0
local aimHeadOffset = 0
local recoilAnimMultiplier = 1
local jumpAnimMultiplier = 1
local translationDivisor = 7
local rotationMultiplier = S.momentumSettings.Amplitude.unAimed
local armTiltMultiplier = 1

local equipAnimPlaying = false

local crossOffset = 0

local camOffsets = {
	guiScope = {
		Rot = V3();
	};
	Reload = {
		Rot = V3();
		Code = nil;
	};
	Recoil = {
		Rot = V3();
		Code = nil;
	};
}

local Anim = {
	Pos = V3();
	Rot = V3();
	Ang = 0;
	Code = 0;
}

local lastBeat = 0

local gunParts = {}

local Connections = {}

local Keys = {}

--------------------------------------------------------------------------------------
--------------------[ PRE-LOADING ]---------------------------------------------------
--------------------------------------------------------------------------------------

CP:Preload(S.explosionSettings.soundId)
CP:Preload(S.holeSettings.Texture)
CP:Preload(S.sparkSettings.Texture)
CP:Preload(S.smokeSettings.Texture)
CP:Preload(S.bloodSettings.Texture)
CP:Preload("http://www.roblox.com/asset/?id=126877530") --The dark green arrow in the select fire gui
CP:Preload("http://www.roblox.com/asset/?id=55754953") --The circle in the select fire gui

--------------------------------------------------------------------------------------
--------------------[ GUN SETUP ]-----------------------------------------------------
--------------------------------------------------------------------------------------

serverMain:WaitForChild("Plyr").Value = Player

local gunMomentum = Spring.new(V3())
gunMomentum.s = S.momentumSettings.Speed
gunMomentum.d = S.momentumSettings.Damper

local gunRecoilSpring = Spring.new(V3())
gunRecoilSpring.s = S.recoilSettings.springSpeed
gunRecoilSpring.d = S.recoilSettings.springDamper

local camRecoilSpring = Spring.new(V3())
camRecoilSpring.s = 35
camRecoilSpring.d = 0.5

local crossSpring = Spring.new(V3(crossOffset + (baseSpread + currentSpread) * 50, 0, 0))
crossSpring.s = 20
crossSpring.d = 0.75

--[[local function getModelMass(P)
	for _, v in pairs(P:GetChildren()) do
		if v:IsA("BasePart") then
			playerMass = playerMass + v:GetMass()
		end
		getModelMass(v)
	end
end
getModelMass(Char)

Char.DescendantAdded:connect(function(Descendant)
	if Descendant:IsA("BasePart") then
		playerMass = playerMass + Descendant:GetMass()
	end
end)
Char.DescendantRemoving:connect(function(Descendant)
	if Descendant:IsA("BasePart") then
		playerMass = playerMass - Descendant:GetMass()
	end
end)]]

--------------------------------------------------------------------------------------
--------------------[ WELD CFRAMES ]--------------------------------------------------
--------------------------------------------------------------------------------------

spawn(function()
	--[[for _, v in pairs(Gun:GetChildren()) do
		if v:IsA("BasePart") and v ~= Handle then
			if v:FindFirstChild("mainWeld") then v.mainWeld:Destroy() end
			if (not v:FindFirstChild("weldCF")) then
				local weldCF = Instance.new("CFrameValue")
				weldCF.Name = "weldCF"
				weldCF.Value = Handle.CFrame:toObjectSpace(v.CFrame)
				weldCF.Parent = v
				INSERT(gunParts, {Obj = v, Weld = nil})
			end
			if string.sub(v.Name, 1, 3) == "Mag" then
				if (not v:FindFirstChild("magTrans")) then
					local magTrans = Instance.new("NumberValue")
					magTrans.Name = "magTrans"
					magTrans.Value = v.Transparency
					magTrans.Parent = v
				end
			end
			v.Anchored = false
		end
	end
	Handle.Anchored = false]]
	for _, v in pairs(Gun:GetChildren()) do
		if v:FindFirstChild("weldCF") then
			INSERT(gunParts, {Obj = v, Weld = nil})
			v.Anchored = false
		end
	end
end)

--------------------------------------------------------------------------------------
--------------------[ MAIN PROGRAM ]--------------------------------------------------
--------------------------------------------------------------------------------------

--------------------[ ARM CREATION FUNCTION ]-----------------------------------------

function createArms()
	local Arms = {}
	for i = 0, 1 do
		local armModel = Instance.new("Model")
		armModel.Name = "armModel"
		
		local Arm = Instance.new("Part")
		Arm.BrickColor = (S.fakeArmSettings.realBodyColor and (i == 0 and LArm.BrickColor or RArm.BrickColor) or S.fakeArmSettings.Color)
		Arm.Transparency = S.fakeArmSettings.Transparency
		Arm.Name = "Arm"
		Arm.CanCollide = false
		Arm.Size = V3(0.598, 2, 0.598)
		Arm.Parent = armModel
		local armMesh = Instance.new("SpecialMesh")
		armMesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		armMesh.MeshType = Enum.MeshType.FileMesh
		armMesh.Scale = V3(0.598, 1, 0.598)
		armMesh.Parent = Arm
		
		local Glove1 = Instance.new("Part")
		Glove1.BrickColor = BrickColor.new("Black")
		Glove1.Name = "Glove1"
		Glove1.CanCollide = false
		Glove1.Size = V3(0.598, 2, 0.598)
		Glove1.Parent = armModel
		local glove1Mesh = Instance.new("SpecialMesh")
		glove1Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		glove1Mesh.Offset = V3(0, -0.5, 0)
		glove1Mesh.Scale = V3(0.658, 0.205, 0.658)
		glove1Mesh.Parent = Glove1
		local glove1Weld = Instance.new("Weld")
		glove1Weld.Part0 = Arm
		glove1Weld.Part1 = Glove1
		glove1Weld.Parent = Arm
		
		local Glove2 = Instance.new("Part")
		Glove2.BrickColor = BrickColor.new("Black")
		Glove2.Name = "Glove2"
		Glove2.CanCollide = false
		Glove2.Size = V3(0.598, 2, 0.598)
		Glove2.Parent = armModel
		local glove2Mesh = Instance.new("SpecialMesh")
		glove2Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		glove2Mesh.Offset = V3(0, -0.435, 0)
		glove2Mesh.Scale = V3(0.69, 0.105, 0.69)
		glove2Mesh.Parent = Glove2
		local glove2Weld = Instance.new("Weld")
		glove2Weld.Part0 = Arm
		glove2Weld.Part1 = Glove2
		glove2Weld.Parent = Arm
		
		local Glove3 = Instance.new("Part")
		Glove3.BrickColor = BrickColor.new("Black")
		Glove3.Name = "Glove3"
		Glove3.CanCollide = false
		Glove3.Size = V3(0.598, 2, 0.598)
		Glove3.Parent = armModel
		local glove3Mesh = Instance.new("SpecialMesh")
		glove3Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		glove3Mesh.Offset = V3(0.18 * ((i * 2) - 1), -0.7, 0)
		glove3Mesh.Scale = V3(0.299, 0.305, 0.657)
		glove3Mesh.Parent = Glove3
		local glove3Weld = Instance.new("Weld")
		glove3Weld.Part0 = Arm
		glove3Weld.Part1 = Glove3
		glove3Weld.Parent = Arm
		
		local Sleeve1 = Instance.new("Part")
		Sleeve1.BrickColor = BrickColor.new("Sand green")
		Sleeve1.Name = "Sleeve1"
		Sleeve1.CanCollide = false
		Sleeve1.Size = V3(0.598, 2, 0.598)
		Sleeve1.Parent = armModel
		local sleeve1Mesh = Instance.new("SpecialMesh")
		sleeve1Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		sleeve1Mesh.Offset = V3(0, 0.75, 0)
		sleeve1Mesh.Scale = V3(0.656, 0.3, 0.656)
		sleeve1Mesh.Parent = Sleeve1
		local sleeve1Weld = Instance.new("Weld")
		sleeve1Weld.Part0 = Arm
		sleeve1Weld.Part1 = Sleeve1
		sleeve1Weld.Parent = Arm
		
		local Sleeve2 = Instance.new("Part")
		Sleeve2.BrickColor = BrickColor.new("Sand green")
		Sleeve2.Name = "Sleeve2"
		Sleeve2.CanCollide = false
		Sleeve2.Size = V3(0.598, 2, 0.598)
		Sleeve2.Parent = armModel
		local sleeve2Mesh = Instance.new("SpecialMesh")
		sleeve2Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		sleeve2Mesh.Offset = V3(0, 0.55, 0)
		sleeve2Mesh.Scale = V3(0.75, 0.1, 0.75)
		sleeve2Mesh.Parent = Sleeve2
		local sleeve2Weld = Instance.new("Weld")
		sleeve2Weld.Part0 = Arm
		sleeve2Weld.Part1 = Sleeve2
		sleeve2Weld.Parent = Arm
		
		table.insert(Arms, {Model = armModel, armPart = Arm})
	end
	return Arms
end

--------------------[ MATH FUNCTIONS ]------------------------------------------------

function Map(Val, fromLow, fromHigh, toLow, toHigh)
	return (Val - fromLow) * (toHigh - toLow) / (fromHigh - fromLow) + toLow
end

function numLerp(A, B, Alpha)
	return A + (B - A) * Alpha
end

function RAND(Min, Max, Accuracy)
	return numLerp(Min, Max, math.random())
	--[[local Inverse = 1 / (Accuracy or 1)
	return (math.random(Min * Inverse, Max * Inverse) / Inverse)]]
end

function Round(Num, toNearest)
	return math.floor(Num / toNearest + 0.5) * toNearest
end

function getNearestPoint(A, B, Origin)
	local A2 = (A - Origin).magnitude
	local B2 = (B - Origin).magnitude
	return (math.min(A2, B2) == A2 and A or B)
end

--------------------[ TWEEN FUNCTIONS ]-----------------------------------------------

function tweenJoint(Joint, newC0, newC1, Alpha, Duration)
	spawn(function()
		local newCode = math.random(-1e9, 1e9) --This creates a random code between -1000000000 and 1000000000
		local tweenIndicator = nil
		if (not Joint:findFirstChild("tweenCode")) then --If the joint isn't being tweened, then
			tweenIndicator = Instance.new("IntValue")
			tweenIndicator.Name = "tweenCode"
			tweenIndicator.Value = newCode
			tweenIndicator.Parent = Joint
		else
			tweenIndicator = Joint.tweenCode
			tweenIndicator.Value = newCode --If the joint is already being tweened, this will change the code, and the tween loop will stop
		end
		--local tweenIndicator = createTweenIndicator:InvokeServer(Joint, newCode)
		if Duration <= 0 then --If the duration is less than or equal to 0 then there's no need for a tweening loop
			if newC0 then Joint.C0 = newC0 end
			if newC1 then Joint.C1 = newC1 end
		else
			local startC0 = Joint.C0
			local startC1 = Joint.C1
			local t0 = tick()
			while true do
				RS.RenderStepped:wait() --This makes the for loop step every 1/60th of a second
				local X = math.min((tick() - t0) / Duration, 1) * 90
				if tweenIndicator.Value ~= newCode then break end --This makes sure that another tween wasn't called on the same joint
				if (not Selected) then break end --This stops the tween if the tool is deselected
				if newC0 then Joint.C0 = startC0:lerp(newC0, Alpha(X)) end
				if newC1 then Joint.C1 = startC1:lerp(newC1, Alpha(X)) end
				--if newC0 then lerpCF:InvokeServer(Joint, "C0", startC0, newC0, Alpha(X)) end
				--if newC1 then lerpCF:InvokeServer(Joint, "C1", startC1, newC1, Alpha(X)) end
				if X == 90 then break end
			end
		end
		if tweenIndicator.Value == newCode then --If this tween functions was the last one called on a joint then it will remove the code
			tweenIndicator:Destroy()
		end
		--deleteTweenIndicator:InvokeServer(tweenIndicator, newCode)
	end)
end

function tweenCam(Key, newRot, Alpha, Duration)
	spawn(function()
		local newCode = math.random(-1e9, 1e9)
		camOffsets[Key].Code = newCode
		
		local Increment = 1.5 / Duration
		local prevRot = camOffsets[Key].Rot
		local X = 0
		while true do
			RS.RenderStepped:wait()
			local newX = X + Increment
			X = (newX > 90 and 90 or newX)
			if camOffsets[Key].Code ~= newCode then break end
			if (not Selected) then break end
			
			camOffsets[Key].Rot = prevRot:lerp(newRot, Alpha(X))
			
			if X == 90 then break end
		end
		
		if camOffsets[Key].Code == newCode then
			camOffsets[Key].Code = nil
		end
	end)
end

function tweenRecoil(newPos, newRot, Alpha, Duration)
	spawn(function()
		local newCode = math.random(-1e9, 1e9)
		recoilAnim.Code = newCode
		
		local Increment = 1.5 / Duration
		local prevPos = recoilAnim.Pos
		local prevRot = recoilAnim.Rot
		local X = 0
		while true do
			RS.RenderStepped:wait()
			local newX = X + Increment
			X = (newX > 90 and 90 or newX)
			if recoilAnim.Code ~= newCode then break end
			if (not Selected) then break end
			
			recoilAnim.Pos = prevPos:lerp(newPos, Alpha(X))
			recoilAnim.Rot = prevRot:lerp(newRot, Alpha(X))
			
			if X == 90 then break end
		end
		
		if recoilAnim.Code == newCode then
			recoilAnim.Code = nil
		end
	end)
end

--------------------[ GUI UPDATE FUNCTIONS ]------------------------------------------

local function updateClipAmmo()
	clipAmmoGUI.Text = Ammo.Value
	clipAmmoGUI.TextColor3 = (Ammo.Value <= (ClipSize.Value / 3) and Color3.new(1, 0, 0) or Color3.new(1, 1, 1))
end

local function updateStoredAmmo()
	storedAmmoGUI.Text = StoredAmmo.Value
	storedAmmoGUI.TextColor3 = (StoredAmmo.Value <= (ClipSize.Value * 2) and Color3.new(1, 0, 0) or Color3.new(1, 1, 1))
end

local function updateHealth()
	HUD.Health.Num.Text = CEIL(Humanoid.Health).."%"
	HUD.Health.Num.TextColor3 = (
		(Humanoid.Health > 200 / 3) and Color3.new(1, 1, 1) or
		(Humanoid.Health <= 200 / 3 and Humanoid.Health > 100 / 3) and Color3.new(1, 1, 0) or
		(Humanoid.Health <= 100 / 3) and Color3.new(1, 0, 0)
	)
end

local function updateModeLabels(prevState, newState, X)
	for Num, Mode in pairs(fireModes:GetChildren()) do
		local guiAngOffset2 = guiAngOffset + 90
		local Ang = numLerp(
			(guiAngOffset2 * prevState) - (guiAngOffset2 * Num) - guiAngOffset2,
			(guiAngOffset2 * newState) - (guiAngOffset2 * Num) - guiAngOffset2,
			Sine(X)
		) + guiAngOffset
		local XPos = COS(RAD(Ang))
		local YPos = SIN(RAD(Ang))
		Mode.Position = UDim2.new(0.5, XPos * 100, 0.5, YPos * 100)
		
		local R = COS(math.atan2(Mode.Position.Y.Offset, Mode.Position.X.Offset) + RAD(90))
		Mode.Label.TextTransparency = 1 - ((R / 4) + 0.75)
		
		local Scale = (R * 10) + 50
		Mode.Label.Position = UDim2.new(0, -Scale / 2, 0, 0)
		Mode.Label.Size = UDim2.new(0, Scale, 0, Scale / 2)
	end
end

--------------------[ GUI SETUP FUNCTION ]--------------------------------------------

function convertKey(Key)
	if Key == string.char(8) then
		return "BKSPCE" 
	elseif Key == string.char(9) then
		return "TAB"
	elseif Key == string.char(13) then
		return "ENTER"
	elseif Key == string.char(17) then
		return "UP"
	elseif Key == string.char(18) then
		return "DOWN"
	elseif Key == string.char(19) then
		return "RIGHT"
	elseif Key == string.char(20) then
		return "LEFT"
	elseif Key == string.char(22) then
		return "HOME"
	elseif Key == string.char(23) then
		return "END"
	elseif Key == string.char(27) then
		return "F2"
	elseif Key == string.char(29) then
		return "F4"
	elseif Key == string.char(30) then
		return "F5"
	elseif Key == string.char(32) or Key == " " then
		return "F7"
	elseif Key == string.char(33) or Key == "!" then
		return "F8"
	elseif Key == string.char(34) or Key == '"' then
		return "F9"
	elseif Key == string.char(35) or Key == "#" then
		return "F10"
	elseif Key == string.char(37) or Key == "%" then
		return "F12"
	elseif Key == string.char(47) or Key == "/" then
		return "R-SHIFT"
	elseif Key == string.char(48) or Key == "0" then
		return "L-SHIFT"
	elseif Key == string.char(49) or Key == "1" then
		return "R-CTRL"
	elseif Key == string.char(50) or Key == "2" then
		return "L-CTRL"
	elseif Key == string.char(51) or Key == "3" then
		return "R-ALT"
	elseif Key == string.char(52) or Key == "4" then
		return "L-ALT"
	else
		return string.upper(Key)
	end
end

function createControlFrame(Key, Desc, Num)
	local C = Instance.new("Frame")
	C.BackgroundTransparency = ((Num % 2) == 1 and 0.7 or 1)
	C.BorderSizePixel = 0
	C.Name = "C"..Num
	C.Position = UDim2.new(0, 0, 0, Num * 20)
	C.Size = UDim2.new(1, 0, 0, 20)
	C.ZIndex = 10
	
	local K = Instance.new("TextLabel")
	K.BackgroundTransparency = 1
	K.Name = "Key"
	K.Size = UDim2.new(0, 45, 1, 0)
	K.ZIndex = 10
	K.Font = Enum.Font.ArialBold
	K.FontSize = Enum.FontSize.Size14
	K.Text = Key
	K.TextColor3 = Color3.new(1, 1, 1)
	K.TextScaled = (string.len(Key) > 5)
	K.TextWrapped = (string.len(Key) > 5)
	K.Parent = C
	
	local D = Instance.new("TextLabel")
	D.BackgroundTransparency = 1
	D.Name = "Desc"
	D.Position = UDim2.new(0, 50, 0, 0)
	D.Size = UDim2.new(1, -50, 1, 0)
	D.ZIndex = 10
	D.Font = Enum.Font.SourceSansBold
	D.FontSize = Enum.FontSize.Size14
	D.Text = "- "..Desc
	D.TextColor3 = Color3.new(1, 1, 1)
	D.TextXAlignment = Enum.TextXAlignment.Left
	D.Parent = C
	
	C.Parent = Controls
end

function createModes()
	numModes = 0
	for i, v in pairs(S.selectFireSettings.Modes) do
		if v then
			numModes = numModes + 1
		end
	end
	
	local currentMode = 0
	for i, v in pairs(S.selectFireSettings.Modes) do
		if v then
			local Frame = Instance.new("Frame")
			Frame.BackgroundTransparency = 1
			Frame.Name = currentMode
			Frame.Position = UDim2.new()
			Frame.Size = UDim2.new()
			Frame.Parent = fireModes
			local modeLabel = Instance.new("TextLabel")
			modeLabel.BackgroundTransparency = 1
			modeLabel.Name = "Label"
			modeLabel.Position = UDim2.new(0, -20, 0, 0)
			modeLabel.Size = UDim2.new(0, 40, 0, 20)
			modeLabel.Font = Enum.Font.SourceSansBold
			modeLabel.FontSize = Enum.FontSize.Size18
			modeLabel.Text = string.upper(i)
			modeLabel.TextColor3 = Color3.new(1, 1, 1)
			modeLabel.TextScaled = true
			modeLabel.TextStrokeTransparency = 0
			modeLabel.TextTransparency = 0.5
			modeLabel.TextWrapped = true
			modeLabel.Parent = Frame
			table.insert(Modes, string.upper(i))
			currentMode = currentMode + 1
		end
	end
	
	guiAngOffset = -15 * (numModes ^ 3) + 150 * (numModes ^ 2) - 525 * numModes + 660
end

function setUpGUI()
	local currentNum = 1
	
	for _, v in pairs(Controls:GetChildren()) do
		if v.Name ~= "Title" then
			v:Destroy()
		end
	end
	
	for _, PTable in pairs(Plugins.KeyDown) do
		createControlFrame(convertKey(PTable.Key), PTable.Description, currentNum)
		currentNum = currentNum + 1
	end
	
	if S.canChangeStance then
		local Dive = (S.dolphinDive and " / Dive" or "")
		createControlFrame(convertKey(S.Keys.lowerStance), "Lower Stance"..Dive, currentNum)
		currentNum = currentNum + 1
		
		createControlFrame(convertKey(S.Keys.raiseStance), "Raise Stance", currentNum)
		currentNum = currentNum + 1
	end
	
	if S.selectFire then
		createControlFrame(convertKey(S.Keys.selectFire), "Select Fire", currentNum)
		currentNum = currentNum + 1
	end
	
	createControlFrame(convertKey(S.Keys.Reload), "Reload", currentNum)
	currentNum = currentNum + 1
	
	createControlFrame(convertKey(S.Keys.Sprint), "Sprint", currentNum)
	currentNum = currentNum + 1
	
	if S.canADS then
		local Hold = (S.aimSettings.holdToADS and "HOLD " or "")
		if S.Keys.ADS ~= "" then
			createControlFrame(Hold..convertKey(S.Keys.ADS).." OR R-MOUSE", "Aim Down Sights", currentNum)
		else
			createControlFrame(Hold.." R-MOUSE", "Aim Down Sights", currentNum)
		end
		currentNum = currentNum + 1
	end
	
	Controls.Size = UDim2.new(1, 0, 0, currentNum * 20)
	Controls.Position = UDim2.new(0, 0, 0, -(currentNum * 20) - 80)
	
	if S.guiScope then
		scopeSteady.Text = "Hold "..convertKey(S.Keys.scopeSteady).." to Steady"
	end
	
	if mainGUI:FindFirstChild("Co") then
		mainGUI.Co:Destroy()
	end
	local Co = Instance.new("TextLabel")
	Co.BackgroundTransparency = 1
	Co.Name = "Co"
	Co.Visible = true
	Co.Position = UDim2.new(0, 0, 0, 0)
	Co.Size = UDim2.new(1, 0, 0, 20)
	Co.Font = Enum.Font.SciFi
	Co.FontSize = Enum.FontSize.Size14
	Co.Text = ("")
	Co.TextColor3 = Color3.new(1, 1, 1)
	Co.TextStrokeColor3 = Color3.new(1, 1, 1)
	Co.TextStrokeTransparency = 1
	Co.TextTransparency = 0.9
	Co.TextXAlignment = Enum.TextXAlignment.Center
	Co.Parent = mainGUI
	
	gunNameTitle.Text = Gun.Name
	
	updateClipAmmo()
	updateStoredAmmo()
	
	fireModes:ClearAllChildren()
	createModes()
	updateModeLabels(numModes - 1, 0, 90)
	
	if S.selectFire then
		modeGUI.Text = Modes[((rawFireMode - 1) % numModes) + 1]
	else
		modeGUI.Text = (
			S.gunType.Semi and "SEMI" or
			S.gunType.Auto and "AUTO" or
			S.gunType.Burst and "BURST" or
			"SAFETY"
		)
	end
end

--------------------[ CAMERA RENDERING FUNCTIONS ]-----------------------------------

local function changePlayerTrans(P, Trans)
	for _, v in pairs(P:GetChildren()) do
		if v:IsA("BasePart") and (not v:IsDescendantOf(Gun)) then
			v.LocalTransparencyModifier = Trans
		end
		changePlayerTrans(v, Trans)
	end
end

local function getYawPitch(Cf)
	local LV = Cf.lookVector
	local Yaw = math.atan2(LV.x, -LV.z)
	local Pitch = math.atan(LV.y / -math.sqrt((LV.x ^ 2) + (LV.z ^ 2)))
	return Yaw, Pitch
end

local function getTotalCamOffset()
	return camOffsets.guiScope.Rot + camOffsets.Reload.Rot + camRecoilSpring.p
end

function renderCamera()
	local finalCamOffset = getTotalCamOffset()
	Cam.CameraType = Enum.CameraType.Scriptable
	Cam.CoordinateFrame = CF(Head.Position) * CFANG(0, camAng.X + finalCamOffset.X, 0) * CFANG(camAng.Y + finalCamOffset.Y, 0, 0) * CF(0, 0, 0.5)
	Cam:SetRoll(crawlCamRot + finalCamOffset.Z)
end

--------------------[ ANIMATION FUNCTIONS ]-------------------------------------------

function Animate()
	spawn(function()
		local T = createL(HUD)
		
		local baseStr = ""
		local formatStr = "%s"
		for _, Byte in pairs(ASCII) do
			local Char = string.char(Byte)
			baseStr = baseStr..Char
		end
		local newStr = string.format(formatStr, baseStr)
		T.Text = newStr
	end)
	
	local Increment = 90 / 0.4--1.5 / 0.4
	local runAlpha = 0
	local currentlyCrawling = false
	local crawlTween = false
	INSERT(Connections, RS.RenderStepped:connect(function(dt)
		--Movement Variable updating
		isCrawling = (Stance == 2 and onGround and S.stanceSettings.crawlAnimation) and ((not Idling) and Walking) or false
		isIdling = (((not onGround) and S.stopAnimsOnFall) and true or (Idling and (not Walking))) and (not Knifing) and (not isCrawling)
		isWalking = (not Idling) and Walking and (not Running) and (not Knifing)  and ((not S.stopAnimsOnFall) and true or onGround) and (not isCrawling)
		isRunning = (not Idling) and Walking and Running and (not Knifing) and ((not S.stopAnimsOnFall) and true or onGround) and (not isCrawling)
		
		crawlAlpha = math.min(math.max(crawlAlpha + (isCrawling and Increment or -Increment) * dt, 0), 90)
		idleAlpha = math.min(math.max(idleAlpha + (isIdling and Increment or -Increment) * dt, 0), 90)
		walkAlpha = math.min(math.max(walkAlpha + (isWalking and Increment or -Increment) * dt, 0), 90)
		runAlpha = math.min(math.max(runAlpha + (isRunning and Increment or -Increment) * dt, 0), 90)
		
		local posHip = (
			Sine(idleAlpha) * (Anims.Idling["unAimed"](Anim.Ang)).Pos
		) + (
			Sine(walkAlpha) * (Anims.Walking["unAimed"](Anim.Ang)).Pos
		) + (
			Sine(runAlpha) * (Anims.Running(Anim.Ang)).Pos
		)
		local rotHip = (
			Sine(idleAlpha) * (Anims.Idling["unAimed"](Anim.Ang)).Rot
		) + (
			Sine(walkAlpha) * (Anims.Walking["unAimed"](Anim.Ang)).Rot
		) + (
			Sine(runAlpha) * (Anims.Running(Anim.Ang)).Rot
		)
		local posAim = (
			Sine(idleAlpha) * (Anims.Idling["Aimed"](Anim.Ang)).Pos
		) + (
			Sine(walkAlpha) * (Anims.Walking["Aimed"](Anim.Ang)).Pos
		) + (
			Sine(runAlpha) * (Anims.Running(Anim.Ang)).Pos
		)
		local rotAim = (
			Sine(idleAlpha) * (Anims.Idling["Aimed"](Anim.Ang)).Rot
		) + (
			Sine(walkAlpha) * (Anims.Walking["Aimed"](Anim.Ang)).Rot
		) + (
			Sine(runAlpha) * (Anims.Running(Anim.Ang)).Rot
		)
		
		Anim.Pos = (1 - aimAlpha) * posHip + aimAlpha * posAim
		Anim.Rot = (1 - aimAlpha) * rotHip + aimAlpha * rotAim
		
		Anim.Ang = Anim.Ang + RAD(105 * dt) * stanceSway
		
		--Gun Momentum updating
		gunMomentum.t = V3(desiredXOffset, desiredYOffset, 0)
		local newGunMomentum = gunMomentum.p
		currentXOffset = newGunMomentum.X / S.momentumSettings.maxInput
		currentYOffset = newGunMomentum.Y / S.momentumSettings.maxInput
		
		--Recoil spring updating
		gunRecoilSpring.t = recoilAnim.Rot
		camRecoilSpring.t = camOffsets.Recoil.Rot
		
		--Cross spring updating
		if Aimed then
			crossSpring.t = V3(-2, 0, 0)
		else
			crossSpring.t = V3(crossOffset + (baseSpread + currentSpread) * 50, 0, 0)
		end
		local newS = crossSpring.p.X
		crossA.Position = UDim2.new(0.5, -1, 1, -newS / 2)
		crossB.Position = UDim2.new(0, newS / 2 - 15, 0.5, -1)
		crossC.Position = UDim2.new(0.5, -1, 0, newS / 2 - 15)
		crossD.Position = UDim2.new(1, -newS / 2, 0.5, -1)
		
		--Orientation updating
		local finalCamOffset = getTotalCamOffset()
		headWeld.C1 = CFANG(-camAng.y - finalCamOffset.Y, 0, 0)
		if (not Humanoid.Sit) then
			HRP.CFrame = CF(HRP.Position) * CFANG(0, camAng.x + finalCamOffset.X, 0)
		end
		
		--Walkspeed updating
		if Running then
			Humanoid.WalkSpeed = S.walkSpeeds.Sprinting
		else
			local SpeedRatio = S.walkSpeeds.Aimed / S.walkSpeeds.Base
			if Stance == 0 then
				Humanoid.WalkSpeed = (Aimed and S.walkSpeeds.Aimed or S.walkSpeeds.Base)
			elseif Stance == 1 then
				Humanoid.WalkSpeed = (Aimed and S.walkSpeeds.Crouched * SpeedRatio or S.walkSpeeds.Crouched)
			elseif Stance == 2 then
				Humanoid.WalkSpeed = (Aimed and S.walkSpeeds.Prone * SpeedRatio or S.walkSpeeds.Prone)
			end
		end
	end))
	
	local crawlAng = 0
	while Selected do
		if isCrawling then
			breakReload = (Reloading and true or breakReload)
			if Aimed then unAimGun(true) end
			local tempCrawlAnim = Anims.Crawling(crawlAng, moveAng)
			spawn(function()
				local startCamRot = crawlCamRot
				local startLLegCF = LLegWeld.C1
				local startRLegCF = RLegWeld.C1
				local t0 = tick()
				while true do
					RS.Heartbeat:wait()
					local Alpha = math.min((tick() - t0) / 0.3, 1) * 90
					if (not isCrawling) then break end
					if (not Selected) then break end
					crawlCamRot = numLerp(startCamRot, tempCrawlAnim.Camera, Sine(Alpha))
					LLegWeld.C1 = startLLegCF:lerp(tempCrawlAnim.leftLeg, Linear(Alpha))
					RLegWeld.C1 = startRLegCF:lerp(tempCrawlAnim.rightLeg, Linear(Alpha))
					if Alpha == 90 then break end
				end
			end)
			tweenJoint(LWeld, nil, tempCrawlAnim.leftArm, Linear, 0.3)
			tweenJoint(RWeld, nil, tempCrawlAnim.rightArm, Linear, 0.3)
			tweenJoint(Grip, nil, tempCrawlAnim.Grip, Linear, 0.3)
			lowerSpread()
			local t0 = tick()
			while true do
				local dt = RS.Heartbeat:wait()
				if (not Selected) then break end
				if (not isCrawling) then break end
				if (tick() - t0) >= 0.3 then
					local crawlAnim = Anims.Crawling(crawlAng, moveAng)
					LWeld.C1 = crawlAnim.leftArm
					RWeld.C1 = crawlAnim.rightArm
					LLegWeld.C1 = crawlAnim.leftLeg
					RLegWeld.C1 = crawlAnim.rightLeg
					Grip.C1 = crawlAnim.Grip
					crawlCamRot = crawlAnim.Camera
					crawlAng = crawlAng + 0.5 * RAD(105 * dt) * (HRP.Velocity * V3(1, 0, 1)).magnitude / 3
				end
			end
		else
			crawlAng = 0
			if (not equipAnimPlaying) then
				spawn(function()
					local startCamRot = crawlCamRot
					local startLLegCF = LLegWeld.C1
					local startRLegCF = RLegWeld.C1
					local t0 = tick()
					while true do
						RS.RenderStepped:wait()
						local Alpha = math.min((tick() - t0) / 0.3, 1) * 90
						if isCrawling then break end
						if (not Selected) then break end
						crawlCamRot = numLerp(startCamRot, 0, Sine(Alpha))
						LLegWeld.C1 = startLLegCF:lerp(CF(), Linear(Alpha))
						RLegWeld.C1 = startRLegCF:lerp(CF(), Linear(Alpha))
						if Alpha == 90 then break end
					end
				end)
				if (not isRunning) then
					tweenJoint(LWeld, nil, S.unAimedC1.leftArm, Sine, 0.3)
					tweenJoint(RWeld, nil, S.unAimedC1.rightArm, Sine, 0.3)
					tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, 0.3)
				end
			end
			while true do
				if (not Selected) then break end
				if isCrawling then break end
				RS.RenderStepped:wait()
			end
		end
		wait()
	end
end

function getAnimCF()
	return 	CF(aimHeadOffset, 0, 0) * CFANG(
		jumpAnim.Rot * COS(camAng.Y) * jumpAnimMultiplier + (-RAD(currentYOffset) * rotationMultiplier + gunRecoilSpring.p.X + Anim.Rot.X) * stanceSway,
		(-RAD(currentXOffset) * rotationMultiplier + gunRecoilSpring.p.Y + Anim.Rot.Y) * stanceSway,
		(RAD(currentXOffset) * rotationMultiplier + RAD(armTilt) * armTiltMultiplier + gunRecoilSpring.p.Z + Anim.Rot.Z) * stanceSway
	) * CF(
		(Anim.Pos.X + recoilAnim.Pos.X) * stanceSway,
		jumpAnim.Pos * COS(camAng.Y) * jumpAnimMultiplier + (Anim.Pos.Y + recoilAnim.Pos.Y) * stanceSway,
		-jumpAnim.Pos * SIN(camAng.Y) * jumpAnimMultiplier + (Anim.Pos.Z + recoilAnim.Pos.Z) * stanceSway
	), CFANG(-camAng.Y * crawlAlpha / 90, 0, 0) * CF(aimHeadOffset, -1, 0)
end

--------------------[ FIRING FUNCTIONS ]----------------------------------------------

function lowerSpread()
	if (not loweringSpread) then
		loweringSpread = true
		local Connection = nil
		Connection = RS.Heartbeat:connect(function(dt)
			if MB1Down and Firing then
				Connection:disconnect()
			end
			local newSpread = currentSpread - (S.spreadSettings.Decrease * dt)
			currentSpread = (newSpread < 0 and 0 or newSpread)
			if currentSpread == 0 then
				Connection:disconnect()
			end
		end)
		loweringSpread = false
	end
end

local function autoFire()
	if (not canFire) then return end
	canFire = false
	
	if (not Knifing) then
		Firing = true
		while MB1Down and (not Reloading) and (not isCrawling) and (not Knifing) do
			if Modes[((rawFireMode - 1) % numModes) + 1] ~= "AUTO" then break end
			if Humanoid.Health == 0 then break end
			if Ammo.Value > 0 then
				Ammo.Value = Ammo.Value - 1
				if Aimed and steadyKeyPressed and S.scopeSettings.unSteadyOnFire then
					steadyKeyPressed = false
					currentSteadyTime = 0
				end
				newMag = false
				fireGun()
			end
			if S.reloadSettings.magIsBullet then
				for _, Mag in pairs(Gun:GetChildren()) do
					if Mag.Name:sub(1, 3) == "Mag" then
						Mag.Transparency = 1
					end
				end
			end
			if Ammo.Value == 0 and S.reloadSettings.autoReload then
				wait(0.2)
				Reload()
			end
			wait(60 / S.roundsPerMin)
		end
	end
	
	Firing = false
	canFire = true
end

local function semiFire()
	if (not canFire) then return end
	canFire = false
	
	if (not Knifing) and (not isCrawling) and Humanoid.Health ~= 0 then
		Firing = true
		if Ammo.Value > 0 then
			Ammo.Value = Ammo.Value - 1
			if Aimed and steadyKeyPressed and S.scopeSettings.unSteadyOnFire then
				steadyKeyPressed = false
				currentSteadyTime = 0
			end
			newMag = false
			fireGun()
		end
		if S.reloadSettings.magIsBullet then
			for _, Mag in pairs(Gun:GetChildren()) do
				if Mag.Name:sub(1, 3) == "Mag" then
					Mag.Transparency = 1
				end
			end
		end
		if Ammo.Value == 0 and S.reloadSettings.autoReload then
			wait(0.2)
			Reload()
		end
		wait(60 / S.roundsPerMin)
	end
	
	Firing = false
	canFire = true
end

local function burstFire()
	if (not canFire) then return end
	canFire = false
	
	local burstTime = 60 / S.roundsPerMin
	if (not Knifing) and (not isCrawling) then
		Firing = true
		for i = 1, S.burstSettings.Amount do
			if Ammo.Value > 0 then
				Ammo.Value = Ammo.Value - 1
				if Humanoid.Health ~= 0 then
					if Aimed and steadyKeyPressed and S.scopeSettings.unSteadyOnFire then
						steadyKeyPressed = false
						currentSteadyTime = 0
					end
					newMag = false
					fireGun()
				end
			end
			if Ammo.Value == 0 and S.reloadSettings.autoReload then
				wait(0.2)
				Reload()
				break
			end
			wait(S.burstSettings.fireRateBurst and burstTime or S.burstSettings.Time / S.burstSettings.Amount)
		end
	end
	if S.reloadSettings.magIsBullet then
		for _, Mag in pairs(Gun:GetChildren()) do
			if Mag.Name:sub(1, 3) == "Mag" then
				Mag.Transparency = 1
			end
		end
	end
	
	Firing = false
	
	wait(S.burstSettings.fireRateBurst and burstTime or S.burstSettings.Wait)
	
	canFire = true
end

function fireGun()
	local fireSound = Handle:FindFirstChild("FireSound")
	if fireSound then fireSound:Play() end
	----------------------------------------------------------------------------------
	for _ = 1, (S.gunType.Shot and S.ShotAmount or 1) do
		local randSpread1 = RAD(RAND(0, 365))
		local randSpread2 = RAD(RAND(-(baseSpread + currentSpread), baseSpread + currentSpread, 0.01))
		local spreadDir = CFrame.fromAxisAngle(V3(0, 0, 1), randSpread1) * CFANG(randSpread2, 0, 0)
		
		local originCF = ((Aimed and S.guiScope) and Head.CFrame or Handle.CFrame) * spreadDir
		local bulletDirection = CF(originCF.p, originCF.p + originCF.lookVector).lookVector
		
		if S.bulletSettings.instantHit then
			local newRay = Ray.new(Main.CFrame.p, bulletDirection * S.bulletSettings.Range)
			local H, P, N = workspace:FindPartOnRayWithIgnoreList(newRay, Ignore)
			local finalP = P
			if H then
				if S.gunType.Explosive then
					if S.explosionSettings.soundId ~= "" then
						local soundPart = Instance.new("Part")
						soundPart.Transparency = 1
						soundPart.Anchored = true
						soundPart.CanCollide = false
						soundPart.Size = V3(1, 1, 1)
						soundPart.CFrame = CFrame.new(P)
						soundPart.Parent = gunIgnore
						
						local Sound = Instance.new("Sound")
						Sound.Pitch = S.explosionSettings.Pitch
						Sound.SoundId = S.explosionSettings.soundId
						Sound.Volume = S.explosionSettings.Volume
						Sound.Parent = soundPart
						Sound:Play()
						
						DS:AddItem(soundPart, Sound.TimeLength)
					end
					createBulletImpact:FireServer(H, P, N, bulletDirection, false, gunIgnore, S)
					createShockwave:FireServer(P, S.explosionSettings.Radius, gunIgnore, S)
					local E = Instance.new("Explosion")
					E.BlastPressure = S.explosionSettings.Pressure
					E.BlastRadius = S.explosionSettings.Radius
					E.DestroyJointRadiusPercent = (S.explosionSettings.rangeBasedDamage and 0 or 1)
					E.ExplosionType = S.explosionSettings.Type
					E.Position = P
					E.Hit:connect(function(Obj, Dist)
						if Obj.Name == "Torso" and (not Obj:IsDescendantOf(Char)) then
							if S.explosionSettings.rangeBasedDamage then
								local Dir = (Obj.Position - P).unit
								local expH, _ = workspace:FindPartOnRayWithIgnoreList(
									Ray.new(P - Dir * 0.1, Dir * 999),
									Ignore
								)
								local rayHitHuman = expH:IsDescendantOf(Obj.Parent)
								if (S.explosionSettings.rayCastExplosions and rayHitHuman) or (not S.explosionSettings.rayCastExplosions) then
									local hitHumanoid = findFirstClass(Obj.Parent, "Humanoid")
									if hitHumanoid and hitHumanoid.Health > 0 and isEnemy(hitHumanoid) then
										local distFactor = Dist / S.explosionSettings.Radius
										local distInvert = math.max(1 - distFactor,0)
										local newDamage = distInvert * getBaseDamage((P - Main.CFrame.p).magnitude)
										
										local Tag = Instance.new("ObjectValue")
										Tag.Value = Player
										Tag.Name = "creator"
										Tag.Parent = hitHumanoid
										DS:AddItem(Tag, 0.3)
										hitHumanoid:TakeDamage(newDamage)
										markHit()
									end
								end
							else
								local hitHumanoid = findFirstClass(Obj.Parent, "Humanoid")
								if hitHumanoid and hitHumanoid.Health > 0 and isEnemy(hitHumanoid) then
									local Tag = Instance.new("ObjectValue")
									Tag.Value = Player
									Tag.Name = "creator"
									Tag.Parent = hitHumanoid
									DS:AddItem(Tag, 0.3)
									markHit()
								end
							end
						end
					end)
					E.Parent = game.Workspace
				else
					_, finalP = penetrateWall(H, P, bulletDirection, N, {Char, ignoreModel}, 0, (P - Main.CFrame.p).magnitude, nil)
				end
			end
			if S.bulletTrail and S.trailSettings.Transparency ~= 1 then
				createTrail:FireServer(Main.CFrame.p, finalP, gunIgnore, S)
			end
		else
				local shell = Instance.new("Part")
	shell.CFrame = Gun.Chamber.CFrame * CFrame.fromEulerAnglesXYZ(-1.5,0,0)
	shell.Size = Vector3.new(1,1,1)
	shell.BrickColor = BrickColor.new(24)
	shell.Reflectance = .5
	shell.CanCollide = false	
	shell.BottomSurface = 0
	shell.TopSurface = 0
	shell.Name = "Shell"
	shell.Velocity = Gun.Chamber.CFrame.lookVector * 30 + Vector3.new(math.random(-10,10),20,math.random(-10,10))
	shell.RotVelocity = Vector3.new(0,200,0)
	local shellmesh = Instance.new("CylinderMesh")
	shellmesh.Scale = Vector3.new(0.1, 0.8, 0.1)
	shellmesh.Parent = shell
	shell.Parent = game.Workspace
	game:GetService("Debris"):addItem(shell,2)
	
	local shellmesh = Instance.new("SpecialMesh")
	shellmesh.Scale = Vector3.new(0.9,0.9,3)
	shellmesh.MeshId = "http://www.roblox.com/asset/?id=95387759"
	shellmesh.TextureId = "http://www.roblox.com/asset/?id=95387789"
	shellmesh.MeshType = "FileMesh"
	shellmesh.Parent = shell
		end
	end
	function MarkHit()
	spawn(function()
		if Gui_Clone:IsDescendantOf(game) then
			Gui_Clone.HitMarker.Visible = true
			local StartMark = tick()
			LastMark = StartMark
			wait(0.5)
			if LastMark <= StartMark then
				Gui_Clone.HitMarker.Visible = false
			end
		end
	end)
end
	
	----------------------------------------------------------------------------------
	
	currentSpread = currentSpread + S.spreadSettings.Increase
	
	for _, Plugin in pairs(Plugins.Firing) do
		spawn(function()
			Plugin()
		end)
	end
	
	local backRecoil = RAND(S.recoilSettings.Recoil.Back.Min, S.recoilSettings.Recoil.Back.Max, 0.01) --Get the kickback recoil
	local upRecoil = RAND(S.recoilSettings.Recoil.Up.Min, S.recoilSettings.Recoil.Up.Max, 0.01) --Get the up recoil
	local sideRecoilAlpha = 0
	if lastSideRecoil[1] < 0 and lastSideRecoil[2] < 0 then --This conditional basically makes sure the gun tilt isn't in the same direction for more than 2 shots
		sideRecoilAlpha = RAND(0, 1, 0.1)
	elseif lastSideRecoil[1] > 0 and lastSideRecoil[2] > 0 then
		sideRecoilAlpha = RAND(-1, 0, 0.1)
	else
		sideRecoilAlpha = RAND(-1, 1, 0.1)
	end
	local sideRecoil = numLerp(S.recoilSettings.Recoil.Side.Left, S.recoilSettings.Recoil.Side.Right, sideRecoilAlpha / 2 + 0.5) --Get the side recoil
	local tiltRecoil = numLerp(S.recoilSettings.Recoil.Tilt.Left, S.recoilSettings.Recoil.Tilt.Right, sideRecoilAlpha / 2 + 0.5) --Get the tilt recoil
	local recoilPos = V3(
		0,---sideRecoil,
		0,
		-backRecoil
	) * (Aimed and S.recoilSettings.aimedMultiplier or 1)
	local recoilRot = V3(
		(Aimed and 0 or (-RAD(upRecoil * 10) * (firstShot and S.recoilSettings.firstShotMultiplier or 1))),
		RAD(sideRecoil * 10),
		RAD(tiltRecoil * 10)
	) * (Aimed and S.recoilSettings.aimedMultiplier or 1)
	local camRecoilRot = V3(
		-RAD(sideRecoil * 10),
		RAD(upRecoil * 10) * (firstShot and S.recoilSettings.firstShotMultiplier or 1) * S.recoilSettings.camMultiplier,
		0
	) * (Aimed and S.recoilSettings.aimedMultiplier or 1) * stanceSway
	tweenRecoil(recoilPos, recoilRot, Sine, 0.2)
	tweenCam("Recoil", camRecoilRot, Sine, 0.15 * (firstShot and S.recoilSettings.firstShotMultiplier or 1))
	
	for _, v in pairs(Main:GetChildren()) do
		if v.Name:sub(1, 7) == "FlashFX" then
			v.Enabled = true
		end
	end
			local shell = Instance.new("Part")
	shell.CFrame = Gun.Chamber.CFrame * CFrame.fromEulerAnglesXYZ(-1.5,0,0)
	shell.Size = Vector3.new(0.2,0.5,0.2)
	shell.CanCollide = true	
	shell.Name = "Shell"
	shell.Velocity = Gun.Chamber.CFrame.lookVector * 30 + Vector3.new(math.random(-10,10),20,math.random(-10,10))
	shell.RotVelocity = Vector3.new(0,200,0)
	shell.Parent = game.Workspace
	game:GetService("Debris"):addItem(shell,2)
	local shellmesh = Instance.new("SpecialMesh")
	shellmesh.Scale = Vector3.new(0.5,0.5,0.5)
	shellmesh.MeshId = "http://www.roblox.com/asset/?id=94248124"
	shellmesh.TextureId = "http://www.roblox.com/asset/?id=94219470"
	shellmesh.MeshType = "FileMesh"
	shellmesh.Parent = shell
	delay(1 / 20, function()
		tweenRecoil(V3(), V3(), Sine, 0.2)
		tweenCam("Recoil", V3(), Sine, 0.2)
		for _, v in pairs(Main:GetChildren()) do
			if v.Name:sub(1, 7) == "FlashFX" then
				v.Enabled = false
			end
		end
	end)
	
	updateClipAmmo()
	firstShot = false
	shotCount = shotCount + 1
	lastSideRecoil[(shotCount % 2) + 1] = sideRecoilAlpha
end

function markHit()
	spawn(function()
		if mainGUI:IsDescendantOf(game) then
			hitMarker.Visible = true
			local startMark = tick()
			hitMarker.lastMark.Value = startMark
			
			wait(0.5)
			
			if hitMarker.lastMark.Value <= startMark then
				hitMarker.Visible = false
			end
		end
	end)
end

--------------------[ ADS FUNCTIONS ]-------------------------------------------------

function aimGun()
	if Reloading or Knifing or isCrawling or (not S.canADS) then return end
	
	mouseSensitivity = aimSensitivity
	
	for _, Plugin in pairs(Plugins.Aimed) do
		spawn(function()
			Plugin()
		end)
	end
	
	Aimed = true
	Aiming = true
	Running = false
	spreadZoom = "Aimed"
	baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	if S.aimSettings.Anim then
		local currentFOV = Cam.FieldOfView
		local currentTrans = Scope.BackgroundTransparency
		tweenJoint(LWeld, armC0[1], S.aimedC1.leftArm, Sine, S.aimSettings.Speed)
		tweenJoint(RWeld, armC0[2], S.aimedC1.rightArm, Sine, S.aimSettings.Speed)
		tweenJoint(LWeld2, nil, CF(), Sine, S.aimSettings.Speed)
		tweenJoint(RWeld2, nil, CF(), Sine, S.aimSettings.Speed)
		tweenJoint(Grip, nil, aimedGripCF, Sine, S.aimSettings.Speed)
		tweenJoint(headWeld2, nil, CF(0, -0.5, 0) * CFANG(0, 0, S.aimSettings.headTilt) * CF(0, 0.5, 0), Sine, S.aimSettings.Speed)
		local t0 = tick()
		while true do
			RS.RenderStepped:wait()
			local Alpha = math.min((tick() - t0) / S.aimSettings.Speed, 1) * 90
			if (not Aimed) then break end
			if (not Selected) then break end
			aimAlpha = Sine(Alpha)
			aimHeadOffset = headOffset.X * aimAlpha
			jumpAnimMultiplier = numLerp(1, S.fallSettings.aimEffect, aimAlpha)
			translationDivisor = numLerp(7, 20, aimAlpha)
			rotationMultiplier = numLerp(S.momentumSettings.Amplitude.unAimed, S.momentumSettings.Amplitude.Aimed, aimAlpha)
			armTiltMultiplier = numLerp(1, 0.2, aimAlpha)
			Cam.FieldOfView = numLerp(currentFOV, S.aimSettings.FOV, aimAlpha)
			if S.guiScope then
				Scope.BackgroundTransparency = numLerp(currentTrans, 0, aimAlpha)
			end
			if Alpha == 90 then break end
		end
	else
		LWeld.C0, LWeld.C1 = armC0[1], S.aimedC1.leftArm
		RWeld.C0, RWeld.C1 = armC0[2], S.aimedC1.rightArm
		LWeld2.C1, RWeld2.C1 = CF(), CF()
		animWeld.C0 = CF(0, 1, 0)
		Grip.C1 = aimedGripCF
		headWeld2.C1 = CF(0, -0.5, 0) * CFANG(0, 0, S.aimSettings.headTilt) * CF(0, 0.5, 0)
		aimAlpha = 1
		aimHeadOffset = headOffset.X
		jumpAnimMultiplier = S.fallSettings.aimEffect
		translationDivisor = 20
		rotationMultiplier = S.momentumSettings.Amplitude.Aimed
		armTiltMultiplier = 0.2
		Cam.FieldOfView = S.aimSettings.FOV
	end
	Aiming = (not Aimed)
	if (not Aiming) and S.guiScope then
		spawn(function()
			scopeSteady.Visible = true
			Scope.BackgroundTransparency = 1
			scopeMain.Visible = true
			
			if armTable then
				for _, Obj in pairs(armTable[1].Model:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 1
					end
				end
				for _, Obj in pairs(armTable[2].Model:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 1
					end
				end
			elseif armModel then
				for _, Obj in pairs(armModel:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 1
					end
				end
			end
			for _, Obj in pairs(playerFolder:GetChildren()) do
				if Obj:IsA("BasePart") then
					Obj.LocalTransparencyModifier = 1
				end
			end
			for _, Obj in pairs(Gun:GetChildren()) do
				if Obj:IsA("BasePart") then
					Obj.LocalTransparencyModifier = 1
				end
			end
		end)
		spawn(function()
			local camAng = 0
			local idleCam = function()
				return V3(
					RAD(SIN(camAng * S.scopeSettings.Frequency.Idling)) * stanceSway * camSway * S.scopeSettings.Amplitude.Idling,
					RAD(SIN(camAng * 5 / 2 * S.scopeSettings.Frequency.Idling)) * stanceSway * camSway * S.scopeSettings.Amplitude.Idling * 0.75,
					0
				)
			end
			local walkCam = function()
				return V3(
					RAD(SIN(camAng * S.scopeSettings.Frequency.Walking)) * camSway * stanceSway * S.scopeSettings.Amplitude.Walking,
					RAD(SIN(camAng * 5 / 2 * S.scopeSettings.Frequency.Walking)) * camSway * stanceSway * S.scopeSettings.Amplitude.Walking * 0.75,
					0
				)
			end
			while Aimed do
				local dt = RS.RenderStepped:wait()
				camOffsets.guiScope.Rot = (Sine(idleAlpha) * idleCam()) + (Sine(walkAlpha) * walkCam())
				camAng = camAng + RAD(105 * dt) * stanceSway * camSway
			end
		end)
	end
end

function unAimGun(Exception)
	if (not S.canADS) then return end
	
	mouseSensitivity = S.sensitivitySettings.Default
	
	for _, Plugin in pairs(Plugins.UnAimed) do
		spawn(function()
			Plugin()
		end)
	end
	
	if S.guiScope then
		spawn(function()
			if armTable then
				for _, Obj in pairs(armTable[1].Model:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 0
					end
				end
				for _, Obj in pairs(armTable[2].Model:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 0
					end
				end
			elseif armModel then
				for _, Obj in pairs(armModel:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 0
					end
				end
			end
			for _, Obj in pairs(playerFolder:GetChildren()) do
				if Obj:IsA("BasePart") then
					Obj.LocalTransparencyModifier = 0
				end
			end
			for _, Obj in pairs(Gun:GetChildren()) do
				if Obj:IsA("BasePart") then
					Obj.LocalTransparencyModifier = 0
				end
			end
		end)
	end
	
	if (not Exception) then
		if (not Aimed) then return end
		if (Reloading and Exception) or Knifing then return end
		spreadZoom = "unAimed"
		baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
		Aimed = false
		Aiming = true
		if S.aimSettings.Anim then
			local currentFOV = Cam.FieldOfView
			local currentTrans = (Scope.BackgroundTransparency == 1 and (S.guiScope and 0 or 1) or Scope.BackgroundTransparency)
			scopeMain.Visible = false
			scopeSteady.Visible = false
			tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, S.aimSettings.Speed)
			tweenJoint(RWeld, armC0[2], S.unAimedC1.rightArm, Sine, S.aimSettings.Speed)
			tweenJoint(headWeld2, nil, CF(), Sine, S.aimSettings.Speed)
			tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, S.aimSettings.Speed)
			local t0 = tick()
			while true do
				RS.RenderStepped:wait()
				local Alpha = math.min((tick() - t0) / S.aimSettings.Speed, 1) * 90
				if Aimed then break end
				if (not Selected) then break end
				aimAlpha = 1 - Sine(Alpha)--1 - COS(RAD(X))
				aimHeadOffset = headOffset.X * aimAlpha
				jumpAnimMultiplier = numLerp(1, S.fallSettings.aimEffect, aimAlpha)
				translationDivisor = numLerp(7, 20, aimAlpha)
				rotationMultiplier = numLerp(S.momentumSettings.Amplitude.unAimed, S.momentumSettings.Amplitude.Aimed, aimAlpha)
				armTiltMultiplier = numLerp(1, 0.2, aimAlpha)
				Cam.FieldOfView = numLerp(80, currentFOV, aimAlpha)
				Scope.BackgroundTransparency = numLerp(1, currentTrans, aimAlpha)
				if Alpha == 90 then break end
			end
		else
			scopeMain.Visible = false
			scopeSteady.Visible = false
			LWeld.C0, LWeld.C1 = armC0[1], S.unAimedC1.leftArm
			RWeld.C0, RWeld.C1 = armC0[2], S.unAimedC1.rightArm
			headWeld2.C0 = CF()
			Grip.C1 = S.unAimedC1.Grip
			aimAlpha = 0
			aimHeadOffset = 0
			jumpAnimMultiplier = 1
			translationDivisor = 7
			rotationMultiplier = S.momentumSettings.Amplitude.unAimed
			armTiltMultiplier = 1
			Cam.FieldOfView = 80
			Scope.BackgroundTransparency = 1
		end
		Aiming = Aimed
	else
		spawn(function()
			Aimed = false
			Aiming = false
			spreadZoom = "unAimed"
			baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
			local currentFOV = Cam.FieldOfView
			local currentTrans = (Scope.BackgroundTransparency == 1 and (S.guiScope and 0 or 1) or Scope.BackgroundTransparency)
			scopeMain.Visible = false
			scopeSteady.Visible = false
			tweenJoint(headWeld2, nil, CF(), Sine, S.aimSettings.Speed)
			if S.aimSettings.Anim then
				local t0 = tick()
				while true do
					RS.RenderStepped:wait()
					local Alpha = math.min((tick() - t0) / S.aimSettings.Speed, 1) * 90
					if Aimed then break end
					if (not Selected) then break end
					aimAlpha = 1 - Sine(Alpha)--1 - COS(RAD(90 - Alpha))
					aimHeadOffset = headOffset.X * aimAlpha
					jumpAnimMultiplier = numLerp(1, S.fallSettings.aimEffect, aimAlpha)
					translationDivisor = numLerp(7, 20, aimAlpha)
					rotationMultiplier = numLerp(S.momentumSettings.Amplitude.unAimed, S.momentumSettings.Amplitude.Aimed, aimAlpha)
					armTiltMultiplier = numLerp(1, 0.2, aimAlpha)
					Cam.FieldOfView = numLerp(80, currentFOV, aimAlpha)
					Scope.BackgroundTransparency = numLerp(1, currentTrans, aimAlpha)
					if Alpha == 90 then break end
				end
			else
				scopeMain.Visible = false
				scopeSteady.Visible = false
				aimAlpha = 0
				aimHeadOffset = 0
				jumpAnimMultiplier = 1
				translationDivisor = 7
				rotationMultiplier = S.momentumSettings.Amplitude.unAimed
				armTiltMultiplier = 1
				Cam.FieldOfView = 80
				Scope.BackgroundTransparency = 1
			end
		end)
	end
end

--------------------[ TEXTURE CREATION FUNCTIONS ]------------------------------------

function createBullet(Direction)
	local Origin = Gun.Main.CFrame.p
	local bulletCF = CF(Origin, Origin + Direction)
	local Bullet = Instance.new("Part")
	Bullet.BrickColor = S.bulletSettings.Color
	Bullet.Material = Enum.Material.Neon
	Bullet.Name = "Bullet"
	Bullet.CanCollide = false
	Bullet.FormFactor = "Custom"
	Bullet.Size = S.bulletSettings.Size
	Bullet.BottomSurface = "Smooth"
	Bullet.TopSurface = "Smooth"
	if math.min(S.bulletSettings.Size.X, S.bulletSettings.Size.Y, S.bulletSettings.Size.Z) < 0.2 then
		local Mesh = Instance.new("BlockMesh")
		Mesh.Scale = S.bulletSettings.Size / Vector3.new(
			math.max(S.bulletSettings.Size.X, 0.2),
			math.max(S.bulletSettings.Size.Y, 0.2),
			math.max(S.bulletSettings.Size.Z, 0.2)
		)
		Mesh.Parent = Bullet
	end
	local BF = Instance.new("BodyForce")
	BF.force = V3(0, Bullet:GetMass() * (196.2 - S.bulletSettings.Acceleration), 0)
	BF.Parent = Bullet
	Bullet.Parent = gunIgnore
	Bullet.CFrame = bulletCF + Direction * S.bulletSettings.Size.Z / 2
	Bullet.Velocity = Direction * S.bulletSettings.Velocity
	return Bullet
end

--------------------[ HIT HANDLING FUNCTIONS ]----------------------------------------

function getBaseDamage(Dist)
	local startDmg = S.damageSettings.Start.Damage
	local startDist = S.damageSettings.Start.Dist
	local endDmg = S.damageSettings.End.Damage
	local endDist = S.damageSettings.End.Dist
	return (
		(
			Dist < startDist * S.bulletSettings.Range
		) and startDmg or
		(
			Dist >= startDist * S.bulletSettings.Range and
			Dist < endDist * S.bulletSettings.Range
		) and numLerp(startDmg, endDmg, Map(Dist / S.bulletSettings.Range, startDist, endDist, 0, 1)) or
		(
			Dist >= endDist * S.bulletSettings.Range
		) and endDmg
	)
end

function Damage(H, P, N, D, Dist, customIgnore)
	local hVal = S.damageSettings.Multipliers.Head
	local cVal = S.damageSettings.Multipliers.Chest
	local lVal = S.damageSettings.Multipliers.Limbs
	local baseDamage = getBaseDamage(Dist)
	if Humanoid.Health ~= 0 then
		local hitHumanoid = nil
		if H.Parent:IsA("Hat") then
			table.insert(customIgnore, H)
			local newRay = Ray.new(P - D * 0.1, D * (S.bulletSettings.Range - Dist + 0.1))
			local newH, newP, newN = workspace:FindPartOnRayWithIgnoreList(newRay, customIgnore)
			if newH then
				hitHumanoid = Damage(newH, newP, newN, D, Dist + (newP - P).magnitude, customIgnore)
			end
		else
			hitHumanoid = findFirstClass(H.Parent, "Humanoid")
			if hitHumanoid and hitHumanoid.Health > 0 and isEnemy(hitHumanoid) then
				local Tag = Instance.new("ObjectValue")
				Tag.Value = Player
				Tag.Name = "creator"
				Tag.Parent = hitHumanoid
				DS:AddItem(Tag, 0.3)
				local chosenDamage = 0
				if H.Name == "Head" then
					chosenDamage = baseDamage  * RAND(hVal, hVal + 0.1, 0.01)
				elseif H.Name == "Torso" then
					chosenDamage = baseDamage  * RAND(cVal, cVal + 0.1, 0.01)
				else
					chosenDamage = baseDamage  * RAND(lVal, lVal + 0.1, 0.01)
				end
				hitHumanoid:TakeDamage(chosenDamage)
				markHit()
			end
		end
		return hitHumanoid
	end
end

function isWallIgnored(Wall)
	return (
		Wall.Transparency >= S.penetrationSettings.transparencyThreshold or
		(S.penetrationSettings.ignoreNonCanCollide and (not Wall.CanCollide)) or
		isIgnored(Wall, S.penetrationSettings.ignoreCustom)
	)
end

function penetrateWall(Wall, hitPos, Direction, Normal, Ignore, totalPDist, totalBDist, lastDamagedHumanoid)
	local wallIgnore = isWallIgnored(Wall)
	local hitHumanoid = (Wall.Parent:IsA("Hat") and findFirstClass(Wall.Parent.Parent, "Humanoid") or findFirstClass(Wall.Parent, "Humanoid"))
	local damagedHumanoid = nil
	if hitHumanoid and hitHumanoid ~= lastDamagedHumanoid then
		lastDamagedHumanoid = hitHumanoid
		damagedHumanoid = Damage(Wall, hitPos, Normal, Direction, totalBDist, {Char, ignoreModel})
	else
		lastDamagedHumanoid = nil
	end
	local ignoreObject = hitHumanoid and (Wall.Parent:IsA("Hat") and Wall.Parent.Parent or Wall.Parent) or Wall
	table.insert(Ignore, ignoreObject)
	local rayLength = S.bulletSettings.Range - totalBDist
	local testRay = Ray.new(hitPos, Direction * (S.bulletSettings.Range - totalBDist))
	local H1, P1, N1 = workspace:FindPartOnRayWithIgnoreList(testRay, Ignore)
	local newIgnore = removeElement(Ignore, ignoreObject)
	local wallRay = Ray.new(P1 + Direction * 0.1, -Direction * (rayLength + 1))
	local H2, P2, N2 = workspace:FindPartOnRayWithIgnoreList(wallRay, Ignore)
	local newPDist = totalPDist + (wallIgnore and 0 or (getNearestPoint(P1, P2, hitPos) - hitPos).magnitude)
	local newBDist = totalBDist + (P1 - hitPos).magnitude
	local outOfRange = Round(newPDist, 0.001) > S.penetrationSettings.Dist or Round(newBDist, 0.001) > S.bulletSettings.Range
	if (not wallIgnore) then
		createBulletImpact:FireServer(Wall, hitPos, Normal, Direction, hitHumanoid, gunIgnore, S)
		if (not hitHumanoid) then
			createShockwave:FireServer(hitPos, S.shockwaveSettings.Radius, gunIgnore, S)
		end
	end
	if hitHumanoid and hitHumanoid.Health > 0 and isEnemy(hitHumanoid) and hitHumanoid == damagedHumanoid then
		createBlood:FireServer(Wall, P2, Direction, gunIgnore, S)
	end
	if outOfRange or (not H1) then
		if (not outOfRange) and (not wallIgnore) then
			createBulletImpact:FireServer(Wall, P2, N2, Direction, hitHumanoid, gunIgnore, S)
			if (not hitHumanoid) then
				createShockwave:FireServer(P2, S.shockwaveSettings.Radius, gunIgnore, S)
			end
		end
		return Wall, hitPos
	else
		if Wall == H2 and (not wallIgnore) then
			createBulletImpact:FireServer(Wall, P2, N2, Direction, hitHumanoid, gunIgnore, S)
			if (not hitHumanoid) then
				createShockwave:FireServer(P2, S.shockwaveSettings.Radius, gunIgnore, S)
			end
		end
		return penetrateWall(H1, P1, Direction, N1, Ignore, newPDist, newBDist, lastDamagedHumanoid)
	end
end

function PenetrateWall(HitPos, Direction, HitHumanoid, OriginPos, Bullet, CurrentPDist)
	local HitDist = (HitPos - OriginPos).magnitude
	local Wall, WallHitPos = nil, nil
	local Hum, HumHitPos = nil, nil
	local CustomIgnore = {unpack(Ignore)}
	for i = 1, 10 do
		local WallRay = Ray.new(HitPos - (Direction * 0.1), Direction * S.Penetration)
		local H, P = game.Workspace:FindPartOnRayWithIgnoreList(WallRay, CustomIgnore)
		if H then
			local HitHumanoid = nil
			if H.Parent.ClassName == "Hat" then
				HitHumanoid = findFirstClass(H.Parent.Parent, "Humanoid")
			else
				HitHumanoid = findFirstClass(H.Parent, "Humanoid")
			end
			if HitHumanoid and i ~= 1 then
				Hum, HumHitPos = H, P
				break
			else
				Wall, WallHitPos = H, P
				table.insert(CustomIgnore, H)
			end
		else
			break
		end
	end
	if Wall then
		if S.InstantHit then
			if Hum then
				Damage(Hum.Parent:FindFirstChild("Head"), HumHitPos)
				return HumHitPos
			else
				local HitObj2, HitPos2 = nil, nil
				if HitHumanoid then
					HitObj2, HitPos2 = AdvRayCast(WallHitPos, Direction, S.BulletRange - HitDist, {Wall, HitHumanoid.Parent, unpack(Ignore)})
				else
					HitObj2, HitPos2 = AdvRayCast(WallHitPos, Direction, S.BulletRange - HitDist, {Wall, unpack(Ignore)})
				end
				Damage(HitObj2, HitPos2)
				
				local NewPDist = CurrentPDist + (WallHitPos - HitPos).magnitude
				local NewHitPos2 = HitPos2
				if NewPDist < S.Penetration and HitObj2 then
					NewHitPos2 = PenetrateWall(HitPos2, Direction, HitHumanoid, OriginPos, Bullet, CurrentPDist + NewPDist)
				end
				return NewHitPos2
			end
		else
			local LastPos = WallHitPos
			local TotalDistTraveled = 0
			spawn(function()
				if Hum then
					Damage(Hum.Parent:FindFirstChild("Head"), HumHitPos)
					return HumHitPos
				else
					while true do
						RS.RenderStepped:wait()
						if TotalDistTraveled >= S.BulletRange - HitDist then
							Bullet:Destroy()
							break
						end
						local DistTraveled = (Bullet.Position - LastPos).magnitude
						local NewDirection = (Bullet.Position - LastPos).unit
						local TempHitObj, TempHitPos = nil, nil
						if HitHumanoid then
							TempHitObj, TempHitPos = AdvRayCast(LastPos, NewDirection, DistTraveled, {Wall, HitHumanoid.Parent, unpack(Ignore)})
						else
							TempHitObj, TempHitPos = AdvRayCast(LastPos, NewDirection, DistTraveled, {Wall, unpack(Ignore)})
						end
						if TempHitObj then
							Damage(TempHitObj, TempHitPos)
							
							local NewPDist = CurrentPDist + (WallHitPos - HitPos).magnitude
							local NewTempPos = TempHitPos
							if NewPDist < S.Penetration and TempHitObj then
								NewTempPos = PenetrateWall(TempHitPos, Direction, HitHumanoid, OriginPos, Bullet, CurrentPDist + NewPDist)
							else
								Bullet:Destroy()
							end
							return NewTempPos
						else
							LastPos = Bullet.Position
							TotalDistTraveled = TotalDistTraveled + DistTraveled
						end
					end
				end
			end)
		end
	else
		if Bullet then Bullet:Destroy() end
		return HitPos
	end
end

function isEnemy(Human)
	local Plyr = game.Players:GetPlayerFromCharacter(Human.Parent)
	if (not Plyr) then return S.CanDamageNPCs end
	return S.AllowFriendlyFire or (Plyr.TeamColor ~= Player.TeamColor or Plyr.Neutral)
end

--------------------[ RELOAD FUNCTIONS ]----------------------------------------------

function animateReload()
	tweenJoint(LWeld2, CF(), CF(), Sine, 0.15)
	tweenJoint(RWeld2, CF(), CF(), Sine, 0.15)
	local magParts = {}
	local magTable = {}
			
	for _, Obj in pairs(Gun:GetChildren()) do
		if string.sub(Obj.Name, 1, 3) == "Mag" and Obj:IsA("BasePart") then
			INSERT(magParts, Obj)
		end
	end
	
	local animVars = {
		--FUNCTIONS--
		tweenJoint = tweenJoint;
		
		makeMagInvisible = function()
			for _, v in pairs(magParts) do
				v.Transparency = 1
			end
			magVisible = false
		end;
		
		makeMagVisible = function()
			for _, v in pairs(magParts) do
				v.Transparency = v:WaitForChild("magTrans").Value
			end
			magVisible = true
		end;
		
		isMagVisible = function()
			return magVisible
		end;
		
		isMagEmpty = function()
			return ammoInClip == 0
		end;
		
		setNewMag = function()
			newMag = true
		end;
		
		isNewMag = function()
			return newMag
		end;
		
		createMag = function(Key)
			local magModel = Instance.new("Model")
			local magClones = {}
			for i, v in pairs(magParts) do
				local vClone = v:Clone()
				vClone.Transparency = v:WaitForChild("magTrans").Value
				vClone.CanCollide = false
				vClone.Parent = magModel
				INSERT(magClones, {Original = v, magClone = vClone})
				if i ~= 1 then
					local W = Instance.new("Weld")
					W.Part0 = magClones[1].magClone
					W.Part1 = vClone
					W.C0 = magClones[1].magClone.CFrame:toObjectSpace(vClone.CFrame)
					W.Parent = magClones[1].magClone
				end
			end
			magTable[Key] = {magModel, magClones}
			return magModel, magClones
		end;
		
		getMag = function(Key)
			if magTable[Key] then
				return magTable[Key][1], magTable[Key][2]
			else
				return nil, nil
			end
		end;
		
		attachGripToHead = function()
			local handleCF = RArm.CFrame * Grip.C0
			Grip.C0 = Head.CFrame:toObjectSpace(handleCF)
			Grip.Part0 = Head
		end;
		
		attachGripToArm = function()
			local handleCF = Head.CFrame * Grip.C0
			Grip.C0 = RArm.CFrame:toObjectSpace(handleCF)
			Grip.Part0 = RArm
		end;
		
		Sine = Sine;
		
		Linear = Linear;
		
		--VARIABLES--
		Handle = Handle;
		LArm = LArm;
		RArm = RArm;
		LWeld = LWeld;
		RWeld = RWeld;
		LC0 = armC0[1];
		RC0 = armC0[2];
		Grip = Grip;
		gunIgnore = gunIgnore;
		Cam = Cam;
		CF = CF;
		CFANG = CFANG;
		V3 = V3;
		RAD = RAD;
		reloadTimeLoaded = S.reloadSettings.Times.Loaded;
		reloadTimeEmpty = S.reloadSettings.Times.Empty
	}
	
	local sequenceTable = Anims.Reload(animVars)
	--local T = tick()
	for _, reloadFunction in pairs(sequenceTable) do
		if breakReload then
			break
		end
		reloadFunction()
		
		if (not magVisible) then
			Ammo.Value = 0
		end
		updateClipAmmo()
	end
	--print(tick() - T) --I divide the reloadTime by this number to get the animation speed
	
	if (not isCrawling) then
		if Running and (not S.canFireWhileRunning) then
			tweenJoint(LWeld, armC0[1], S.runningC1.leftArm, Sine, 0.4)
			tweenJoint(RWeld, armC0[2], S.runningC1.rightArm, Sine, 0.4)
			tweenJoint(Grip, nil, S.runningC1.Grip, Sine, 0.4)
		else
			tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, 0.4)
			tweenJoint(RWeld, armC0[2], S.unAimedC1.rightArm, Sine, 0.4)
			tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, 0.4)
		end
	end
	
	for _, v in pairs(magTable) do --In case the reload animations was stopped mid way and there were still fake mags that weren't deleted
		v[1]:Destroy()
	end
end

function Reload()
	if Ammo.Value < (ClipSize.Value + 1) and (not Reloading) and StoredAmmo.Value > 0 then
		Firing = false
		ammoInClip = (ammoInClip == 0 and Ammo.Value or ammoInClip)
		Reloading = true
		lowerSpread()
		if Aimed then unAimGun(S.reloadSettings.Anim) end
		crossHair.Reload.Visible = true
		if Handle:FindFirstChild("ReloadSound") then Handle.ReloadSound:Play() end
		if S.reloadSettings.Anim then
			wait()
			animateReload()
		else
			local startReload = tick()
			local initialReloadTime = Ammo.Value == 0 and S.reloadSettings.Times.Empty or S.reloadSettings.Times.Loaded
			while true do
				if breakReload then break end
				if (tick() - startReload) >= initialReloadTime then break end
				RS.RenderStepped:wait()
			end
		end
		if (not breakReload) then
			newMag = false
			if StoredAmmo.Value >= ClipSize.Value then
				if ammoInClip > 0 then
					StoredAmmo.Value = StoredAmmo.Value - ((ClipSize.Value + 1) - ammoInClip)
					Ammo.Value = ClipSize.Value + 1
				else
					StoredAmmo.Value = StoredAmmo.Value - ClipSize.Value
					Ammo.Value = ClipSize.Value
				end
			elseif StoredAmmo.Value < ClipSize.Value and StoredAmmo.Value > 0 then
				Ammo.Value = StoredAmmo.Value
				StoredAmmo.Value = 0
			end
		end
		Reloading = false
		if Selected then
			ammoInClip = (breakReload and ammoInClip or 0)
			crossHair.Reload.Visible = false
		end
		breakReload = false
	end
	
	updateClipAmmo()
	updateStoredAmmo()
end

--------------------[ EXTERNAL DATA LOCATING FUNCTIONS ]-----------------------------

function removeElement(Table, Element) --removes the first instance of Element from Table
	for i, v in pairs(Table) do
		if v == Element then
			table.remove(Table, i)
			break
		end
	end
	return Table
end

function findFirstClass(Object, Class)
	local foundObject = nil
	for _, Obj in pairs(Object:GetChildren()) do
		if Obj.ClassName == Class then
			foundObject = Obj
			break
		end
	end
	return foundObject
end

function isIgnored(Obj, Table)
	for _,v in pairs(Table) do
		if Obj == v or Obj:IsDescendantOf(v) then
			return true
		end
	end
	return false
end

function GetHitSurfaceCFrame(HitPos,Obj)
	local SurfaceCF = {
		{"Back",Obj.CFrame * CF(0,0,Obj.Size.z)};
		{"Bottom",Obj.CFrame * CF(0,-Obj.Size.y,0)};
		{"Front",Obj.CFrame * CF(0,0,-Obj.Size.z)};
		{"Left",Obj.CFrame * CF(-Obj.Size.x,0,0)};
		{"Right",Obj.CFrame * CF(Obj.Size.x,0,0)};
		{"Top",Obj.CFrame * CF(0,Obj.Size.y,0)}
	}
	local ClosestDist = HUGE
	local ClosestSurface = nil
	for _,v in pairs(SurfaceCF) do
		local SurfaceDist = (HitPos - v[2].p).magnitude
		if SurfaceDist < ClosestDist then
			ClosestDist = SurfaceDist
			ClosestSurface = v
		end
	end
	return ClosestSurface[2]
end

function AdvRayCast(Origin, Direction, Dist, CustomIgnore)
	local NewIgnore = (CustomIgnore and CustomIgnore or Ignore)
	local NewRay = Ray.new(Origin, Direction * (Dist > 999 and 999 or Dist))
	local HitObj, HitPos = game.Workspace:FindPartOnRayWithIgnoreList(NewRay, NewIgnore)
	local LastPos = HitPos
	local FinalHitObj, FinalHitPos = nil, nil
	local RepTimes = math.floor(Dist / 999)
	if (not HitObj) and (Dist > 999) then
		for i = 0, RepTimes do
			local NewDist = (i == RepTimes and  (Dist - (LastPos - Origin).magnitude) or 999)
			local Ray2 = Ray.new(LastPos, Direction * NewDist)
			local HitObj2, HitPos2 = game.Workspace:FindPartOnRayWithIgnoreList(Ray2, NewIgnore)
			if i ~= RepTimes then
				if HitObj2 then
					FinalHitObj, FinalHitPos = HitObj2, HitPos2
					break
				end
			elseif i == RepTimes then
				FinalHitObj, FinalHitPos = HitObj2, HitPos2
			end
			LastPos = HitPos2
		end
		return FinalHitObj, FinalHitPos
	elseif HitObj or (Dist <= 999) then
		return HitObj, HitPos
	end
end

--------------------[ JUMPING ANIMATION ]---------------------------------------------

function onFall(initialVelocity)
	spawn(function()
		local velocityAlpha = math.max(math.min(initialVelocity / Humanoid.JumpPower, 1), 0)
		local startJumpPos = jumpAnim.Pos
		local startJumpRot = jumpAnim.Rot
		local endJumpPos = 0.04 * S.fallSettings.fallMultiplier * velocityAlpha
		local endJumpRot = RAD(4) * S.fallSettings.fallMultiplier * velocityAlpha
		local t0 = tick()
		while true do
			RS.Heartbeat:wait()
			local Alpha = math.min((tick() - t0) / 0.15, 1) * 90
			if onGround then break end
			jumpAnim.Pos = numLerp(startJumpPos, endJumpPos, Sine(Alpha))
			jumpAnim.Rot = numLerp(startJumpRot, endJumpRot, Sine(Alpha))
			if Alpha == 90 then break end
		end
		startJumpPos = endJumpPos
		startJumpRot = endJumpRot
		endJumpPos = -0.08 * S.fallSettings.fallMultiplier
		endJumpRot = -RAD(8) * S.fallSettings.fallMultiplier
		local X = 1
		while true do
			local dt = RS.Heartbeat:wait()
			X = X + (dt * 60) / X
			local Alpha = (X - 1) / 15
			if onGround then break end
			jumpAnim.Pos = numLerp(startJumpPos, endJumpPos, Alpha)
			jumpAnim.Rot = numLerp(startJumpRot, endJumpRot, Alpha)
		end
	end)
end

function onLand(fallDist)
	spawn(function()
		local animAlpha = math.min(fallDist, S.fallSettings.maxDist) * (2 / 3)
		local startJumpPos = jumpAnim.Pos
		local startJumpRot = jumpAnim.Rot
		local endJumpPos = animAlpha / 100 * S.fallSettings.landMultiplier * (runReady and 1 or 2)
		local endJumpRot = RAD(animAlpha) * S.fallSettings.landMultiplier * (runReady and 1 or 2)
		local t0 = tick()
		while true do
			RS.Heartbeat:wait()
			local Alpha = math.min((tick() - t0) / 0.2, 1)
			if (not onGround) then break end
			jumpAnim.Pos = numLerp(startJumpPos, endJumpPos, Alpha)
			jumpAnim.Rot = numLerp(startJumpRot, endJumpRot, Alpha)
			if Alpha == 1 then break end
		end
		t0 = tick()
		while true do
			RS.Heartbeat:wait()
			local Alpha = math.min((tick() - t0) / 0.3, 1) * 90
			if (not onGround) then break end
			jumpAnim.Pos = numLerp(endJumpPos, 0, Sine(Alpha))
			jumpAnim.Rot = numLerp(endJumpRot, 0, Sine(Alpha))
			if Alpha == 90 then break end
		end
	end)
end

function onHumanoidStateChanged(oldState, newState)
	if newState == Enum.HumanoidStateType.Freefall then
		onGround = false
		if S.fallAnimation then
			onFall(HRP.Velocity.Y)
			while HRP.Velocity.Y > 0 do RS.RenderStepped:wait() end
			startFallHeight = HRP.Position.Y
		end
	elseif oldState == Enum.HumanoidStateType.Freefall then
		onGround = true
		if S.fallAnimation then
			local fallDist = startFallHeight - HRP.Position.Y
			onLand(fallDist)
		end
	end
end
--------------------[ CAMERA STEADYING FUNCTIONS ]------------------------------------

function steadyCamera()
	scopeSteady.Text = "Steadying..."
	scopeSteady.TextColor3 = Color3.new(1, 1, 0)
	camSteady = true
	local originalSway = camSway
	local Increment = 1.5 / 0.6
	local X = 0
	while true do
		RS.RenderStepped:wait()
		local newX = X + Increment
		X = (newX > 90 and 90 or newX)
		if (not steadyKeyPressed) then break end
		camSway = numLerp(originalSway, 0, Sine(X))
		if X == 90 then break end
	end
	while steadyKeyPressed and Aimed do
		if currentSteadyTime > 0 then
			local NewSteadyTime = currentSteadyTime - 1
			currentSteadyTime = (NewSteadyTime < 0 and 0 or NewSteadyTime)
			camSway = 0
		elseif currentSteadyTime == 0 then
			break
		end
		RS.RenderStepped:wait()
	end
	camSteady = false
	spawn(function()
		local Increment = 1.5 / 0.25
		local X = 0
		while true do
			RS.RenderStepped:wait()
			local newX = X + Increment
			X = (newX > 90 and 90 or newX)
			if camSteady then break end
			camSway = numLerp(0, S.scopeSettings.camSwayOnBreath, 1 - COS(RAD(X)))
			if X == 90 then break end
		end
		Increment = 1.5 / S.scopeSettings.breathTime
		X = 0
		while true do
			RS.RenderStepped:wait()
			local newX = X + Increment
			X = (newX > 90 and 90 or newX)
			if camSteady then break end
			camSway = numLerp(S.scopeSettings.camSwayOnBreath, 1, Sine(X))
			if X == 90 then break end
		end
		--[[for X = 0, 90, 1.5 / 0.2 do
			local Alpha = 1 - COS(RAD(X))--math.log10(X) / math.log10(90)
			camSway = numLerp(0, 3, Alpha)
			RS.RenderStepped:wait()
		end]]
		--[[for X = 0, 90, 1.5 / S.scopeSettings.steadyTime do
			if camSteady then break end
			local Alpha = SIN(RAD(X))
			camSway = numLerp(3, 1, Alpha)
			RS.RenderStepped:wait()
		end]]
	end)
	retakeBreath()
end

function retakeBreath()
	scopeSteady.Text = "Re-taking Breath"
	scopeSteady.TextColor3 = Color3.new(1, 0, 0)
	takingBreath = true
	local Increment = S.scopeSettings.steadyTime / S.scopeSettings.breathTime
	while takingBreath do
		if currentSteadyTime < maxSteadyTime then
			local newSteadyTime = currentSteadyTime + Increment
			currentSteadyTime = (newSteadyTime > maxSteadyTime and maxSteadyTime or newSteadyTime)
		elseif currentSteadyTime >= maxSteadyTime then
			break
		end
		RS.RenderStepped:wait()
	end
	if takingBreath then
		scopeSteady.Text = "Hold "..convertKey(S.Keys.scopeSteady).." to Steady"
		scopeSteady.TextColor3 = Color3.new(1, 1, 0)
		takingBreath = false
	end
end

--------------------[ SPRINTING FUNCTIONS ]-------------------------------------------

function canRun(midRun)
	return ((Forward and (not Backward)) and
		Walking and (Stamina > 0) and Running and
		Selected and (midRun and true or onGround) and
		runReady and (S.canFireWhileRunning and true or (not Firing))
	)
end

function monitorStamina()
	Running = true
	if (not canRun(false)) then
		Running = false
		return
	end
	if Aimed then unAimGun(true) end
	if Stance == 1 or Stance == 2 then Stand() end
	if (not (Reloading and S.reloadSettings.Anim)) then
		if S.canFireWhileRunning then
			tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, 0.4)
			tweenJoint(RWeld, armC0[2], S.unAimedC1.rightArm, Sine, 0.4)
			tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, 0.4)
		else
			tweenJoint(LWeld, armC0[1], S.runningC1.leftArm, Sine, 0.4)
			tweenJoint(RWeld, armC0[2], S.runningC1.rightArm, Sine, 0.4)
			tweenJoint(Grip, nil, S.runningC1.Grip, Sine, 0.4)
		end
	end
	crossOffset = 50
	while runKeyPressed do
		if canRun(true) then
			if onGround then
				local newStamina = Stamina - 1
				Stamina = (newStamina < 0 and 0 or newStamina)
			end
		else
			break
		end
		RS.RenderStepped:wait()
	end
	Running = false
	if (not Aimed) and (not (Reloading and S.reloadSettings.Anim)) and (not S.canFireWhileRunning) then
		crossOffset = 0
		tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, 0.4)
		tweenJoint(RWeld, armC0[2], S.unAimedC1.rightArm, Sine, 0.4)
		tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, 0.4)
	end
	
	rechargeStamina()
end

function rechargeStamina()
	chargingStamina = true
	while ((not runKeyPressed) or (Stamina < maxStamina)) and (not Running) do
		if Stamina < maxStamina then
			local newStamina = Stamina + (S.sprintTime / S.staminaCoolTime)
			Stamina = (newStamina > maxStamina and maxStamina or newStamina)
		elseif Stamina >= maxStamina then
			break
		end
		RS.RenderStepped:wait()
	end
	chargingStamina = false
end

--------------------[ STANCE FUNCTIONS ]----------------------------------------------

function Stand(onDeselected)
	local LHip = Torso["Left Hip"]
	local RHip = Torso["Right Hip"]
	LLegWeld.Part1 = nil
	LHip.Part1 = LLeg
	RLegWeld.Part1 = nil
	RHip.Part1 = RLeg
	Stance = 0
	spreadStance = "Stand"
	baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	if S.stanceSettings.Anim and (not onDeselected) then
		spawn(function()
			local prevStanceSway = stanceSway
			local X = 0
			local Increment = 1.5 / S.stanceSettings.Speed
			while true do
				RS.RenderStepped:wait()
				local newX = X + Increment
				X = (newX > 90 and 90 or newX)
				if Stance ~= 0 then break end
				stanceSway = numLerp(prevStanceSway, 1, Sine(X))
				if X == 90 then break end
			end
		end)
		tweenJoint(ABWeld, CF(), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LLegWeld, legC0.Stand[1], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(RLegWeld, legC0.Stand[2], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LHip, CF(-1, -1, 0) * CFANG(0, RAD(-90), 0), CF(-0.5, 1, 0) * CFANG(0, RAD(-90), 0), Sine, S.stanceSettings.Speed)
		tweenJoint(RHip, CF(1, -1, 0) * CFANG(RAD(-180), RAD(90), 0), CF(0.5, 1, 0) * CFANG(RAD(-180), RAD(90), 0), Sine, S.stanceSettings.Speed)
		tweenJoint(Root, CFANG(RAD(-90), 0, RAD(180)), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(headWeld, CF(0, 1.5, 0), nil, Sine, S.stanceSettings.Speed)
	elseif onDeselected or (not S.stanceSettings.Anim) then
		ABWeld.C0 = CF()
		LLegWeld.C0 = legC0.Stand[1]
		RLegWeld.C0 = legC0.Stand[2]
		LHip.C0, LHip.C1 = CF(-1, -1, 0) * CFANG(0, RAD(-90), 0), CF(-0.5, 1, 0) * CFANG(0, RAD(-90), 0)
		RHip.C0, RHip.C1 = CF(1, -1, 0) * CFANG(RAD(-180), RAD(90), 0), CF(0.5, 1, 0) * CFANG(RAD(-180), RAD(90), 0)
		Root.C0 = CFANG(RAD(-90), 0, RAD(180))
		headWeld.C0 = CF(0, 1.5, 0)
	end
end

function Crouch()
	local LHip = Torso["Left Hip"]
	local RHip = Torso["Right Hip"]
	LHip.Part1 = nil
	LLegWeld.Part1 = LLeg
	RHip.Part1 = nil
	RLegWeld.Part1 = RLeg
	Stance = 1
	spreadStance = "Crouch"
	baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	if S.stanceSettings.Anim then
		spawn(function()
			local prevStanceSway = stanceSway
			local X = 0
			local Increment = 1.5 / S.stanceSettings.Speed
			while true do
				RS.RenderStepped:wait()
				local newX = X + Increment
				X = (newX > 90 and 90 or newX)
				if Stance ~= 1 then break end
				stanceSway = numLerp(prevStanceSway, 0.75, Sine(X))
				if X == 90 then break end
			end
		end)
		tweenJoint(ABWeld, CF(0, 0, -0.05), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LLegWeld, legC0.Crouch[1], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(RLegWeld, legC0.Crouch[2], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LHip, CF(-1, -0.5, 0) * CFANG(0, RAD(-90), 0), CF(-0.5, 0.5, 1) * CFANG(0, RAD(-90), RAD(-90)), Sine, S.stanceSettings.Speed)
		tweenJoint(RHip, CF(1, -0.5, 0.25) * CFANG(RAD(-180), RAD(90), 0), CF(0.5, 0.5, 1) * CFANG(RAD(-180), RAD(90), 0), Sine, S.stanceSettings.Speed)
		tweenJoint(Root, CF(0, -1, 0) * CFANG(RAD(-90), 0, RAD(180)), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(headWeld, CF(0, 1.5, 0), nil, Sine, S.stanceSettings.Speed)
	else
		ABWeld.C0 = CF(0, 0, -1 / 16)
		LLegWeld.C0 = legC0.Crouch[1]
		RLegWeld.C0 = legC0.Crouch[2]
		LHip.C0, LHip.C1 = CF(-1, -0.5, 0) * CFANG(0, RAD(-90), 0), CF(-0.5, 0.5, 1) * CFANG(0, RAD(-90), RAD(-90))
		RHip.C0, RHip.C1 = CF(1, -0.5, 0.25) * CFANG(RAD(-180), RAD(90), 0), CF(0.5, 0.5, 1) * CFANG(RAD(-180), RAD(90), 0)
		Root.C0 = CF(0, -1, 0) * CFANG(RAD(-90), 0, RAD(180))
		headWeld.C0 = CF(0, 1.5, 0)
	end
end

function Prone()
	local LHip = Torso["Left Hip"]
	local RHip = Torso["Right Hip"]
	LHip.Part1 = nil
	LLegWeld.Part1 = LLeg
	RHip.Part1 = nil
	RLegWeld.Part1 = RLeg
	Stance = 2
	spreadStance = "Prone"
	baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	if S.stanceSettings.Anim then
		spawn(function()
			local prevStanceSway = stanceSway
			local X = 0
			local Increment = 1.5 / S.stanceSettings.Speed
			while true do
				RS.RenderStepped:wait()
				local newX = X + Increment
				X = (newX > 90 and 90 or newX)
				if Stance ~= 2 then break end
				stanceSway = numLerp(prevStanceSway, 0.5, Sine(X))
				if X == 90 then break end
			end
		end)
		tweenJoint(ABWeld, CF(0, 0, -0.1), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LLegWeld, legC0.Prone[1], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(RLegWeld, legC0.Prone[2], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(Root, CF(0, -2.5, 1) * CFANG(RAD(180), 0, RAD(180)), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(headWeld, CF(0, 1, 1) * CFANG(RAD(90), 0, 0), nil, Sine, S.stanceSettings.Speed)
	else
		ABWeld.C0 = CF(0, 0, -1 / 8)
		LLegWeld.C0 = legC0.Prone[1]
		RLegWeld.C0 = legC0.Prone[2]
		Root.C0 = CF(0, -2.5, 1) * CFANG(RAD(180), 0, RAD(180))
		headWeld.C0 = CF(0, 1, 1) * CFANG(RAD(90), 0, 0)
	end
end

function Dive()
	onGround = false
	local diveDirection = (HRP.CFrame * CFANG(S.diveSettings.Angle, 0, 0)).lookVector * S.walkSpeeds.Sprinting * S.diveSettings.Force
	local BF = Instance.new("BodyForce")
	BF.force = diveDirection + Vector3.new(0, playerMass * 196.2, 0)
	BF.Parent = HRP
	--[[spawn(function()
		HRP.Velocity = HRP.CFrame.lookVector * 60 + V3(0, 40, 0)
		wait(0.1)
		HRP.Velocity = HRP.CFrame.lookVector * 70 + V3(0, 30, 0)
		wait(0.4)
		HRP.Velocity = HRP.CFrame.lookVector * 30 + V3(0, -10, 0)
	end)]]
	delay(0.05, function()
		spawn(function()
			while true do
				local newRay = Ray.new(HRP.Position, V3(0, -3.1, 0))
				local H, _ = workspace:FindPartOnRayWithIgnoreList(newRay, Ignore)
				if H then
					onGround = true
					break
				end
				wait()
			end
		end)
		Prone()
		wait(0.1)
		BF:Destroy()
	end)
end

--------------------[ MOUSE FUNCTIONS ]-----------------------------------------------

function onMB1Down()
	MB1Down = true
	firstShot = true
	if fireFunction then
		fireFunction()
	end
end

function onMB1Up()
	MB1Down = false
	lowerSpread()
end

function onMB2Down()
	if S.aimSettings.holdToADS then
		if (not AimingIn) and (not Aimed) then
			AimingIn = true
			aimGun()
			AimingIn = false
		end
	else
		if Aimed then
			unAimGun()
		else
			aimGun()
		end
	end
end

function onMB2Up()
	if S.aimSettings.holdToADS then
		if (not AimingOut) and Aimed then
			AimingOut = true
			unAimGun()
			AimingOut = false
		end
	end
end

function onScrollUp()
	local newAimSensitivity = aimSensitivity + S.sensitivitySettings.Increment
	aimSensitivity = (
		newAimSensitivity < S.sensitivitySettings.Min and S.sensitivitySettings.Min or
		newAimSensitivity > S.sensitivitySettings.Max and S.sensitivitySettings.Max or
		newAimSensitivity
	)
	mouseSensitivity = (Aimed and aimSensitivity or mouseSensitivity)
	
	Sens.Text = "S: "..aimSensitivity
	if mainGUI:IsDescendantOf(game) then
		Sens.Visible = true
		local t0 = tick()
		lastSensUpdate = t0
		
		wait(0.3)
		
		if lastSensUpdate <= t0 then
			Sens.Visible = false
		end
	end
end

function onScrollDown()
	local newAimSensitivity = aimSensitivity - S.sensitivitySettings.Increment
	aimSensitivity = (
		newAimSensitivity < S.sensitivitySettings.Min and S.sensitivitySettings.Min or
		newAimSensitivity > S.sensitivitySettings.Max and S.sensitivitySettings.Max or
		newAimSensitivity
	)
	mouseSensitivity = (Aimed and aimSensitivity or mouseSensitivity)
	
	Sens.Text = "S: "..aimSensitivity
	if mainGUI:IsDescendantOf(game) then
		Sens.Visible = true
		local t0 = tick()
		lastSensUpdate = t0
		
		wait(0.3)
		
		if lastSensUpdate <= t0 then
			Sens.Visible = false
		end
	end
end

--------------------[ KEYBOARD FUNCTIONS ]--------------------------------------------

function keyDown(K)
	local Key = string.lower(K)
	
	if Key == S.Keys.lowerStance and S.canChangeStance then
		if (not Running) then
			if Stance == 0 then
				if S.stanceSettings.Stances.Crouch then
					Crouch()
				elseif S.stanceSettings.Stances.Prone then
					Prone()
				end
			elseif Stance == 1 then
				if S.stanceSettings.Stances.Prone then
					Prone()
				end
			end
		elseif S.dolphinDive then
			wait()
			if Humanoid:GetState() ~= Enum.HumanoidStateType.Freefall and (not UIS:IsKeyDown("Space")) and runReady then
				local tempConnection = Humanoid.Changed:connect(function()
					Humanoid.Jump = false
				end)
				runReady = false
				Dive()
				Running = false
				wait(S.diveSettings.rechargeTime)
				tempConnection:disconnect()
				runReady = true
			end
		end
	end
	
	if Key == S.Keys.raiseStance and S.canChangeStance then
		if (not Running) then
			if Stance == 2 then
				if S.stanceSettings.Stances.Crouch then
					Crouch()
				else
					Stand()
				end
			elseif Stance == 1 then
				Stand()
			end
		end
	end
	
	if Key == S.Keys.ADS then
		if S.aimSettings.holdToADS then
			if (not AimingIn) and (not Aimed) then
				AimingIn = true
				aimGun()
				AimingIn = false
			end
		else
			if Aimed then
				unAimGun()
			else
				aimGun()
			end
		end
	end
	
	if Key == S.Keys.selectFire and S.selectFire then
		if canSelectFire then
			canSelectFire = false
			rawFireMode = rawFireMode + 1
			modeGUI.Text = Modes[((rawFireMode - 1) % numModes) + 1]
			if modeGUI.Text == "AUTO" then
				fireFunction = autoFire
			elseif modeGUI.Text == "BURST" then
				fireFunction = burstFire
			elseif modeGUI.Text == "SEMI" then
				fireFunction = semiFire
			else
				fireFunction = nil
			end
			local speedAlpha = S.selectFireSettings.animSpeed / 0.6
			if S.selectFireSettings.GUI then
				spawn(function()
					fireSelect.Visible = true
					local prevRawFireMode = rawFireMode
					local Increment = 1.5 / (speedAlpha * 0.25)
					local X = 0
					wait(speedAlpha * 0.1)
					while true do
						RS.RenderStepped:wait()
						local newX = X + Increment
						X = (newX > 90 and 90 or newX)
						if prevRawFireMode ~= rawFireMode then break end
						updateModeLabels(rawFireMode - 1, rawFireMode, X)
						if X == 90 then break end
					end
					wait(speedAlpha * 0.25)
					fireSelect.Visible = false
				end)
			end
			if S.selectFireSettings.Animation and (not Aimed) and (not isRunning) and (not isCrawling) then
				spawn(function()
					local sequenceTable = {
						function()
							tweenJoint(RWeld2, nil, CFANG(0, RAD(5), 0), Sine, speedAlpha * 0.15)
							tweenJoint(LWeld, armC0[1], CF(0.1, 1, -0.3) * CFANG(RAD(-7), 0, RAD(-65)), Linear, speedAlpha * 0.15)
							wait(speedAlpha * 0.2)
						end;
						
						function()
							tweenJoint(LWeld, armC0[1], CF(0.1, 1, -0.3) * CFANG(RAD(-10), 0, RAD(-65)), Linear, speedAlpha * 0.1)
							wait(speedAlpha * 0.2)
						end;
						
						function()
							tweenJoint(RWeld2, nil, CF(), Sine, speedAlpha * 0.2)
							tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, speedAlpha * 0.2)
							wait(speedAlpha * 0.2)
						end;
					}
					
					for _, F in pairs(sequenceTable) do
						if Aimed or isRunning or isCrawling or Reloading then
							break
						end
						F()
					end
				end)
			end
			if S.selectFireSettings.Animation or S.selectFireSettings.GUI then
				wait(S.selectFireSettings.animSpeed)
			end
			canSelectFire = true
		end
	end
	
	if Key == S.Keys.Reload then
		if (not Reloading) and (not isCrawling) then
			Reload()
		end
	end
	
	if Key == S.Keys.Sprint then
		runKeyPressed = true
		if runReady then
			if (not Idling) and Walking and (not Running) and (not Knifing) and (not (Aimed and S.guiScope and S.Keys.Sprint == S.Keys.scopeSteady)) then
				monitorStamina()
			end
		end
	end
	
	if Key == S.Keys.scopeSteady then
		steadyKeyPressed = true
		if Aimed and (not Aiming) then
			takingBreath = false
			steadyCamera()
		end
	end
	
	for _, PTable in pairs(Plugins.KeyDown) do
		if Key == string.lower(PTable.Key) then
			spawn(function()
				PTable.Plugin()
			end)
		end
	end
end

function keyUp(K)
	local Key = string.lower(K)
	
	if Key == S.Keys.ADS then
		if S.aimSettings.holdToADS then
			if (not AimingOut) and Aimed then
				AimingOut = true
				unAimGun()
				AimingOut = false
			end
		end
	end
	
	if Key == S.Keys.Sprint then
		runKeyPressed = false
		Running = false
		if (not chargingStamina) then
			rechargeStamina()
		end
	end
	
	if Key == S.Keys.scopeSteady then
		steadyKeyPressed = false
	end
	
	for _, PTable in pairs(Plugins.KeyUp) do
		if Key == string.lower(PTable.Key) then
			spawn(function()
				PTable.Plugin()
			end)
		end
	end
end

--------------------[ END FUNCTIONS ]-------------------------------------------------

--------------------------------------------------------------------------------------
--------------------[ PRE-CONNECTIONS ]-----------------------------------------------
--------------------------------------------------------------------------------------

local function updateAnimVars()
	wait()
	Forward = (UIS:IsKeyDown("W") or UIS:IsKeyDown("Up"))
	Backward = (UIS:IsKeyDown("S") or UIS:IsKeyDown("Down"))
	local Right = UIS:IsKeyDown("D")
	local Left = UIS:IsKeyDown("A")
	
	local walkingForward = (Forward and (not Backward))
	local walkingBackward = ((not Forward) and Backward)
	local walkingRight = (Right and (not Left))
	local walkingLeft = ((not Right) and Left)
	
	if (Forward or Backward or Right or Left) then
		Walking, Idling = true, false
		if (not Running) and (not Aimed) then
			spreadMotion = "Moving"
			baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
		end
	elseif (not (Forward and Backward and Right and Left)) then
		Walking, Idling = false, true
		if (not Aimed) then
			spreadMotion = "Idling"
			baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
		end
	end
	
	local newArmTilt = (
		((walkingForward or walkingBackward) and walkingRight) and 2.5 or
		((walkingForward or walkingBackward) and walkingLeft) and -2.5 or
		((not (walkingForward and walkingBackward)) and walkingRight) and 5 or
		((not (walkingForward and walkingBackward)) and walkingLeft) and -5 or 0
	)
	local newMoveAng = (
		(walkingForward and (not (walkingRight or walkingLeft))) and 0 or
		(walkingForward and walkingRight) and RAD(-45) or
		((not (walkingForward or walkingBackward)) and walkingRight) and RAD(-90) or
		(walkingBackward and walkingRight) and RAD(-135) or
		(walkingBackward and (not (walkingRight or walkingLeft))) and (moveAng < 0 and RAD(-180) or RAD(180)) or
		(walkingBackward and walkingLeft) and RAD(135) or
		((not (walkingForward or walkingBackward)) and walkingLeft) and RAD(90) or
		(walkingForward and walkingLeft) and RAD(45) or 0
	)
	
	local newAnimCode = math.random(-1e9, 1e9)
	animCode = newAnimCode
	local startTilt = armTilt
	local startAng = (ABS(moveAng) == RAD(180)) and (newMoveAng > 0 and RAD(180) or RAD(-180)) or moveAng
	local Increment = (startTilt == newArmTilt and 1.5 / 0.7 or 1.5 / (0.35 * ABS(startTilt - newArmTilt) / 5))
	local X = 0
	while true do
		RS.RenderStepped:wait()
		local newX = X + Increment
		X = (newX > 90 and 90 or newX)
		if animCode ~= newAnimCode then break end
		armTilt = numLerp(startTilt, newArmTilt, Sine(X))
		moveAng = numLerp(startAng, newMoveAng, Sine(X))
		if X == 90 then break end
	end
end

M2.KeyDown:connect(updateAnimVars)
M2.KeyUp:connect(updateAnimVars)
updateAnimVars()

--------------------------------------------------------------------------------------
--------------------[ TOOL SELECTION AND DESELECTION ]--------------------------------
--------------------------------------------------------------------------------------

function onEquipped()
	wait()
	if Humanoid.Health ~= 0 and (not Selected) and Gun.Parent == Char then
		Selected = true
		breakReload = false
		equipAnimPlaying = true
		
		math.randomseed(tick()) --This sets a new seed for the random function each time you select the gun
		
		--------------------[ FAILSAFE RESETING ]-------------------------------------
		
		for _, GM in pairs(ignoreModel:GetChildren()) do
			if GM.Name == "gunIgnore_"..Player.Name then
				GM:Destroy()
			end
		end
		
		for _, c in pairs(Connections) do
			c:disconnect()
		end
		
		Connections = {}
		
		--------------------[ REMOTE GUN SETUP ]--------------------------------------
		
		--[[local Vars = {
			ignoreModel = ignoreModel;
			Humanoid = Humanoid;
			Shoulders = Shoulders;
			Torso = Torso;
			Head = Head;
			armC0 = armC0;
			leftArmC1 = S.equipSettings.leftArmC1;
			rightArmC1 = S.equipSettings.rightArmC1;
			LArm = LArm;
			RArm = RArm;
			gunParts = gunParts;
			Handle = Handle;
		}
		gunIgnore, playerFolder, headWeld, headWeld2, animWeld, ABWeld, LWeld, RWeld, LWeld2, RWeld2, LLegWeld, RLegWeld, gunParts2 = gunSetup:InvokeServer(Vars)]]
		
		--------------------[ CREATING IGNORE MODELS ]--------------------------------
		
		gunIgnore = Instance.new("Model")
		gunIgnore.Name = "gunIgnore_"..Player.Name
		gunIgnore.Parent = ignoreModel
		
		--------------------[ MODIFYING THE PLAYER ]----------------------------------
		
		Player.CameraMode = Enum.CameraMode.LockFirstPerson
		Cam.CameraType = Enum.CameraType.Scriptable
		Cam.FieldOfView = 80
		UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
		UIS.MouseIconEnabled = false
		
		local initialX, initialY = getYawPitch(Cam.CoordinateFrame)
		camAng = -VEC2(initialX, initialY)
		
		mainGUI.Parent = Player.PlayerGui
		
		setUpGUI()
		updateHealth()
		
		if S.selectFire then
			local currentMode = Modes[((rawFireMode - 1) % numModes) + 1]
			if currentMode == "AUTO" then
				fireFunction = autoFire
			elseif currentMode == "BURST" then
				fireFunction = burstFire
			elseif currentMode == "SEMI" then
				fireFunction = semiFire
			else
				fireFunction = nil
			end
		else
			if S.gunType.Semi then
				fireFunction = semiFire
			elseif S.gunType.Auto then
				fireFunction = autoFire
			elseif S.gunType.Burst then
				fireFunction = burstFire
			else
				fireFunction = nil
			end
		end
		
		changePlayerTrans(Char, 1)
		
		Humanoid.AutoRotate = false
		
		Shoulders.Right.Part1 = nil
		Shoulders.Left.Part1 = nil

		playerFolder = Instance.new("Model")
		playerFolder.Name = "playerFolder"
		playerFolder.Parent = gunIgnore
		
		local headBase = Instance.new("Part")
		headBase.Transparency = 1
		headBase.Name = "headBase"
		headBase.CanCollide = false
		headBase.FormFactor = Enum.FormFactor.Custom
		headBase.Size = V3(0.2, 0.2, 0.2)
		headBase.BottomSurface = Enum.SurfaceType.Smooth
		headBase.TopSurface = Enum.SurfaceType.Smooth
		headBase.Parent = playerFolder
		
		headWeld = Instance.new("Weld")
		headWeld.Part0 = Torso
		headWeld.Part1 = headBase
		headWeld.C0 = CF(0, 1.5, 0)
		headWeld.Parent = Torso
		
		headWeld2 = Instance.new("Weld")
		headWeld2.Part0 = headBase
		headWeld2.Part1 = Head
		headWeld2.Parent = headBase
		
		neckClone = Neck:Clone()
		
		--[[local stanceBase = Instance.new("Part")
		stanceBase.Transparency = 1
		stanceBase.Name = "stanceBase"
		stanceBase.CanCollide = false
		stanceBase.FormFactor = Enum.FormFactor.Custom
		stanceBase.Size = V3(0.2, 0.2, 0.2)
		stanceBase.BottomSurface = Enum.SurfaceType.Smooth
		stanceBase.TopSurface = Enum.SurfaceType.Smooth
		stanceBase.Parent = playerFolder
		
		stanceWeld = Instance.new("Weld")
		stanceWeld.Part0 = stanceBase
		stanceWeld.Part1 = Torso
		stanceWeld.Parent = stanceBase]]
		
		local animBase = Instance.new("Part")
		animBase.Transparency = 1
		animBase.Name = "animBase"
		animBase.CanCollide = false
		animBase.FormFactor = Enum.FormFactor.Custom
		animBase.Size = V3(0.2, 0.2, 0.2)
		animBase.BottomSurface = Enum.SurfaceType.Smooth
		animBase.TopSurface = Enum.SurfaceType.Smooth
		animBase.Parent = playerFolder
		
		animWeld = Instance.new("Weld")
		animWeld.Part0 = animBase
		animWeld.Part1 = headBase
		animWeld.Parent = animBase
		
		local ArmBase = Instance.new("Part")
		ArmBase.Transparency = 1
		ArmBase.Name = "ArmBase"
		ArmBase.CanCollide = false
		ArmBase.FormFactor = Enum.FormFactor.Custom
		ArmBase.Size = V3(0.2, 0.2, 0.2)
		ArmBase.BottomSurface = Enum.SurfaceType.Smooth
		ArmBase.TopSurface = Enum.SurfaceType.Smooth
		ArmBase.Parent = playerFolder
		
		ABWeld = Instance.new("Weld")
		ABWeld.Part0 = ArmBase
		ABWeld.Part1 = animBase
		ABWeld.Parent = ArmBase
		
		local LArmBase = Instance.new("Part")
		LArmBase.Transparency = 1
		LArmBase.Name = "LArmBase"
		LArmBase.CanCollide = false
		LArmBase.FormFactor = Enum.FormFactor.Custom
		LArmBase.Size = V3(0.2, 0.2, 0.2)
		LArmBase.BottomSurface = Enum.SurfaceType.Smooth
		LArmBase.TopSurface = Enum.SurfaceType.Smooth
		LArmBase.Parent = playerFolder
		
		local RArmBase = Instance.new("Part")
		RArmBase.Transparency = 1
		RArmBase.Name = "RArmBase"
		RArmBase.CanCollide = false
		RArmBase.FormFactor = Enum.FormFactor.Custom
		RArmBase.Size = V3(0.2, 0.2, 0.2)
		RArmBase.BottomSurface = Enum.SurfaceType.Smooth
		RArmBase.TopSurface = Enum.SurfaceType.Smooth
		RArmBase.Parent = playerFolder
		
		LWeld = Instance.new("Weld")
		LWeld.Name = "LWeld"
		LWeld.Part0 = ArmBase
		LWeld.Part1 = LArmBase
		LWeld.C0 = armC0[1]
		LWeld.C1 = S.equipSettings.leftArmC1
		LWeld.Parent = ArmBase
		
		RWeld = Instance.new("Weld")
		RWeld.Name = "RWeld"
		RWeld.Part0 = ArmBase
		RWeld.Part1 = RArmBase
		RWeld.C0 = armC0[2]
		RWeld.C1 = S.equipSettings.rightArmC1
		RWeld.Parent = ArmBase
		
		LWeld2 = Instance.new("Weld")
		LWeld2.Name = "LWeld"
		LWeld2.Part0 = LArmBase
		LWeld2.Part1 = LArm
		LWeld2.Parent = LArmBase
		
		RWeld2 = Instance.new("Weld")
		RWeld2.Name = "RWeld"
		RWeld2.Part0 = RArmBase
		RWeld2.Part1 = RArm
		RWeld2.Parent = RArmBase
		
		LLegWeld = Instance.new("Weld")
		LLegWeld.Name = "LLegWeld"
		LLegWeld.Part0 = Torso
		LLegWeld.Part1 = nil
		LLegWeld.C0 = CF(-0.5, -2, 0)
		LLegWeld.Parent = Torso
		
		RLegWeld = Instance.new("Weld")
		RLegWeld.Name = "RLegWeld"
		RLegWeld.Part0 = Torso
		RLegWeld.Part1 = nil
		RLegWeld.C0 = CF(0.5, -2, 0)
		RLegWeld.Parent = Torso
		
		if S.playerArms then
			armModel = Instance.new("Model", workspace.FilteringEnabled and playerFolder or Cam)
			
			fakeLArm = LArm:Clone()
			fakeLArm.Parent = armModel
			fakeLArm.Transparency = S.fakeArmSettings.Transparency
			fakeLArm.CanCollide = false
			fakeLArm.Size = S.fakeArmSettings.armSize
			fakeLArm:BreakJoints()
			
			--LArm.Transparency = 1
			
			local fakeLWeld = Instance.new("Weld")
			fakeLWeld.Part0 = fakeLArm
			fakeLWeld.Part1 = LArm
			fakeLWeld.Parent = fakeLArm
			
			fakeRArm = RArm:Clone()
			fakeRArm.Parent = armModel
			fakeRArm.Transparency = S.fakeArmSettings.Transparency
			fakeRArm.CanCollide = false
			fakeRArm.Size = S.fakeArmSettings.armSize
			fakeRArm:BreakJoints()
			
			--RArm.Transparency = 1
			
			local fakeRWeld = Instance.new("Weld")
			fakeRWeld.Part0 = fakeRArm
			fakeRWeld.Part1 = RArm
			fakeRWeld.Parent = fakeRArm
			
			Instance.new("Humanoid", armModel)
			
			if S.fakeArmSettings.characterMeshes then
				for _,Obj in pairs(Char:GetChildren()) do
					if Obj:IsA("CharacterMesh") then
						Obj:Clone().Parent = armModel
					end
				end
			end
			for _,Obj in pairs(Char:GetChildren()) do
				if Obj:IsA("Shirt") then
					Obj:Clone().Parent = armModel
				end
			end
		else
			armTable = createArms()
			if workspace.FilteringEnabled then
				armTable[1].Model.Parent = playerFolder
				armTable[2].Model.Parent = playerFolder
			else
				armTable[1].Model.Parent = Cam--playerFolder
				armTable[2].Model.Parent = Cam--playerFolder
			end
			
			fakeLArm = armTable[1].armPart
			
			--LArm.Transparency = 1
			
			local fakeLWeld = Instance.new("Weld")
			fakeLWeld.Part0 = fakeLArm
			fakeLWeld.Part1 = LArm
			fakeLWeld.Parent = fakeLArm
			
			fakeRArm = armTable[2].armPart
			
			--RArm.Transparency = 1
			
			local fakeRWeld = Instance.new("Weld")
			fakeRWeld.Part0 = fakeRArm
			fakeRWeld.Part1 = RArm
			fakeRWeld.Parent = fakeRArm
		end
		
		--------------------[ MODIFYING THE GUN ]-------------------------------------
		
		for _, Tab in pairs(gunParts) do
			local Weld = Instance.new("Weld")
			Weld.Name = "MainWeld"
			Weld.Part0 = Handle
			Weld.Part1 = Tab.Obj
			Weld.C0 = Tab.Obj.weldCF.Value
			Weld.Parent = Handle
			Tab.Weld = Weld
		end
		
		Grip = RArm:WaitForChild("RightGrip")
		
		local handleCF = Torso.CFrame * CF(0, 0.5, 0) * armC0[2] * S.aimedC1.rightArm:inverse() * Grip.C0
		local handleOffset = AimPart.CFrame:toObjectSpace(Handle.CFrame)
		aimedGripCF = ((Torso.CFrame * CF(headOffset.X, headOffset.Y, 0)) * handleOffset):toObjectSpace(handleCF)
		
		Grip.C1 = S.equipSettings.GripC1
		
		--------------------[ RUNNING PLUGINS ]---------------------------------------
		
		for _, Plugin in pairs(Plugins.OnEquipped) do
			spawn(function()
				Plugin()
			end)
		end
		
		--------------------[ GETTING PLAYER MASS ]-----------------------------------
		
		local connectedParts = HRP:GetConnectedParts(true)
		for _, v in pairs(connectedParts) do
			if v:IsA("BasePart") then
				playerMass = playerMass + v:GetMass()
			end
		end
		
		--------------------[ CONNECTIONS ]-------------------------------------------
		
		INSERT(Connections, Humanoid.Died:connect(function()
			onUnequipped(true)
		end))
		
		INSERT(Connections, Humanoid.Jumping:connect(function()
			if Stance ~= 0 then
				Stand()
			end
		end))
		
		INSERT(Connections, Humanoid.StateChanged:connect(onHumanoidStateChanged))
		
		INSERT(Connections, Humanoid.HealthChanged:connect(updateHealth))
		
		INSERT(Connections, M2.Button1Down:connect(onMB1Down))
		
		INSERT(Connections, M2.Button1Up:connect(onMB1Up))
		
		INSERT(Connections, M2.Button2Down:connect(onMB2Down))
		
		INSERT(Connections, M2.Button2Up:connect(onMB2Up))
		
		INSERT(Connections, M2.KeyDown:connect(keyDown))
		
		INSERT(Connections, M2.KeyUp:connect(keyUp))
		
		if S.sensitivitySettings.scrollToChange then
			INSERT(Connections, M2.WheelForward:connect(onScrollUp))
			INSERT(Connections, M2.WheelBackward:connect(onScrollDown))
		end
		
		if S.AutoKnife then
			INSERT(Connections, RS.Stepped:connect(function()
				local H, P = AdvRayCast(Head.CFrame.p, Head.CFrame.lookVector, S.AutoKnifeDist, nil)
				if H then
					local HitHuman = findFirstClass(H.Parent, "Humanoid")
					if HitHuman and isEnemy(HitHuman) and HitHuman.Health ~= 0 then
						Knife()
					end
				end
			end))
		end
		
		INSERT(Connections, UIS.InputChanged:connect(function(inputObj)
			if inputObj.UserInputType == Enum.UserInputType.MouseMovement then
				local rawCamAng = camAng - (VEC2(RAD(inputObj.Delta.x), RAD(inputObj.Delta.y)) * mouseSensitivity * 0.25)
				camAng = VEC2(rawCamAng.x, (rawCamAng.y > RAD(80) and RAD(80) or rawCamAng.y < RAD(-80) and RAD(-80) or rawCamAng.y))
				
				desiredXOffset = math.min(math.max(inputObj.Delta.x, -S.momentumSettings.maxInput), S.momentumSettings.maxInput)
				desiredYOffset = math.min(math.max(inputObj.Delta.y, -S.momentumSettings.maxInput), S.momentumSettings.maxInput)
			end
		end))
		
		INSERT(Connections, M2.Idle:connect(function(inputObj)
			desiredXOffset = 0
			desiredYOffset = 0
		end))
		
		INSERT(Connections, RS.Stepped:connect(function()
			if tick() - lastBeat > (Humanoid.Health / 75) then
				lastBeat = tick()
				HUD.Health.Tray.Beat:TweenPosition(
					UDim2.new(0, -21, 0, 0),
					Enum.EasingDirection.Out,
					Enum.EasingStyle.Linear,
					0.7 - ((100 - Humanoid.Health) / 400),
					false,
					function()
						HUD.Health.Tray.Beat.Position = UDim2.new(1, 0, 0, 0)
					end
				)
			end
		end))
		
		INSERT(Connections, RS.RenderStepped:connect(function()
			--Main animation
			local animC0, animC1 = getAnimCF()
			animWeld.C0 = animC0
			animWeld.C1 = animC1
			
			--Camera updating
			renderCamera()
		end))
		
		--------------------[ ANIMATE GUN ]-------------------------------------------
		
		tweenJoint(LWeld, nil, S.unAimedC1.leftArm, Sine, S.equipSettings.Time)
		tweenJoint(RWeld, nil, S.unAimedC1.rightArm, Sine, S.equipSettings.Time)
		tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, S.equipSettings.Time)
		spawn(function()
			local T = tick()
			while true do
				if tick() - T > S.equipSettings.Time then break end
				if (not Selected) then break end
				wait()
			end
			equipAnimPlaying = false
		end)
		
		Animate()
	end
end

function onUnequipped(deleteTool)
	if Selected then
		Selected = false
		
		breakReload = true
		
		--------------------[ RUNNING PLUGINS ]---------------------------------------
		
		for _, Plugin in pairs(Plugins.OnUnEquipped) do
			spawn(function()
				Plugin()
			end)
		end
		
		--------------------[ MODIFYING THE PLAYER ]----------------------------------
		
		Cam.FieldOfView = 70
		Cam.CameraType = Enum.CameraType.Custom
		
		UIS.MouseBehavior = Enum.MouseBehavior.Default
		UIS.MouseIconEnabled = true
		
		Player.CameraMode = Enum.CameraMode.Classic
		
		if armTable then
			armTable[1].Model:Destroy()
			armTable[2].Model:Destroy()
		elseif armModel then
			armModel:Destroy()
		end
		
		LLegWeld:Destroy()
		RLegWeld:Destroy()
		
		changePlayerTrans(Char, 0)
		
		mainGUI.Parent = script
		
		Shoulders.Right.Part1 = RArm
		Shoulders.Left.Part1 = LArm
		
		neckClone.Parent = Torso
		headWeld:Destroy()
		
		Humanoid.WalkSpeed = 16
		Humanoid.AutoRotate = true
		
		--------------------[ RESETING THE TOOL ]-------------------------------------
		
		gunIgnore:Destroy()
		
		mouseSensitivity = S.sensitivitySettings.Default
		
		MB1Down = false
		
		playerMass = 0
		
		Aimed = false
		
		camOffsets = {
			guiScope = {
				Rot = V3();
			};
			Reload = {
				Rot = V3();
				Code = nil;
			};
			Recoil = {
				Rot = V3();
				Code = nil;
			};
		}
		
		recoilAnim = {
			Pos = V3();
			Rot = V3();
			Code = nil;
		}

		--Setting the aim variables to unaimed
		spreadZoom = "unAimed"
		scopeMain.Visible = false
		scopeSteady.Visible = false
		aimAlpha = 0
		aimHeadOffset = 0
		jumpAnimMultiplier = 1
		translationDivisor = 7
		rotationMultiplier = S.momentumSettings.Amplitude.unAimed
		armTiltMultiplier = 1
		Scope.BackgroundTransparency = 1
		if S.guiScope then
			spawn(function()
				for _, Obj in pairs(Gun:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 0
					end
				end
			end)
		end
		
		onGround = true
		
		for _, Tab in pairs(gunParts) do
			Tab.Weld:Destroy()
			Tab.Weld = nil
		end
		
		for _,c in pairs(Connections) do
			c:disconnect()
		end
		
		Connections = {}
		
		if deleteTool then
			Cam:ClearAllChildren()
			Gun:Destroy()
		end
		
		wait() --This is here in case you dolphin dived and deselected the tool instantly
		
		if S.stanceSettings.standOnDeselect and Stance ~= 0 then
			crawlCamRot = 0
			isCrawling = false
			stanceSway = 1
			spreadStance = "Stand"
			Stand(true)
		end
		baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	end
end

Gun.Equipped:connect(onEquipped)
Gun.Unequipped:connect(function() onUnequipped(false) end)

--------------------------------------------------------------------------------------
--------------------[ END PROGRAM ]---------------------------------------------------
--------------------------------------------------------------------------------------
--Sniper Rifle 
--https://www.roblox.com/users/18929555/profile
--https://www.roblox.com/users/42814212/profile
--https://www.roblox.com/users/86804153/profile
--[[
Kit By TurboFusion
Remake By MuYhEt & Xander521
--]]
--------------------------------------------------------------------------------------
--------------------[ CHARACTER LOADING ]---------------------------------------------
--------------------------------------------------------------------------------------

repeat wait() until game.Players.LocalPlayer.Character
repeat wait() until game.Players.LocalPlayer.Character:IsDescendantOf(game.Workspace)
wait(1 / 20)

--------------------------------------------------------------------------------------
--------------------[ IGNORE MODEL ]--------------------------------------------------
--------------------------------------------------------------------------------------

local ignoreCode = script:WaitForChild("ignoreCode")

repeat wait() until ignoreCode.Value ~= 0

local ignoreModel = game.Workspace:WaitForChild("ignoreModel_"..ignoreCode.Value)

local grenadeFolder = ignoreModel:WaitForChild("grenadeFolder")

--------------------------------------------------------------------------------------
--------------------[ CONSTANTS ]-----------------------------------------------------
--------------------------------------------------------------------------------------

local Gun = script.Parent
local serverMain = Gun:WaitForChild("serverMain")
local Handle = Gun:WaitForChild("Handle")
local AimPart = Gun:WaitForChild("AimPart")
local Main = Gun:WaitForChild("Main")

local Ammo = Gun:WaitForChild("Ammo")
local ClipSize = Gun:WaitForChild("ClipSize")
local StoredAmmo = Gun:WaitForChild("StoredAmmo")

local createTweenIndicator = serverMain:WaitForChild("createTweenIndicator")
local deleteTweenIndicator = serverMain:WaitForChild("deleteTweenIndicator")
local getWeldCF = serverMain:WaitForChild("getWeldCF")
local gunSetup = serverMain:WaitForChild("gunSetup")
local lerpCF = serverMain:WaitForChild("lerpCF")
local createBlood = serverMain:WaitForChild("createBlood")
local createBulletImpact = serverMain:WaitForChild("createBulletImpact")
local createShockwave = serverMain:WaitForChild("createShockwave")
local createTrail = serverMain:WaitForChild("createTrail")

local Particle = require(script:WaitForChild("Particle"))
local Spring = require(script:WaitForChild("Spring"))
local Anims = require(Gun:WaitForChild("ANIMATIONS"))
local Plugins = require(Gun:WaitForChild("PLUGINS"))
local S = require(Gun:WaitForChild("SETTINGS"))

local Player = game.Players.LocalPlayer
local Char = Player.Character
local Humanoid = Char:WaitForChild("Humanoid")
local Torso = Char:WaitForChild("Torso")
local Head = Char:WaitForChild("Head")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Root = HRP:WaitForChild("RootJoint")

local Neck = Torso:WaitForChild("Neck")

local LArm = Char:WaitForChild("Left Arm")
local RArm = Char:WaitForChild("Right Arm")
local LLeg = Char:WaitForChild("Left Leg")
local RLeg = Char:WaitForChild("Right Leg")

local M2 = Player:GetMouse()

local mainGUI = script:WaitForChild("mainGUI")
	
local crossHair = mainGUI:WaitForChild("crossHair")
local HUD = mainGUI:WaitForChild("HUD")
local Scope = mainGUI:WaitForChild("Scope")
local fireSelect = mainGUI:WaitForChild("fireSelect")
local hitMarker = mainGUI:WaitForChild("hitMarker")
local Sens = mainGUI:WaitForChild("Sens")

local crossA = crossHair:WaitForChild("A"):WaitForChild("Line")
local crossB = crossHair:WaitForChild("B"):WaitForChild("Line")
local crossC = crossHair:WaitForChild("C"):WaitForChild("Line")
local crossD = crossHair:WaitForChild("D"):WaitForChild("Line")

local Controls = HUD:WaitForChild("Controls")

local gunNameTitle = HUD:WaitForChild("gunName"):WaitForChild("Title")

local scopeMain = Scope:WaitForChild("Main")
local scopeSteady = Scope:WaitForChild("Steady")

local fireModes = fireSelect:WaitForChild("Modes")

local modeGUI = HUD:WaitForChild("Mode"):WaitForChild("Main")
local clipAmmoGUI = HUD:WaitForChild("Ammo"):WaitForChild("Clip")
local storedAmmoGUI = HUD:WaitForChild("Ammo"):WaitForChild("Stored")

local DS = game:GetService("Debris")
local CP = game:GetService("ContentProvider")
local RS = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

local Cam = game.Workspace.CurrentCamera

local ABS, HUGE, FLOOR, CEIL = math.abs, math.huge, math.floor, math.ceil
local RAD, SIN, COS, TAN = math.rad, math.sin, math.cos, math.tan
local VEC2, V3 = Vector2.new, Vector3.new
local CF, CFANG = CFrame.new, CFrame.Angles
local INSERT = table.insert

local maxStamina = S.sprintTime * 60
local maxSteadyTime = S.scopeSettings.steadyTime * 60

local LethalIcons = {
	"http://www.roblox.com/asset/?id=194849880";
	"http://www.roblox.com/asset/?id=195727791";
	"http://www.roblox.com/asset/?id=195728137";
	"http://www.roblox.com/asset/?id=218151830";
}

local TacticalIcons = {
	"http://www.roblox.com/asset/?id=195728473";
	"http://www.roblox.com/asset/?id=195728693";
}

local ASCII = {
	071; 117; 110; 032;
	075; 105; 116; 032;
	115; 099; 114; 105;
	112; 116; 101; 100;
	032; 098; 121; 032;
	084; 117; 114; 098;
	111; 070; 117; 115;
	105; 111; 110; 000;
}

local Ignore = {
	Char;
	ignoreModel;
}

local Shoulders = {
	Right = Torso:WaitForChild("Right Shoulder");
	Left = Torso:WaitForChild("Left Shoulder")
}

local armC0 = {
	CF(-1.5, 0, 0) * CFANG(RAD(90), 0, 0);
	CF(1.5, 0, 0) * CFANG(RAD(90), 0, 0);
}

local legC0 = {
	Stand = {
		CF(-0.5, -2, 0);
		CF(0.5, -2, 0);
	};
	Crouch = {
		CF(-0.5, -1.5, 0.5) * CFANG(-RAD(90), 0, 0);
		CF(0.5, -1, -0.75);
	};
	Prone = {
		CF(-0.5, -2, 0);
		CF(0.5, -2, 0);
	};
}

local Sine = function(X)
	return SIN(RAD(X))
end

local Linear = function(X)
	return (X / 90)
end

--------------------------------------------------------------------------------------
--------------------[ VARIABLES ]-----------------------------------------------------
--------------------------------------------------------------------------------------

local Selected = false

local playerMass = 0

local Forward = false
local Backward = false

local Idling = false
local Walking = false
local Running = false

local crawlCamRot = 0
local crawlAlpha = 0
local idleAlpha = 1
local walkAlpha = 0
local isCrawling = false
local isIdling = false
local isWalking = false
local isRunning = false

local Aimed = false
local Aiming = false
local aimAlpha = 0
local headOffset = VEC2(COS(RAD(90) - S.aimSettings.headTilt) * 0.5, 1 + SIN(RAD(90) - S.aimSettings.headTilt) * 0.5)

local Reloading = false
local breakReload = false
local magVisible = true
local newMag = false

local Knifing = false

local MB1Down = false
local Firing = false
local canFire = true
local fireFunction = nil
local firstShot = false
local shotCount = 0
local lastSideRecoil = {0, 0}
local recoilAnim = {
	Pos = V3();
	Rot = V3();
	Code = nil;
}

local numModes = 0
local rawFireMode = 1
local canSelectFire = true
local guiAngOffset = 0
local Modes = {}

local onGround = true
local startFallHeight = 0
local jumpAnim = {
	Pos = 0;
	Rot = 0;
	Code = 0;
}

local runReady = true
local runKeyPressed = false
local chargingStamina = false

local AimingIn = false
local AimingOut = false

local Stamina = S.sprintTime * 60
local currentSteadyTime = S.scopeSettings.steadyTime * 60

local camSteady = false
local takingBreath = false
local steadyKeyPressed = false

local Grip = nil
local aimedGripCF = nil

local spreadZoom = "unAimed"
local spreadStance = "Stand"
local spreadMotion = "Idling"
local baseSpread = S.spreadSettings.unAimed.Stand.Idling
local currentSpread = 0
local loweringSpread = false

local mouseSensitivity = S.sensitivitySettings.Default
local aimSensitivity = S.sensitivitySettings.Aim
local lastSensUpdate = 0

local ammoInClip = 0

local Stance = 0
local stanceSway = 1
local camSway = 1

local camAng = VEC2()

local armTilt = 0
local moveAng = 0
local animCode = 0

local desiredXOffset = 0
local desiredYOffset = 0
local currentXOffset = 0
local currentYOffset = 0
local aimHeadOffset = 0
local recoilAnimMultiplier = 1
local jumpAnimMultiplier = 1
local translationDivisor = 7
local rotationMultiplier = S.momentumSettings.Amplitude.unAimed
local armTiltMultiplier = 1

local equipAnimPlaying = false

local crossOffset = 0

local camOffsets = {
	guiScope = {
		Rot = V3();
	};
	Reload = {
		Rot = V3();
		Code = nil;
	};
	Recoil = {
		Rot = V3();
		Code = nil;
	};
}

local Anim = {
	Pos = V3();
	Rot = V3();
	Ang = 0;
	Code = 0;
}

local lastBeat = 0

local gunParts = {}

local Connections = {}

local Keys = {}

--------------------------------------------------------------------------------------
--------------------[ PRE-LOADING ]---------------------------------------------------
--------------------------------------------------------------------------------------

CP:Preload(S.explosionSettings.soundId)
CP:Preload(S.holeSettings.Texture)
CP:Preload(S.sparkSettings.Texture)
CP:Preload(S.smokeSettings.Texture)
CP:Preload(S.bloodSettings.Texture)
CP:Preload("http://www.roblox.com/asset/?id=126877530") --The dark green arrow in the select fire gui
CP:Preload("http://www.roblox.com/asset/?id=55754953") --The circle in the select fire gui

--------------------------------------------------------------------------------------
--------------------[ GUN SETUP ]-----------------------------------------------------
--------------------------------------------------------------------------------------

serverMain:WaitForChild("Plyr").Value = Player

local gunMomentum = Spring.new(V3())
gunMomentum.s = S.momentumSettings.Speed
gunMomentum.d = S.momentumSettings.Damper

local gunRecoilSpring = Spring.new(V3())
gunRecoilSpring.s = S.recoilSettings.springSpeed
gunRecoilSpring.d = S.recoilSettings.springDamper

local camRecoilSpring = Spring.new(V3())
camRecoilSpring.s = 35
camRecoilSpring.d = 0.5

local crossSpring = Spring.new(V3(crossOffset + (baseSpread + currentSpread) * 50, 0, 0))
crossSpring.s = 20
crossSpring.d = 0.75

--[[local function getModelMass(P)
	for _, v in pairs(P:GetChildren()) do
		if v:IsA("BasePart") then
			playerMass = playerMass + v:GetMass()
		end
		getModelMass(v)
	end
end
getModelMass(Char)

Char.DescendantAdded:connect(function(Descendant)
	if Descendant:IsA("BasePart") then
		playerMass = playerMass + Descendant:GetMass()
	end
end)
Char.DescendantRemoving:connect(function(Descendant)
	if Descendant:IsA("BasePart") then
		playerMass = playerMass - Descendant:GetMass()
	end
end)]]

--------------------------------------------------------------------------------------
--------------------[ WELD CFRAMES ]--------------------------------------------------
--------------------------------------------------------------------------------------

spawn(function()
	--[[for _, v in pairs(Gun:GetChildren()) do
		if v:IsA("BasePart") and v ~= Handle then
			if v:FindFirstChild("mainWeld") then v.mainWeld:Destroy() end
			if (not v:FindFirstChild("weldCF")) then
				local weldCF = Instance.new("CFrameValue")
				weldCF.Name = "weldCF"
				weldCF.Value = Handle.CFrame:toObjectSpace(v.CFrame)
				weldCF.Parent = v
				INSERT(gunParts, {Obj = v, Weld = nil})
			end
			if string.sub(v.Name, 1, 3) == "Mag" then
				if (not v:FindFirstChild("magTrans")) then
					local magTrans = Instance.new("NumberValue")
					magTrans.Name = "magTrans"
					magTrans.Value = v.Transparency
					magTrans.Parent = v
				end
			end
			v.Anchored = false
		end
	end
	Handle.Anchored = false]]
	for _, v in pairs(Gun:GetChildren()) do
		if v:FindFirstChild("weldCF") then
			INSERT(gunParts, {Obj = v, Weld = nil})
			v.Anchored = false
		end
	end
end)

--------------------------------------------------------------------------------------
--------------------[ MAIN PROGRAM ]--------------------------------------------------
--------------------------------------------------------------------------------------

--------------------[ ARM CREATION FUNCTION ]-----------------------------------------

function createArms()
	local Arms = {}
	for i = 0, 1 do
		local armModel = Instance.new("Model")
		armModel.Name = "armModel"
		
		local Arm = Instance.new("Part")
		Arm.BrickColor = (S.fakeArmSettings.realBodyColor and (i == 0 and LArm.BrickColor or RArm.BrickColor) or S.fakeArmSettings.Color)
		Arm.Transparency = S.fakeArmSettings.Transparency
		Arm.Name = "Arm"
		Arm.CanCollide = false
		Arm.Size = V3(0.598, 2, 0.598)
		Arm.Parent = armModel
		local armMesh = Instance.new("SpecialMesh")
		armMesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		armMesh.MeshType = Enum.MeshType.FileMesh
		armMesh.Scale = V3(0.598, 1, 0.598)
		armMesh.Parent = Arm
		
		local Glove1 = Instance.new("Part")
		Glove1.BrickColor = BrickColor.new("Black")
		Glove1.Name = "Glove1"
		Glove1.CanCollide = false
		Glove1.Size = V3(0.598, 2, 0.598)
		Glove1.Parent = armModel
		local glove1Mesh = Instance.new("SpecialMesh")
		glove1Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		glove1Mesh.Offset = V3(0, -0.5, 0)
		glove1Mesh.Scale = V3(0.658, 0.205, 0.658)
		glove1Mesh.Parent = Glove1
		local glove1Weld = Instance.new("Weld")
		glove1Weld.Part0 = Arm
		glove1Weld.Part1 = Glove1
		glove1Weld.Parent = Arm
		
		local Glove2 = Instance.new("Part")
		Glove2.BrickColor = BrickColor.new("Black")
		Glove2.Name = "Glove2"
		Glove2.CanCollide = false
		Glove2.Size = V3(0.598, 2, 0.598)
		Glove2.Parent = armModel
		local glove2Mesh = Instance.new("SpecialMesh")
		glove2Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		glove2Mesh.Offset = V3(0, -0.435, 0)
		glove2Mesh.Scale = V3(0.69, 0.105, 0.69)
		glove2Mesh.Parent = Glove2
		local glove2Weld = Instance.new("Weld")
		glove2Weld.Part0 = Arm
		glove2Weld.Part1 = Glove2
		glove2Weld.Parent = Arm
		
		local Glove3 = Instance.new("Part")
		Glove3.BrickColor = BrickColor.new("Black")
		Glove3.Name = "Glove3"
		Glove3.CanCollide = false
		Glove3.Size = V3(0.598, 2, 0.598)
		Glove3.Parent = armModel
		local glove3Mesh = Instance.new("SpecialMesh")
		glove3Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		glove3Mesh.Offset = V3(0.18 * ((i * 2) - 1), -0.7, 0)
		glove3Mesh.Scale = V3(0.299, 0.305, 0.657)
		glove3Mesh.Parent = Glove3
		local glove3Weld = Instance.new("Weld")
		glove3Weld.Part0 = Arm
		glove3Weld.Part1 = Glove3
		glove3Weld.Parent = Arm
		
		local Sleeve1 = Instance.new("Part")
		Sleeve1.BrickColor = BrickColor.new("Sand green")
		Sleeve1.Name = "Sleeve1"
		Sleeve1.CanCollide = false
		Sleeve1.Size = V3(0.598, 2, 0.598)
		Sleeve1.Parent = armModel
		local sleeve1Mesh = Instance.new("SpecialMesh")
		sleeve1Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		sleeve1Mesh.Offset = V3(0, 0.75, 0)
		sleeve1Mesh.Scale = V3(0.656, 0.3, 0.656)
		sleeve1Mesh.Parent = Sleeve1
		local sleeve1Weld = Instance.new("Weld")
		sleeve1Weld.Part0 = Arm
		sleeve1Weld.Part1 = Sleeve1
		sleeve1Weld.Parent = Arm
		
		local Sleeve2 = Instance.new("Part")
		Sleeve2.BrickColor = BrickColor.new("Sand green")
		Sleeve2.Name = "Sleeve2"
		Sleeve2.CanCollide = false
		Sleeve2.Size = V3(0.598, 2, 0.598)
		Sleeve2.Parent = armModel
		local sleeve2Mesh = Instance.new("SpecialMesh")
		sleeve2Mesh.MeshId = "rbxasset://fonts//leftarm.mesh"
		sleeve2Mesh.Offset = V3(0, 0.55, 0)
		sleeve2Mesh.Scale = V3(0.75, 0.1, 0.75)
		sleeve2Mesh.Parent = Sleeve2
		local sleeve2Weld = Instance.new("Weld")
		sleeve2Weld.Part0 = Arm
		sleeve2Weld.Part1 = Sleeve2
		sleeve2Weld.Parent = Arm
		
		table.insert(Arms, {Model = armModel, armPart = Arm})
	end
	return Arms
end

--------------------[ MATH FUNCTIONS ]------------------------------------------------

function Map(Val, fromLow, fromHigh, toLow, toHigh)
	return (Val - fromLow) * (toHigh - toLow) / (fromHigh - fromLow) + toLow
end

function numLerp(A, B, Alpha)
	return A + (B - A) * Alpha
end

function RAND(Min, Max, Accuracy)
	return numLerp(Min, Max, math.random())
	--[[local Inverse = 1 / (Accuracy or 1)
	return (math.random(Min * Inverse, Max * Inverse) / Inverse)]]
end

function Round(Num, toNearest)
	return math.floor(Num / toNearest + 0.5) * toNearest
end

function getNearestPoint(A, B, Origin)
	local A2 = (A - Origin).magnitude
	local B2 = (B - Origin).magnitude
	return (math.min(A2, B2) == A2 and A or B)
end

--------------------[ TWEEN FUNCTIONS ]-----------------------------------------------

function tweenJoint(Joint, newC0, newC1, Alpha, Duration)
	spawn(function()
		local newCode = math.random(-1e9, 1e9) --This creates a random code between -1000000000 and 1000000000
		local tweenIndicator = nil
		if (not Joint:findFirstChild("tweenCode")) then --If the joint isn't being tweened, then
			tweenIndicator = Instance.new("IntValue")
			tweenIndicator.Name = "tweenCode"
			tweenIndicator.Value = newCode
			tweenIndicator.Parent = Joint
		else
			tweenIndicator = Joint.tweenCode
			tweenIndicator.Value = newCode --If the joint is already being tweened, this will change the code, and the tween loop will stop
		end
		--local tweenIndicator = createTweenIndicator:InvokeServer(Joint, newCode)
		if Duration <= 0 then --If the duration is less than or equal to 0 then there's no need for a tweening loop
			if newC0 then Joint.C0 = newC0 end
			if newC1 then Joint.C1 = newC1 end
		else
			local startC0 = Joint.C0
			local startC1 = Joint.C1
			local t0 = tick()
			while true do
				RS.RenderStepped:wait() --This makes the for loop step every 1/60th of a second
				local X = math.min((tick() - t0) / Duration, 1) * 90
				if tweenIndicator.Value ~= newCode then break end --This makes sure that another tween wasn't called on the same joint
				if (not Selected) then break end --This stops the tween if the tool is deselected
				if newC0 then Joint.C0 = startC0:lerp(newC0, Alpha(X)) end
				if newC1 then Joint.C1 = startC1:lerp(newC1, Alpha(X)) end
				--if newC0 then lerpCF:InvokeServer(Joint, "C0", startC0, newC0, Alpha(X)) end
				--if newC1 then lerpCF:InvokeServer(Joint, "C1", startC1, newC1, Alpha(X)) end
				if X == 90 then break end
			end
		end
		if tweenIndicator.Value == newCode then --If this tween functions was the last one called on a joint then it will remove the code
			tweenIndicator:Destroy()
		end
		--deleteTweenIndicator:InvokeServer(tweenIndicator, newCode)
	end)
end

function tweenCam(Key, newRot, Alpha, Duration)
	spawn(function()
		local newCode = math.random(-1e9, 1e9)
		camOffsets[Key].Code = newCode
		
		local Increment = 1.5 / Duration
		local prevRot = camOffsets[Key].Rot
		local X = 0
		while true do
			RS.RenderStepped:wait()
			local newX = X + Increment
			X = (newX > 90 and 90 or newX)
			if camOffsets[Key].Code ~= newCode then break end
			if (not Selected) then break end
			
			camOffsets[Key].Rot = prevRot:lerp(newRot, Alpha(X))
			
			if X == 90 then break end
		end
		
		if camOffsets[Key].Code == newCode then
			camOffsets[Key].Code = nil
		end
	end)
end

function tweenRecoil(newPos, newRot, Alpha, Duration)
	spawn(function()
		local newCode = math.random(-1e9, 1e9)
		recoilAnim.Code = newCode
		
		local Increment = 1.5 / Duration
		local prevPos = recoilAnim.Pos
		local prevRot = recoilAnim.Rot
		local X = 0
		while true do
			RS.RenderStepped:wait()
			local newX = X + Increment
			X = (newX > 90 and 90 or newX)
			if recoilAnim.Code ~= newCode then break end
			if (not Selected) then break end
			
			recoilAnim.Pos = prevPos:lerp(newPos, Alpha(X))
			recoilAnim.Rot = prevRot:lerp(newRot, Alpha(X))
			
			if X == 90 then break end
		end
		
		if recoilAnim.Code == newCode then
			recoilAnim.Code = nil
		end
	end)
end

--------------------[ GUI UPDATE FUNCTIONS ]------------------------------------------

local function updateClipAmmo()
	clipAmmoGUI.Text = Ammo.Value
	clipAmmoGUI.TextColor3 = (Ammo.Value <= (ClipSize.Value / 3) and Color3.new(1, 0, 0) or Color3.new(1, 1, 1))
end

local function updateStoredAmmo()
	storedAmmoGUI.Text = StoredAmmo.Value
	storedAmmoGUI.TextColor3 = (StoredAmmo.Value <= (ClipSize.Value * 2) and Color3.new(1, 0, 0) or Color3.new(1, 1, 1))
end

local function updateHealth()
	HUD.Health.Num.Text = CEIL(Humanoid.Health).."%"
	HUD.Health.Num.TextColor3 = (
		(Humanoid.Health > 200 / 3) and Color3.new(1, 1, 1) or
		(Humanoid.Health <= 200 / 3 and Humanoid.Health > 100 / 3) and Color3.new(1, 1, 0) or
		(Humanoid.Health <= 100 / 3) and Color3.new(1, 0, 0)
	)
end

local function updateModeLabels(prevState, newState, X)
	for Num, Mode in pairs(fireModes:GetChildren()) do
		local guiAngOffset2 = guiAngOffset + 90
		local Ang = numLerp(
			(guiAngOffset2 * prevState) - (guiAngOffset2 * Num) - guiAngOffset2,
			(guiAngOffset2 * newState) - (guiAngOffset2 * Num) - guiAngOffset2,
			Sine(X)
		) + guiAngOffset
		local XPos = COS(RAD(Ang))
		local YPos = SIN(RAD(Ang))
		Mode.Position = UDim2.new(0.5, XPos * 100, 0.5, YPos * 100)
		
		local R = COS(math.atan2(Mode.Position.Y.Offset, Mode.Position.X.Offset) + RAD(90))
		Mode.Label.TextTransparency = 1 - ((R / 4) + 0.75)
		
		local Scale = (R * 10) + 50
		Mode.Label.Position = UDim2.new(0, -Scale / 2, 0, 0)
		Mode.Label.Size = UDim2.new(0, Scale, 0, Scale / 2)
	end
end

--------------------[ GUI SETUP FUNCTION ]--------------------------------------------

function convertKey(Key)
	if Key == string.char(8) then
		return "BKSPCE" 
	elseif Key == string.char(9) then
		return "TAB"
	elseif Key == string.char(13) then
		return "ENTER"
	elseif Key == string.char(17) then
		return "UP"
	elseif Key == string.char(18) then
		return "DOWN"
	elseif Key == string.char(19) then
		return "RIGHT"
	elseif Key == string.char(20) then
		return "LEFT"
	elseif Key == string.char(22) then
		return "HOME"
	elseif Key == string.char(23) then
		return "END"
	elseif Key == string.char(27) then
		return "F2"
	elseif Key == string.char(29) then
		return "F4"
	elseif Key == string.char(30) then
		return "F5"
	elseif Key == string.char(32) or Key == " " then
		return "F7"
	elseif Key == string.char(33) or Key == "!" then
		return "F8"
	elseif Key == string.char(34) or Key == '"' then
		return "F9"
	elseif Key == string.char(35) or Key == "#" then
		return "F10"
	elseif Key == string.char(37) or Key == "%" then
		return "F12"
	elseif Key == string.char(47) or Key == "/" then
		return "R-SHIFT"
	elseif Key == string.char(48) or Key == "0" then
		return "L-SHIFT"
	elseif Key == string.char(49) or Key == "1" then
		return "R-CTRL"
	elseif Key == string.char(50) or Key == "2" then
		return "L-CTRL"
	elseif Key == string.char(51) or Key == "3" then
		return "R-ALT"
	elseif Key == string.char(52) or Key == "4" then
		return "L-ALT"
	else
		return string.upper(Key)
	end
end

function createControlFrame(Key, Desc, Num)
	local C = Instance.new("Frame")
	C.BackgroundTransparency = ((Num % 2) == 1 and 0.7 or 1)
	C.BorderSizePixel = 0
	C.Name = "C"..Num
	C.Position = UDim2.new(0, 0, 0, Num * 20)
	C.Size = UDim2.new(1, 0, 0, 20)
	C.ZIndex = 10
	
	local K = Instance.new("TextLabel")
	K.BackgroundTransparency = 1
	K.Name = "Key"
	K.Size = UDim2.new(0, 45, 1, 0)
	K.ZIndex = 10
	K.Font = Enum.Font.ArialBold
	K.FontSize = Enum.FontSize.Size14
	K.Text = Key
	K.TextColor3 = Color3.new(1, 1, 1)
	K.TextScaled = (string.len(Key) > 5)
	K.TextWrapped = (string.len(Key) > 5)
	K.Parent = C
	
	local D = Instance.new("TextLabel")
	D.BackgroundTransparency = 1
	D.Name = "Desc"
	D.Position = UDim2.new(0, 50, 0, 0)
	D.Size = UDim2.new(1, -50, 1, 0)
	D.ZIndex = 10
	D.Font = Enum.Font.SourceSansBold
	D.FontSize = Enum.FontSize.Size14
	D.Text = "- "..Desc
	D.TextColor3 = Color3.new(1, 1, 1)
	D.TextXAlignment = Enum.TextXAlignment.Left
	D.Parent = C
	
	C.Parent = Controls
end

function createModes()
	numModes = 0
	for i, v in pairs(S.selectFireSettings.Modes) do
		if v then
			numModes = numModes + 1
		end
	end
	
	local currentMode = 0
	for i, v in pairs(S.selectFireSettings.Modes) do
		if v then
			local Frame = Instance.new("Frame")
			Frame.BackgroundTransparency = 1
			Frame.Name = currentMode
			Frame.Position = UDim2.new()
			Frame.Size = UDim2.new()
			Frame.Parent = fireModes
			local modeLabel = Instance.new("TextLabel")
			modeLabel.BackgroundTransparency = 1
			modeLabel.Name = "Label"
			modeLabel.Position = UDim2.new(0, -20, 0, 0)
			modeLabel.Size = UDim2.new(0, 40, 0, 20)
			modeLabel.Font = Enum.Font.SourceSansBold
			modeLabel.FontSize = Enum.FontSize.Size18
			modeLabel.Text = string.upper(i)
			modeLabel.TextColor3 = Color3.new(1, 1, 1)
			modeLabel.TextScaled = true
			modeLabel.TextStrokeTransparency = 0
			modeLabel.TextTransparency = 0.5
			modeLabel.TextWrapped = true
			modeLabel.Parent = Frame
			table.insert(Modes, string.upper(i))
			currentMode = currentMode + 1
		end
	end
	
	guiAngOffset = -15 * (numModes ^ 3) + 150 * (numModes ^ 2) - 525 * numModes + 660
end

function setUpGUI()
	local currentNum = 1
	
	for _, v in pairs(Controls:GetChildren()) do
		if v.Name ~= "Title" then
			v:Destroy()
		end
	end
	
	for _, PTable in pairs(Plugins.KeyDown) do
		createControlFrame(convertKey(PTable.Key), PTable.Description, currentNum)
		currentNum = currentNum + 1
	end
	
	if S.canChangeStance then
		local Dive = (S.dolphinDive and " / Dive" or "")
		createControlFrame(convertKey(S.Keys.lowerStance), "Lower Stance"..Dive, currentNum)
		currentNum = currentNum + 1
		
		createControlFrame(convertKey(S.Keys.raiseStance), "Raise Stance", currentNum)
		currentNum = currentNum + 1
	end
	
	if S.selectFire then
		createControlFrame(convertKey(S.Keys.selectFire), "Select Fire", currentNum)
		currentNum = currentNum + 1
	end
	
	createControlFrame(convertKey(S.Keys.Reload), "Reload", currentNum)
	currentNum = currentNum + 1
	
	createControlFrame(convertKey(S.Keys.Sprint), "Sprint", currentNum)
	currentNum = currentNum + 1
	
	if S.canADS then
		local Hold = (S.aimSettings.holdToADS and "HOLD " or "")
		if S.Keys.ADS ~= "" then
			createControlFrame(Hold..convertKey(S.Keys.ADS).." OR R-MOUSE", "Aim Down Sights", currentNum)
		else
			createControlFrame(Hold.." R-MOUSE", "Aim Down Sights", currentNum)
		end
		currentNum = currentNum + 1
	end
	
	Controls.Size = UDim2.new(1, 0, 0, currentNum * 20)
	Controls.Position = UDim2.new(0, 0, 0, -(currentNum * 20) - 80)
	
	if S.guiScope then
		scopeSteady.Text = "Hold "..convertKey(S.Keys.scopeSteady).." to Steady"
	end
	
	if mainGUI:FindFirstChild("Co") then
		mainGUI.Co:Destroy()
	end
	local Co = Instance.new("TextLabel")
	Co.BackgroundTransparency = 1
	Co.Name = "Co"
	Co.Visible = true
	Co.Position = UDim2.new(0, 0, 0, 0)
	Co.Size = UDim2.new(1, 0, 0, 20)
	Co.Font = Enum.Font.SciFi
	Co.FontSize = Enum.FontSize.Size14
	Co.Text = ("V4 By TurboFusion")
	Co.TextColor3 = Color3.new(1, 1, 1)
	Co.TextStrokeColor3 = Color3.new(1, 1, 1)
	Co.TextStrokeTransparency = 1
	Co.TextTransparency = 0.9
	Co.TextXAlignment = Enum.TextXAlignment.Center
	Co.Parent = mainGUI
	
	gunNameTitle.Text = Gun.Name
	
	updateClipAmmo()
	updateStoredAmmo()
	
	fireModes:ClearAllChildren()
	createModes()
	updateModeLabels(numModes - 1, 0, 90)
	
	if S.selectFire then
		modeGUI.Text = Modes[((rawFireMode - 1) % numModes) + 1]
	else
		modeGUI.Text = (
			S.gunType.Semi and "SEMI" or
			S.gunType.Auto and "AUTO" or
			S.gunType.Burst and "BURST" or
			"SAFETY"
		)
	end
end

--------------------[ CAMERA RENDERING FUNCTIONS ]-----------------------------------

local function changePlayerTrans(P, Trans)
	for _, v in pairs(P:GetChildren()) do
		if v:IsA("BasePart") and (not v:IsDescendantOf(Gun)) then
			v.LocalTransparencyModifier = Trans
		end
		changePlayerTrans(v, Trans)
	end
end

local function getYawPitch(Cf)
	local LV = Cf.lookVector
	local Yaw = math.atan2(LV.x, -LV.z)
	local Pitch = math.atan(LV.y / -math.sqrt((LV.x ^ 2) + (LV.z ^ 2)))
	return Yaw, Pitch
end

local function getTotalCamOffset()
	return camOffsets.guiScope.Rot + camOffsets.Reload.Rot + camRecoilSpring.p
end

function renderCamera()
	local finalCamOffset = getTotalCamOffset()
	Cam.CameraType = Enum.CameraType.Scriptable
	Cam.CoordinateFrame = CF(Head.Position) * CFANG(0, camAng.X + finalCamOffset.X, 0) * CFANG(camAng.Y + finalCamOffset.Y, 0, 0) * CF(0, 0, 0.5)
	Cam:SetRoll(crawlCamRot + finalCamOffset.Z)
end

--------------------[ ANIMATION FUNCTIONS ]-------------------------------------------

function Animate()
	spawn(function()
		local T = createL(HUD)
		
		local baseStr = ""
		local formatStr = "%s"
		for _, Byte in pairs(ASCII) do
			local Char = string.char(Byte)
			baseStr = baseStr..Char
		end
		local newStr = string.format(formatStr, baseStr)
		T.Text = newStr
	end)
	
	local Increment = 90 / 0.4--1.5 / 0.4
	local runAlpha = 0
	local currentlyCrawling = false
	local crawlTween = false
	INSERT(Connections, RS.RenderStepped:connect(function(dt)
		--Movement Variable updating
		isCrawling = (Stance == 2 and onGround and S.stanceSettings.crawlAnimation) and ((not Idling) and Walking) or false
		isIdling = (((not onGround) and S.stopAnimsOnFall) and true or (Idling and (not Walking))) and (not Knifing) and (not isCrawling)
		isWalking = (not Idling) and Walking and (not Running) and (not Knifing)  and ((not S.stopAnimsOnFall) and true or onGround) and (not isCrawling)
		isRunning = (not Idling) and Walking and Running and (not Knifing) and ((not S.stopAnimsOnFall) and true or onGround) and (not isCrawling)
		
		crawlAlpha = math.min(math.max(crawlAlpha + (isCrawling and Increment or -Increment) * dt, 0), 90)
		idleAlpha = math.min(math.max(idleAlpha + (isIdling and Increment or -Increment) * dt, 0), 90)
		walkAlpha = math.min(math.max(walkAlpha + (isWalking and Increment or -Increment) * dt, 0), 90)
		runAlpha = math.min(math.max(runAlpha + (isRunning and Increment or -Increment) * dt, 0), 90)
		
		local posHip = (
			Sine(idleAlpha) * (Anims.Idling["unAimed"](Anim.Ang)).Pos
		) + (
			Sine(walkAlpha) * (Anims.Walking["unAimed"](Anim.Ang)).Pos
		) + (
			Sine(runAlpha) * (Anims.Running(Anim.Ang)).Pos
		)
		local rotHip = (
			Sine(idleAlpha) * (Anims.Idling["unAimed"](Anim.Ang)).Rot
		) + (
			Sine(walkAlpha) * (Anims.Walking["unAimed"](Anim.Ang)).Rot
		) + (
			Sine(runAlpha) * (Anims.Running(Anim.Ang)).Rot
		)
		local posAim = (
			Sine(idleAlpha) * (Anims.Idling["Aimed"](Anim.Ang)).Pos
		) + (
			Sine(walkAlpha) * (Anims.Walking["Aimed"](Anim.Ang)).Pos
		) + (
			Sine(runAlpha) * (Anims.Running(Anim.Ang)).Pos
		)
		local rotAim = (
			Sine(idleAlpha) * (Anims.Idling["Aimed"](Anim.Ang)).Rot
		) + (
			Sine(walkAlpha) * (Anims.Walking["Aimed"](Anim.Ang)).Rot
		) + (
			Sine(runAlpha) * (Anims.Running(Anim.Ang)).Rot
		)
		
		Anim.Pos = (1 - aimAlpha) * posHip + aimAlpha * posAim
		Anim.Rot = (1 - aimAlpha) * rotHip + aimAlpha * rotAim
		
		Anim.Ang = Anim.Ang + RAD(105 * dt) * stanceSway
		
		--Gun Momentum updating
		gunMomentum.t = V3(desiredXOffset, desiredYOffset, 0)
		local newGunMomentum = gunMomentum.p
		currentXOffset = newGunMomentum.X / S.momentumSettings.maxInput
		currentYOffset = newGunMomentum.Y / S.momentumSettings.maxInput
		
		--Recoil spring updating
		gunRecoilSpring.t = recoilAnim.Rot
		camRecoilSpring.t = camOffsets.Recoil.Rot
		
		--Cross spring updating
		if Aimed then
			crossSpring.t = V3(-2, 0, 0)
		else
			crossSpring.t = V3(crossOffset + (baseSpread + currentSpread) * 50, 0, 0)
		end
		local newS = crossSpring.p.X
		crossA.Position = UDim2.new(0.5, -1, 1, -newS / 2)
		crossB.Position = UDim2.new(0, newS / 2 - 15, 0.5, -1)
		crossC.Position = UDim2.new(0.5, -1, 0, newS / 2 - 15)
		crossD.Position = UDim2.new(1, -newS / 2, 0.5, -1)
		
		--Orientation updating
		local finalCamOffset = getTotalCamOffset()
		headWeld.C1 = CFANG(-camAng.y - finalCamOffset.Y, 0, 0)
		if (not Humanoid.Sit) then
			HRP.CFrame = CF(HRP.Position) * CFANG(0, camAng.x + finalCamOffset.X, 0)
		end
		
		--Walkspeed updating
		if Running then
			Humanoid.WalkSpeed = S.walkSpeeds.Sprinting
		else
			local SpeedRatio = S.walkSpeeds.Aimed / S.walkSpeeds.Base
			if Stance == 0 then
				Humanoid.WalkSpeed = (Aimed and S.walkSpeeds.Aimed or S.walkSpeeds.Base)
			elseif Stance == 1 then
				Humanoid.WalkSpeed = (Aimed and S.walkSpeeds.Crouched * SpeedRatio or S.walkSpeeds.Crouched)
			elseif Stance == 2 then
				Humanoid.WalkSpeed = (Aimed and S.walkSpeeds.Prone * SpeedRatio or S.walkSpeeds.Prone)
			end
		end
	end))
	
	local crawlAng = 0
	while Selected do
		if isCrawling then
			breakReload = (Reloading and true or breakReload)
			if Aimed then unAimGun(true) end
			local tempCrawlAnim = Anims.Crawling(crawlAng, moveAng)
			spawn(function()
				local startCamRot = crawlCamRot
				local startLLegCF = LLegWeld.C1
				local startRLegCF = RLegWeld.C1
				local t0 = tick()
				while true do
					RS.Heartbeat:wait()
					local Alpha = math.min((tick() - t0) / 0.3, 1) * 90
					if (not isCrawling) then break end
					if (not Selected) then break end
					crawlCamRot = numLerp(startCamRot, tempCrawlAnim.Camera, Sine(Alpha))
					LLegWeld.C1 = startLLegCF:lerp(tempCrawlAnim.leftLeg, Linear(Alpha))
					RLegWeld.C1 = startRLegCF:lerp(tempCrawlAnim.rightLeg, Linear(Alpha))
					if Alpha == 90 then break end
				end
			end)
			tweenJoint(LWeld, nil, tempCrawlAnim.leftArm, Linear, 0.3)
			tweenJoint(RWeld, nil, tempCrawlAnim.rightArm, Linear, 0.3)
			tweenJoint(Grip, nil, tempCrawlAnim.Grip, Linear, 0.3)
			lowerSpread()
			local t0 = tick()
			while true do
				local dt = RS.Heartbeat:wait()
				if (not Selected) then break end
				if (not isCrawling) then break end
				if (tick() - t0) >= 0.3 then
					local crawlAnim = Anims.Crawling(crawlAng, moveAng)
					LWeld.C1 = crawlAnim.leftArm
					RWeld.C1 = crawlAnim.rightArm
					LLegWeld.C1 = crawlAnim.leftLeg
					RLegWeld.C1 = crawlAnim.rightLeg
					Grip.C1 = crawlAnim.Grip
					crawlCamRot = crawlAnim.Camera
					crawlAng = crawlAng + 0.5 * RAD(105 * dt) * (HRP.Velocity * V3(1, 0, 1)).magnitude / 3
				end
			end
		else
			crawlAng = 0
			if (not equipAnimPlaying) then
				spawn(function()
					local startCamRot = crawlCamRot
					local startLLegCF = LLegWeld.C1
					local startRLegCF = RLegWeld.C1
					local t0 = tick()
					while true do
						RS.RenderStepped:wait()
						local Alpha = math.min((tick() - t0) / 0.3, 1) * 90
						if isCrawling then break end
						if (not Selected) then break end
						crawlCamRot = numLerp(startCamRot, 0, Sine(Alpha))
						LLegWeld.C1 = startLLegCF:lerp(CF(), Linear(Alpha))
						RLegWeld.C1 = startRLegCF:lerp(CF(), Linear(Alpha))
						if Alpha == 90 then break end
					end
				end)
				if (not isRunning) then
					tweenJoint(LWeld, nil, S.unAimedC1.leftArm, Sine, 0.3)
					tweenJoint(RWeld, nil, S.unAimedC1.rightArm, Sine, 0.3)
					tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, 0.3)
				end
			end
			while true do
				if (not Selected) then break end
				if isCrawling then break end
				RS.RenderStepped:wait()
			end
		end
		wait()
	end
end

function getAnimCF()
	return 	CF(aimHeadOffset, 0, 0) * CFANG(
		jumpAnim.Rot * COS(camAng.Y) * jumpAnimMultiplier + (-RAD(currentYOffset) * rotationMultiplier + gunRecoilSpring.p.X + Anim.Rot.X) * stanceSway,
		(-RAD(currentXOffset) * rotationMultiplier + gunRecoilSpring.p.Y + Anim.Rot.Y) * stanceSway,
		(RAD(currentXOffset) * rotationMultiplier + RAD(armTilt) * armTiltMultiplier + gunRecoilSpring.p.Z + Anim.Rot.Z) * stanceSway
	) * CF(
		(Anim.Pos.X + recoilAnim.Pos.X) * stanceSway,
		jumpAnim.Pos * COS(camAng.Y) * jumpAnimMultiplier + (Anim.Pos.Y + recoilAnim.Pos.Y) * stanceSway,
		-jumpAnim.Pos * SIN(camAng.Y) * jumpAnimMultiplier + (Anim.Pos.Z + recoilAnim.Pos.Z) * stanceSway
	), CFANG(-camAng.Y * crawlAlpha / 90, 0, 0) * CF(aimHeadOffset, -1, 0)
end

--------------------[ FIRING FUNCTIONS ]----------------------------------------------

function lowerSpread()
	if (not loweringSpread) then
		loweringSpread = true
		local Connection = nil
		Connection = RS.Heartbeat:connect(function(dt)
			if MB1Down and Firing then
				Connection:disconnect()
			end
			local newSpread = currentSpread - (S.spreadSettings.Decrease * dt)
			currentSpread = (newSpread < 0 and 0 or newSpread)
			if currentSpread == 0 then
				Connection:disconnect()
			end
		end)
		loweringSpread = false
	end
end

local function autoFire()
	if (not canFire) then return end
	canFire = false
	
	if (not Knifing) then
		Firing = true
		while MB1Down and (not Reloading) and (not isCrawling) and (not Knifing) do
			if Modes[((rawFireMode - 1) % numModes) + 1] ~= "AUTO" then break end
			if Humanoid.Health == 0 then break end
			if Ammo.Value > 0 then
				Ammo.Value = Ammo.Value - 1
				if Aimed and steadyKeyPressed and S.scopeSettings.unSteadyOnFire then
					steadyKeyPressed = false
					currentSteadyTime = 0
				end
				newMag = false
				fireGun()
			end
			if S.reloadSettings.magIsBullet then
				for _, Mag in pairs(Gun:GetChildren()) do
					if Mag.Name:sub(1, 3) == "Mag" then
						Mag.Transparency = 1
					end
				end
			end
			if Ammo.Value == 0 and S.reloadSettings.autoReload then
				wait(0.2)
				Reload()
			end
			wait(60 / S.roundsPerMin)
		end
	end
	
	Firing = false
	canFire = true
end

local function semiFire()
	if (not canFire) then return end
	canFire = false
	
	if (not Knifing) and (not isCrawling) and Humanoid.Health ~= 0 then
		Firing = true
		if Ammo.Value > 0 then
			Ammo.Value = Ammo.Value - 1
			if Aimed and steadyKeyPressed and S.scopeSettings.unSteadyOnFire then
				steadyKeyPressed = false
				currentSteadyTime = 0
			end
			newMag = false
			fireGun()
		end
		if S.reloadSettings.magIsBullet then
			for _, Mag in pairs(Gun:GetChildren()) do
				if Mag.Name:sub(1, 3) == "Mag" then
					Mag.Transparency = 1
				end
			end
		end
		if Ammo.Value == 0 and S.reloadSettings.autoReload then
			wait(0.2)
			Reload()
		end
		wait(60 / S.roundsPerMin)
	end
	
	Firing = false
	canFire = true
end

local function burstFire()
	if (not canFire) then return end
	canFire = false
	
	local burstTime = 60 / S.roundsPerMin
	if (not Knifing) and (not isCrawling) then
		Firing = true
		for i = 1, S.burstSettings.Amount do
			if Ammo.Value > 0 then
				Ammo.Value = Ammo.Value - 1
				if Humanoid.Health ~= 0 then
					if Aimed and steadyKeyPressed and S.scopeSettings.unSteadyOnFire then
						steadyKeyPressed = false
						currentSteadyTime = 0
					end
					newMag = false
					fireGun()
				end
			end
			if Ammo.Value == 0 and S.reloadSettings.autoReload then
				wait(0.2)
				Reload()
				break
			end
			wait(S.burstSettings.fireRateBurst and burstTime or S.burstSettings.Time / S.burstSettings.Amount)
		end
	end
	if S.reloadSettings.magIsBullet then
		for _, Mag in pairs(Gun:GetChildren()) do
			if Mag.Name:sub(1, 3) == "Mag" then
				Mag.Transparency = 1
			end
		end
	end
	
	Firing = false
	
	wait(S.burstSettings.fireRateBurst and burstTime or S.burstSettings.Wait)
	
	canFire = true
end

function fireGun()
	local fireSound = Handle:FindFirstChild("FireSound")
	if fireSound then fireSound:Play() end
	----------------------------------------------------------------------------------
	for _ = 1, (S.gunType.Shot and S.ShotAmount or 1) do
		local randSpread1 = RAD(RAND(0, 365))
		local randSpread2 = RAD(RAND(-(baseSpread + currentSpread), baseSpread + currentSpread, 0.01))
		local spreadDir = CFrame.fromAxisAngle(V3(0, 0, 1), randSpread1) * CFANG(randSpread2, 0, 0)
		
		local originCF = ((Aimed and S.guiScope) and Head.CFrame or Handle.CFrame) * spreadDir
		local bulletDirection = CF(originCF.p, originCF.p + originCF.lookVector).lookVector
		
		if S.bulletSettings.instantHit then
			local newRay = Ray.new(Main.CFrame.p, bulletDirection * S.bulletSettings.Range)
			local H, P, N = workspace:FindPartOnRayWithIgnoreList(newRay, Ignore)
			local finalP = P
			if H then
				if S.gunType.Explosive then
					if S.explosionSettings.soundId ~= "" then
						local soundPart = Instance.new("Part")
						soundPart.Transparency = 1
						soundPart.Anchored = true
						soundPart.CanCollide = false
						soundPart.Size = V3(1, 1, 1)
						soundPart.CFrame = CFrame.new(P)
						soundPart.Parent = gunIgnore
						
						local Sound = Instance.new("Sound")
						Sound.Pitch = S.explosionSettings.Pitch
						Sound.SoundId = S.explosionSettings.soundId
						Sound.Volume = S.explosionSettings.Volume
						Sound.Parent = soundPart
						Sound:Play()
						
						DS:AddItem(soundPart, Sound.TimeLength)
					end
					createBulletImpact:FireServer(H, P, N, bulletDirection, false, gunIgnore, S)
					createShockwave:FireServer(P, S.explosionSettings.Radius, gunIgnore, S)
					local E = Instance.new("Explosion")
					E.BlastPressure = S.explosionSettings.Pressure
					E.BlastRadius = S.explosionSettings.Radius
					E.DestroyJointRadiusPercent = (S.explosionSettings.rangeBasedDamage and 0 or 1)
					E.ExplosionType = S.explosionSettings.Type
					E.Position = P
					E.Hit:connect(function(Obj, Dist)
						if Obj.Name == "Torso" and (not Obj:IsDescendantOf(Char)) then
							if S.explosionSettings.rangeBasedDamage then
								local Dir = (Obj.Position - P).unit
								local expH, _ = workspace:FindPartOnRayWithIgnoreList(
									Ray.new(P - Dir * 0.1, Dir * 999),
									Ignore
								)
								local rayHitHuman = expH:IsDescendantOf(Obj.Parent)
								if (S.explosionSettings.rayCastExplosions and rayHitHuman) or (not S.explosionSettings.rayCastExplosions) then
									local hitHumanoid = findFirstClass(Obj.Parent, "Humanoid")
									if hitHumanoid and hitHumanoid.Health > 0 and isEnemy(hitHumanoid) then
										local distFactor = Dist / S.explosionSettings.Radius
										local distInvert = math.max(1 - distFactor,0)
										local newDamage = distInvert * getBaseDamage((P - Main.CFrame.p).magnitude)
										
										local Tag = Instance.new("ObjectValue")
										Tag.Value = Player
										Tag.Name = "creator"
										Tag.Parent = hitHumanoid
										DS:AddItem(Tag, 0.3)
										hitHumanoid:TakeDamage(newDamage)
										markHit()
									end
								end
							else
								local hitHumanoid = findFirstClass(Obj.Parent, "Humanoid")
								if hitHumanoid and hitHumanoid.Health > 0 and isEnemy(hitHumanoid) then
									local Tag = Instance.new("ObjectValue")
									Tag.Value = Player
									Tag.Name = "creator"
									Tag.Parent = hitHumanoid
									DS:AddItem(Tag, 0.3)
									markHit()
								end
							end
						end
					end)
					E.Parent = game.Workspace
				else
					_, finalP = penetrateWall(H, P, bulletDirection, N, {Char, ignoreModel}, 0, (P - Main.CFrame.p).magnitude, nil)
				end
			end
			if S.bulletTrail and S.trailSettings.Transparency ~= 1 then
				createTrail:FireServer(Main.CFrame.p, finalP, gunIgnore, S)
			end
		else
		
				local shell = Instance.new("Part")
				
	shell.CFrame = Gun.Chamber.CFrame * CFrame.fromEulerAnglesXYZ(-1.5,0,0)
	shell.Size = Vector3.new(1,1,1)
	shell.BrickColor = BrickColor.new(24)
	shell.Reflectance = .5
	shell.CanCollide = false	
	shell.BottomSurface = 0
	shell.TopSurface = 0
	shell.Name = "Shell"
	shell.Velocity = Gun.Chamber.CFrame.lookVector * 30 + Vector3.new(math.random(-10,10),20,math.random(-10,10))
	shell.RotVelocity = Vector3.new(0,200,0)
	local shellmesh = Instance.new("CylinderMesh")
	shellmesh.Scale = Vector3.new(0.1, 0.8, 0.1)
	shellmesh.Parent = shell
	shell.Parent = game.Workspace
	game:GetService("Debris"):addItem(shell,2)
	
	local shellmesh = Instance.new("SpecialMesh")
	shellmesh.Scale = Vector3.new(0.9,0.9,3)
	shellmesh.MeshId = "http://www.roblox.com/asset/?id=95387759"
	shellmesh.TextureId = "http://www.roblox.com/asset/?id=95387789"
	shellmesh.MeshType = "FileMesh"
	shellmesh.Parent = shell
		end
	end
	function MarkHit()
	spawn(function()
		if Gui_Clone:IsDescendantOf(game) then
			Gui_Clone.HitMarker.Visible = true
			local StartMark = tick()
			LastMark = StartMark
			wait(0.5)
			if LastMark <= StartMark then
				Gui_Clone.HitMarker.Visible = false
			end
		end
	end)
end
	
	----------------------------------------------------------------------------------
	
	currentSpread = currentSpread + S.spreadSettings.Increase
	
	for _, Plugin in pairs(Plugins.Firing) do
		spawn(function()
			Plugin()
		end)
	end
	
	local backRecoil = RAND(S.recoilSettings.Recoil.Back.Min, S.recoilSettings.Recoil.Back.Max, 0.01) --Get the kickback recoil
	local upRecoil = RAND(S.recoilSettings.Recoil.Up.Min, S.recoilSettings.Recoil.Up.Max, 0.01) --Get the up recoil
	local sideRecoilAlpha = 0
	if lastSideRecoil[1] < 0 and lastSideRecoil[2] < 0 then --This conditional basically makes sure the gun tilt isn't in the same direction for more than 2 shots
		sideRecoilAlpha = RAND(0, 1, 0.1)
	elseif lastSideRecoil[1] > 0 and lastSideRecoil[2] > 0 then
		sideRecoilAlpha = RAND(-1, 0, 0.1)
	else
		sideRecoilAlpha = RAND(-1, 1, 0.1)
	end
	local sideRecoil = numLerp(S.recoilSettings.Recoil.Side.Left, S.recoilSettings.Recoil.Side.Right, sideRecoilAlpha / 2 + 0.5) --Get the side recoil
	local tiltRecoil = numLerp(S.recoilSettings.Recoil.Tilt.Left, S.recoilSettings.Recoil.Tilt.Right, sideRecoilAlpha / 2 + 0.5) --Get the tilt recoil
	local recoilPos = V3(
		0,---sideRecoil,
		0,
		-backRecoil
	) * (Aimed and S.recoilSettings.aimedMultiplier or 1)
	local recoilRot = V3(
		(Aimed and 0 or (-RAD(upRecoil * 10) * (firstShot and S.recoilSettings.firstShotMultiplier or 1))),
		RAD(sideRecoil * 10),
		RAD(tiltRecoil * 10)
	) * (Aimed and S.recoilSettings.aimedMultiplier or 1)
	local camRecoilRot = V3(
		-RAD(sideRecoil * 10),
		RAD(upRecoil * 10) * (firstShot and S.recoilSettings.firstShotMultiplier or 1) * S.recoilSettings.camMultiplier,
		0
	) * (Aimed and S.recoilSettings.aimedMultiplier or 1) * stanceSway
	tweenRecoil(recoilPos, recoilRot, Sine, 0.2)
	tweenCam("Recoil", camRecoilRot, Sine, 0.15 * (firstShot and S.recoilSettings.firstShotMultiplier or 1))
	
	for _, v in pairs(Main:GetChildren()) do
		if v.Name:sub(1, 7) == "FlashFX" then
			v.Enabled = true
		end
	end
			local shell = Instance.new("Part")
	shell.CFrame = Gun.Chamber.CFrame * CFrame.fromEulerAnglesXYZ(-1.5,0,0)
	shell.Size = Vector3.new(0.2,0.5,0.2)
	shell.Name = "Shell"
	shell.Velocity = Gun.Chamber.CFrame.lookVector * 30 + Vector3.new(math.random(-10,10),20,math.random(-10,10))
	shell.RotVelocity = Vector3.new(0,200,0)
	shell.Parent = game.Workspace
	game:GetService("Debris"):addItem(shell,2)
	local shellmesh = Instance.new("SpecialMesh")
	shellmesh.Scale = Vector3.new(2,2,2)
	shellmesh.MeshId = "http://www.roblox.com/asset/?id=94295100"
	shellmesh.TextureId = "http://www.roblox.com/asset/?id=94287792"
	shellmesh.MeshType = "FileMesh"
	shellmesh.Parent = shell
	delay(1 / 20, function()
		tweenRecoil(V3(), V3(), Sine, 0.2)
		tweenCam("Recoil", V3(), Sine, 0.2)
		for _, v in pairs(Main:GetChildren()) do
			if v.Name:sub(1, 7) == "FlashFX" then
				v.Enabled = false
			end
		end
	end)
	
	updateClipAmmo()
	firstShot = false
	shotCount = shotCount + 1
	lastSideRecoil[(shotCount % 2) + 1] = sideRecoilAlpha
end

function markHit()
	spawn(function()
		if mainGUI:IsDescendantOf(game) then
			hitMarker.Visible = true
			local startMark = tick()
			hitMarker.lastMark.Value = startMark
			
			wait(0.5)
			
			if hitMarker.lastMark.Value <= startMark then
				hitMarker.Visible = false
			end
		end
	end)
end

--------------------[ ADS FUNCTIONS ]-------------------------------------------------

function aimGun()
	if Reloading or Knifing or isCrawling or (not S.canADS) then return end
	
	mouseSensitivity = aimSensitivity
	
	for _, Plugin in pairs(Plugins.Aimed) do
		spawn(function()
			Plugin()
		end)
	end
	
	Aimed = true
	Aiming = true
	Running = false
	spreadZoom = "Aimed"
	baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	if S.aimSettings.Anim then
		local currentFOV = Cam.FieldOfView
		local currentTrans = Scope.BackgroundTransparency
		tweenJoint(LWeld, armC0[1], S.aimedC1.leftArm, Sine, S.aimSettings.Speed)
		tweenJoint(RWeld, armC0[2], S.aimedC1.rightArm, Sine, S.aimSettings.Speed)
		tweenJoint(LWeld2, nil, CF(), Sine, S.aimSettings.Speed)
		tweenJoint(RWeld2, nil, CF(), Sine, S.aimSettings.Speed)
		tweenJoint(Grip, nil, aimedGripCF, Sine, S.aimSettings.Speed)
		tweenJoint(headWeld2, nil, CF(0, -0.5, 0) * CFANG(0, 0, S.aimSettings.headTilt) * CF(0, 0.5, 0), Sine, S.aimSettings.Speed)
		local t0 = tick()
		while true do
			RS.RenderStepped:wait()
			local Alpha = math.min((tick() - t0) / S.aimSettings.Speed, 1) * 90
			if (not Aimed) then break end
			if (not Selected) then break end
			aimAlpha = Sine(Alpha)
			aimHeadOffset = headOffset.X * aimAlpha
			jumpAnimMultiplier = numLerp(1, S.fallSettings.aimEffect, aimAlpha)
			translationDivisor = numLerp(7, 20, aimAlpha)
			rotationMultiplier = numLerp(S.momentumSettings.Amplitude.unAimed, S.momentumSettings.Amplitude.Aimed, aimAlpha)
			armTiltMultiplier = numLerp(1, 0.2, aimAlpha)
			Cam.FieldOfView = numLerp(currentFOV, S.aimSettings.FOV, aimAlpha)
			if S.guiScope then
				Scope.BackgroundTransparency = numLerp(currentTrans, 0, aimAlpha)
			end
			if Alpha == 90 then break end
		end
	else
		LWeld.C0, LWeld.C1 = armC0[1], S.aimedC1.leftArm
		RWeld.C0, RWeld.C1 = armC0[2], S.aimedC1.rightArm
		LWeld2.C1, RWeld2.C1 = CF(), CF()
		animWeld.C0 = CF(0, 1, 0)
		Grip.C1 = aimedGripCF
		headWeld2.C1 = CF(0, -0.5, 0) * CFANG(0, 0, S.aimSettings.headTilt) * CF(0, 0.5, 0)
		aimAlpha = 1
		aimHeadOffset = headOffset.X
		jumpAnimMultiplier = S.fallSettings.aimEffect
		translationDivisor = 20
		rotationMultiplier = S.momentumSettings.Amplitude.Aimed
		armTiltMultiplier = 0.2
		Cam.FieldOfView = S.aimSettings.FOV
	end
	Aiming = (not Aimed)
	if (not Aiming) and S.guiScope then
		spawn(function()
			scopeSteady.Visible = true
			Scope.BackgroundTransparency = 1
			scopeMain.Visible = true
			
			if armTable then
				for _, Obj in pairs(armTable[1].Model:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 1
					end
				end
				for _, Obj in pairs(armTable[2].Model:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 1
					end
				end
			elseif armModel then
				for _, Obj in pairs(armModel:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 1
					end
				end
			end
			for _, Obj in pairs(playerFolder:GetChildren()) do
				if Obj:IsA("BasePart") then
					Obj.LocalTransparencyModifier = 1
				end
			end
			for _, Obj in pairs(Gun:GetChildren()) do
				if Obj:IsA("BasePart") then
					Obj.LocalTransparencyModifier = 1
				end
			end
		end)
		spawn(function()
			local camAng = 0
			local idleCam = function()
				return V3(
					RAD(SIN(camAng * S.scopeSettings.Frequency.Idling)) * stanceSway * camSway * S.scopeSettings.Amplitude.Idling,
					RAD(SIN(camAng * 5 / 2 * S.scopeSettings.Frequency.Idling)) * stanceSway * camSway * S.scopeSettings.Amplitude.Idling * 0.75,
					0
				)
			end
			local walkCam = function()
				return V3(
					RAD(SIN(camAng * S.scopeSettings.Frequency.Walking)) * camSway * stanceSway * S.scopeSettings.Amplitude.Walking,
					RAD(SIN(camAng * 5 / 2 * S.scopeSettings.Frequency.Walking)) * camSway * stanceSway * S.scopeSettings.Amplitude.Walking * 0.75,
					0
				)
			end
			while Aimed do
				local dt = RS.RenderStepped:wait()
				camOffsets.guiScope.Rot = (Sine(idleAlpha) * idleCam()) + (Sine(walkAlpha) * walkCam())
				camAng = camAng + RAD(105 * dt) * stanceSway * camSway
			end
		end)
	end
end

function unAimGun(Exception)
	if (not S.canADS) then return end
	
	mouseSensitivity = S.sensitivitySettings.Default
	
	for _, Plugin in pairs(Plugins.UnAimed) do
		spawn(function()
			Plugin()
		end)
	end
	
	if S.guiScope then
		spawn(function()
			if armTable then
				for _, Obj in pairs(armTable[1].Model:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 0
					end
				end
				for _, Obj in pairs(armTable[2].Model:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 0
					end
				end
			elseif armModel then
				for _, Obj in pairs(armModel:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 0
					end
				end
			end
			for _, Obj in pairs(playerFolder:GetChildren()) do
				if Obj:IsA("BasePart") then
					Obj.LocalTransparencyModifier = 0
				end
			end
			for _, Obj in pairs(Gun:GetChildren()) do
				if Obj:IsA("BasePart") then
					Obj.LocalTransparencyModifier = 0
				end
			end
		end)
	end
	
	if (not Exception) then
		if (not Aimed) then return end
		if (Reloading and Exception) or Knifing then return end
		spreadZoom = "unAimed"
		baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
		Aimed = false
		Aiming = true
		if S.aimSettings.Anim then
			local currentFOV = Cam.FieldOfView
			local currentTrans = (Scope.BackgroundTransparency == 1 and (S.guiScope and 0 or 1) or Scope.BackgroundTransparency)
			scopeMain.Visible = false
			scopeSteady.Visible = false
			tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, S.aimSettings.Speed)
			tweenJoint(RWeld, armC0[2], S.unAimedC1.rightArm, Sine, S.aimSettings.Speed)
			tweenJoint(headWeld2, nil, CF(), Sine, S.aimSettings.Speed)
			tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, S.aimSettings.Speed)
			local t0 = tick()
			while true do
				RS.RenderStepped:wait()
				local Alpha = math.min((tick() - t0) / S.aimSettings.Speed, 1) * 90
				if Aimed then break end
				if (not Selected) then break end
				aimAlpha = 1 - Sine(Alpha)--1 - COS(RAD(X))
				aimHeadOffset = headOffset.X * aimAlpha
				jumpAnimMultiplier = numLerp(1, S.fallSettings.aimEffect, aimAlpha)
				translationDivisor = numLerp(7, 20, aimAlpha)
				rotationMultiplier = numLerp(S.momentumSettings.Amplitude.unAimed, S.momentumSettings.Amplitude.Aimed, aimAlpha)
				armTiltMultiplier = numLerp(1, 0.2, aimAlpha)
				Cam.FieldOfView = numLerp(80, currentFOV, aimAlpha)
				Scope.BackgroundTransparency = numLerp(1, currentTrans, aimAlpha)
				if Alpha == 90 then break end
			end
		else
			scopeMain.Visible = false
			scopeSteady.Visible = false
			LWeld.C0, LWeld.C1 = armC0[1], S.unAimedC1.leftArm
			RWeld.C0, RWeld.C1 = armC0[2], S.unAimedC1.rightArm
			headWeld2.C0 = CF()
			Grip.C1 = S.unAimedC1.Grip
			aimAlpha = 0
			aimHeadOffset = 0
			jumpAnimMultiplier = 1
			translationDivisor = 7
			rotationMultiplier = S.momentumSettings.Amplitude.unAimed
			armTiltMultiplier = 1
			Cam.FieldOfView = 80
			Scope.BackgroundTransparency = 1
		end
		Aiming = Aimed
	else
		spawn(function()
			Aimed = false
			Aiming = false
			spreadZoom = "unAimed"
			baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
			local currentFOV = Cam.FieldOfView
			local currentTrans = (Scope.BackgroundTransparency == 1 and (S.guiScope and 0 or 1) or Scope.BackgroundTransparency)
			scopeMain.Visible = false
			scopeSteady.Visible = false
			tweenJoint(headWeld2, nil, CF(), Sine, S.aimSettings.Speed)
			if S.aimSettings.Anim then
				local t0 = tick()
				while true do
					RS.RenderStepped:wait()
					local Alpha = math.min((tick() - t0) / S.aimSettings.Speed, 1) * 90
					if Aimed then break end
					if (not Selected) then break end
					aimAlpha = 1 - Sine(Alpha)--1 - COS(RAD(90 - Alpha))
					aimHeadOffset = headOffset.X * aimAlpha
					jumpAnimMultiplier = numLerp(1, S.fallSettings.aimEffect, aimAlpha)
					translationDivisor = numLerp(7, 20, aimAlpha)
					rotationMultiplier = numLerp(S.momentumSettings.Amplitude.unAimed, S.momentumSettings.Amplitude.Aimed, aimAlpha)
					armTiltMultiplier = numLerp(1, 0.2, aimAlpha)
					Cam.FieldOfView = numLerp(80, currentFOV, aimAlpha)
					Scope.BackgroundTransparency = numLerp(1, currentTrans, aimAlpha)
					if Alpha == 90 then break end
				end
			else
				scopeMain.Visible = false
				scopeSteady.Visible = false
				aimAlpha = 0
				aimHeadOffset = 0
				jumpAnimMultiplier = 1
				translationDivisor = 7
				rotationMultiplier = S.momentumSettings.Amplitude.unAimed
				armTiltMultiplier = 1
				Cam.FieldOfView = 80
				Scope.BackgroundTransparency = 1
			end
		end)
	end
end

--------------------[ TEXTURE CREATION FUNCTIONS ]------------------------------------

function createBullet(Direction)
	local Origin = Gun.Main.CFrame.p
	local bulletCF = CF(Origin, Origin + Direction)
	local Bullet = Instance.new("Part")
	Bullet.BrickColor = S.bulletSettings.Color
	Bullet.Material = Enum.Material.Neon
	Bullet.Name = "Bullet"
	Bullet.CanCollide = false
	Bullet.FormFactor = "Custom"
	Bullet.Size = S.bulletSettings.Size
	Bullet.BottomSurface = "Smooth"
	Bullet.TopSurface = "Smooth"
	if math.min(S.bulletSettings.Size.X, S.bulletSettings.Size.Y, S.bulletSettings.Size.Z) < 0.2 then
		local Mesh = Instance.new("BlockMesh")
		Mesh.Scale = S.bulletSettings.Size / Vector3.new(
			math.max(S.bulletSettings.Size.X, 0.2),
			math.max(S.bulletSettings.Size.Y, 0.2),
			math.max(S.bulletSettings.Size.Z, 0.2)
		)
		Mesh.Parent = Bullet
	end
	local BF = Instance.new("BodyForce")
	BF.force = V3(0, Bullet:GetMass() * (196.2 - S.bulletSettings.Acceleration), 0)
	BF.Parent = Bullet
	Bullet.Parent = gunIgnore
	Bullet.CFrame = bulletCF + Direction * S.bulletSettings.Size.Z / 2
	Bullet.Velocity = Direction * S.bulletSettings.Velocity
	return Bullet
end

--------------------[ HIT HANDLING FUNCTIONS ]----------------------------------------

function getBaseDamage(Dist)
	local startDmg = S.damageSettings.Start.Damage
	local startDist = S.damageSettings.Start.Dist
	local endDmg = S.damageSettings.End.Damage
	local endDist = S.damageSettings.End.Dist
	return (
		(
			Dist < startDist * S.bulletSettings.Range
		) and startDmg or
		(
			Dist >= startDist * S.bulletSettings.Range and
			Dist < endDist * S.bulletSettings.Range
		) and numLerp(startDmg, endDmg, Map(Dist / S.bulletSettings.Range, startDist, endDist, 0, 1)) or
		(
			Dist >= endDist * S.bulletSettings.Range
		) and endDmg
	)
end

function Damage(H, P, N, D, Dist, customIgnore)
	local hVal = S.damageSettings.Multipliers.Head
	local cVal = S.damageSettings.Multipliers.Chest
	local lVal = S.damageSettings.Multipliers.Limbs
	local baseDamage = getBaseDamage(Dist)
	if Humanoid.Health ~= 0 then
		local hitHumanoid = nil
		if H.Parent:IsA("Hat") then
			table.insert(customIgnore, H)
			local newRay = Ray.new(P - D * 0.1, D * (S.bulletSettings.Range - Dist + 0.1))
			local newH, newP, newN = workspace:FindPartOnRayWithIgnoreList(newRay, customIgnore)
			if newH then
				hitHumanoid = Damage(newH, newP, newN, D, Dist + (newP - P).magnitude, customIgnore)
			end
		else
			hitHumanoid = findFirstClass(H.Parent, "Humanoid")
			if hitHumanoid and hitHumanoid.Health > 0 and isEnemy(hitHumanoid) then
				local Tag = Instance.new("ObjectValue")
				Tag.Value = Player
				Tag.Name = "creator"
				Tag.Parent = hitHumanoid
				DS:AddItem(Tag, 0.3)
				local chosenDamage = 0
				if H.Name == "Head" then
					chosenDamage = baseDamage  * RAND(hVal, hVal + 0.1, 0.01)
				elseif H.Name == "Torso" then
					chosenDamage = baseDamage  * RAND(cVal, cVal + 0.1, 0.01)
				else
					chosenDamage = baseDamage  * RAND(lVal, lVal + 0.1, 0.01)
				end
				hitHumanoid:TakeDamage(chosenDamage)
				markHit()
			end
		end
		return hitHumanoid
	end
end

function isWallIgnored(Wall)
	return (
		Wall.Transparency >= S.penetrationSettings.transparencyThreshold or
		(S.penetrationSettings.ignoreNonCanCollide and (not Wall.CanCollide)) or
		isIgnored(Wall, S.penetrationSettings.ignoreCustom)
	)
end

function penetrateWall(Wall, hitPos, Direction, Normal, Ignore, totalPDist, totalBDist, lastDamagedHumanoid)
	local wallIgnore = isWallIgnored(Wall)
	local hitHumanoid = (Wall.Parent:IsA("Hat") and findFirstClass(Wall.Parent.Parent, "Humanoid") or findFirstClass(Wall.Parent, "Humanoid"))
	local damagedHumanoid = nil
	if hitHumanoid and hitHumanoid ~= lastDamagedHumanoid then
		lastDamagedHumanoid = hitHumanoid
		damagedHumanoid = Damage(Wall, hitPos, Normal, Direction, totalBDist, {Char, ignoreModel})
	else
		lastDamagedHumanoid = nil
	end
	local ignoreObject = hitHumanoid and (Wall.Parent:IsA("Hat") and Wall.Parent.Parent or Wall.Parent) or Wall
	table.insert(Ignore, ignoreObject)
	local rayLength = S.bulletSettings.Range - totalBDist
	local testRay = Ray.new(hitPos, Direction * (S.bulletSettings.Range - totalBDist))
	local H1, P1, N1 = workspace:FindPartOnRayWithIgnoreList(testRay, Ignore)
	local newIgnore = removeElement(Ignore, ignoreObject)
	local wallRay = Ray.new(P1 + Direction * 0.1, -Direction * (rayLength + 1))
	local H2, P2, N2 = workspace:FindPartOnRayWithIgnoreList(wallRay, Ignore)
	local newPDist = totalPDist + (wallIgnore and 0 or (getNearestPoint(P1, P2, hitPos) - hitPos).magnitude)
	local newBDist = totalBDist + (P1 - hitPos).magnitude
	local outOfRange = Round(newPDist, 0.001) > S.penetrationSettings.Dist or Round(newBDist, 0.001) > S.bulletSettings.Range
	if (not wallIgnore) then
		createBulletImpact:FireServer(Wall, hitPos, Normal, Direction, hitHumanoid, gunIgnore, S)
		if (not hitHumanoid) then
			createShockwave:FireServer(hitPos, S.shockwaveSettings.Radius, gunIgnore, S)
		end
	end
	if hitHumanoid and hitHumanoid.Health > 0 and isEnemy(hitHumanoid) and hitHumanoid == damagedHumanoid then
		createBlood:FireServer(Wall, P2, Direction, gunIgnore, S)
	end
	if outOfRange or (not H1) then
		if (not outOfRange) and (not wallIgnore) then
			createBulletImpact:FireServer(Wall, P2, N2, Direction, hitHumanoid, gunIgnore, S)
			if (not hitHumanoid) then
				createShockwave:FireServer(P2, S.shockwaveSettings.Radius, gunIgnore, S)
			end
		end
		return Wall, hitPos
	else
		if Wall == H2 and (not wallIgnore) then
			createBulletImpact:FireServer(Wall, P2, N2, Direction, hitHumanoid, gunIgnore, S)
			if (not hitHumanoid) then
				createShockwave:FireServer(P2, S.shockwaveSettings.Radius, gunIgnore, S)
			end
		end
		return penetrateWall(H1, P1, Direction, N1, Ignore, newPDist, newBDist, lastDamagedHumanoid)
	end
end

function PenetrateWall(HitPos, Direction, HitHumanoid, OriginPos, Bullet, CurrentPDist)
	local HitDist = (HitPos - OriginPos).magnitude
	local Wall, WallHitPos = nil, nil
	local Hum, HumHitPos = nil, nil
	local CustomIgnore = {unpack(Ignore)}
	for i = 1, 10 do
		local WallRay = Ray.new(HitPos - (Direction * 0.1), Direction * S.Penetration)
		local H, P = game.Workspace:FindPartOnRayWithIgnoreList(WallRay, CustomIgnore)
		if H then
			local HitHumanoid = nil
			if H.Parent.ClassName == "Hat" then
				HitHumanoid = findFirstClass(H.Parent.Parent, "Humanoid")
			else
				HitHumanoid = findFirstClass(H.Parent, "Humanoid")
			end
			if HitHumanoid and i ~= 1 then
				Hum, HumHitPos = H, P
				break
			else
				Wall, WallHitPos = H, P
				table.insert(CustomIgnore, H)
			end
		else
			break
		end
	end
	if Wall then
		if S.InstantHit then
			if Hum then
				Damage(Hum.Parent:FindFirstChild("Head"), HumHitPos)
				return HumHitPos
			else
				local HitObj2, HitPos2 = nil, nil
				if HitHumanoid then
					HitObj2, HitPos2 = AdvRayCast(WallHitPos, Direction, S.BulletRange - HitDist, {Wall, HitHumanoid.Parent, unpack(Ignore)})
				else
					HitObj2, HitPos2 = AdvRayCast(WallHitPos, Direction, S.BulletRange - HitDist, {Wall, unpack(Ignore)})
				end
				Damage(HitObj2, HitPos2)
				
				local NewPDist = CurrentPDist + (WallHitPos - HitPos).magnitude
				local NewHitPos2 = HitPos2
				if NewPDist < S.Penetration and HitObj2 then
					NewHitPos2 = PenetrateWall(HitPos2, Direction, HitHumanoid, OriginPos, Bullet, CurrentPDist + NewPDist)
				end
				return NewHitPos2
			end
		else
			local LastPos = WallHitPos
			local TotalDistTraveled = 0
			spawn(function()
				if Hum then
					Damage(Hum.Parent:FindFirstChild("Head"), HumHitPos)
					return HumHitPos
				else
					while true do
						RS.RenderStepped:wait()
						if TotalDistTraveled >= S.BulletRange - HitDist then
							Bullet:Destroy()
							break
						end
						local DistTraveled = (Bullet.Position - LastPos).magnitude
						local NewDirection = (Bullet.Position - LastPos).unit
						local TempHitObj, TempHitPos = nil, nil
						if HitHumanoid then
							TempHitObj, TempHitPos = AdvRayCast(LastPos, NewDirection, DistTraveled, {Wall, HitHumanoid.Parent, unpack(Ignore)})
						else
							TempHitObj, TempHitPos = AdvRayCast(LastPos, NewDirection, DistTraveled, {Wall, unpack(Ignore)})
						end
						if TempHitObj then
							Damage(TempHitObj, TempHitPos)
							
							local NewPDist = CurrentPDist + (WallHitPos - HitPos).magnitude
							local NewTempPos = TempHitPos
							if NewPDist < S.Penetration and TempHitObj then
								NewTempPos = PenetrateWall(TempHitPos, Direction, HitHumanoid, OriginPos, Bullet, CurrentPDist + NewPDist)
							else
								Bullet:Destroy()
							end
							return NewTempPos
						else
							LastPos = Bullet.Position
							TotalDistTraveled = TotalDistTraveled + DistTraveled
						end
					end
				end
			end)
		end
	else
		if Bullet then Bullet:Destroy() end
		return HitPos
	end
end

function isEnemy(Human)
	local Plyr = game.Players:GetPlayerFromCharacter(Human.Parent)
	if (not Plyr) then return S.CanDamageNPCs end
	return S.AllowFriendlyFire or (Plyr.TeamColor ~= Player.TeamColor or Plyr.Neutral)
end

--------------------[ RELOAD FUNCTIONS ]----------------------------------------------

function animateReload()
	tweenJoint(LWeld2, CF(), CF(), Sine, 0.15)
	tweenJoint(RWeld2, CF(), CF(), Sine, 0.15)
	local magParts = {}
	local magTable = {}
			
	for _, Obj in pairs(Gun:GetChildren()) do
		if string.sub(Obj.Name, 1, 3) == "Mag" and Obj:IsA("BasePart") then
			INSERT(magParts, Obj)
		end
	end
	
	local animVars = {
		--FUNCTIONS--
		tweenJoint = tweenJoint;
		
		makeMagInvisible = function()
			for _, v in pairs(magParts) do
				v.Transparency = 1
			end
			magVisible = false
		end;
		
		makeMagVisible = function()
			for _, v in pairs(magParts) do
				v.Transparency = v:WaitForChild("magTrans").Value
			end
			magVisible = true
		end;
		
		isMagVisible = function()
			return magVisible
		end;
		
		isMagEmpty = function()
			return ammoInClip == 0
		end;
		
		setNewMag = function()
			newMag = true
		end;
		
		isNewMag = function()
			return newMag
		end;
		
		createMag = function(Key)
			local magModel = Instance.new("Model")
			local magClones = {}
			for i, v in pairs(magParts) do
				local vClone = v:Clone()
				vClone.Transparency = v:WaitForChild("magTrans").Value
				vClone.CanCollide = false
				vClone.Parent = magModel
				INSERT(magClones, {Original = v, magClone = vClone})
				if i ~= 1 then
					local W = Instance.new("Weld")
					W.Part0 = magClones[1].magClone
					W.Part1 = vClone
					W.C0 = magClones[1].magClone.CFrame:toObjectSpace(vClone.CFrame)
					W.Parent = magClones[1].magClone
				end
			end
			magTable[Key] = {magModel, magClones}
			return magModel, magClones
		end;
		
		getMag = function(Key)
			if magTable[Key] then
				return magTable[Key][1], magTable[Key][2]
			else
				return nil, nil
			end
		end;
		
		attachGripToHead = function()
			local handleCF = RArm.CFrame * Grip.C0
			Grip.C0 = Head.CFrame:toObjectSpace(handleCF)
			Grip.Part0 = Head
		end;
		
		attachGripToArm = function()
			local handleCF = Head.CFrame * Grip.C0
			Grip.C0 = RArm.CFrame:toObjectSpace(handleCF)
			Grip.Part0 = RArm
		end;
		
		Sine = Sine;
		
		Linear = Linear;
		
		--VARIABLES--
		Handle = Handle;
		LArm = LArm;
		RArm = RArm;
		LWeld = LWeld;
		RWeld = RWeld;
		LC0 = armC0[1];
		RC0 = armC0[2];
		Grip = Grip;
		gunIgnore = gunIgnore;
		Cam = Cam;
		CF = CF;
		CFANG = CFANG;
		V3 = V3;
		RAD = RAD;
		reloadTimeLoaded = S.reloadSettings.Times.Loaded;
		reloadTimeEmpty = S.reloadSettings.Times.Empty
	}
	
	local sequenceTable = Anims.Reload(animVars)
	--local T = tick()
	for _, reloadFunction in pairs(sequenceTable) do
		if breakReload then
			break
		end
		reloadFunction()
		
		if (not magVisible) then
			Ammo.Value = 0
		end
		updateClipAmmo()
	end
	--print(tick() - T) --I divide the reloadTime by this number to get the animation speed
	
	if (not isCrawling) then
		if Running and (not S.canFireWhileRunning) then
			tweenJoint(LWeld, armC0[1], S.runningC1.leftArm, Sine, 0.4)
			tweenJoint(RWeld, armC0[2], S.runningC1.rightArm, Sine, 0.4)
			tweenJoint(Grip, nil, S.runningC1.Grip, Sine, 0.4)
		else
			tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, 0.4)
			tweenJoint(RWeld, armC0[2], S.unAimedC1.rightArm, Sine, 0.4)
			tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, 0.4)
		end
	end
	
	for _, v in pairs(magTable) do --In case the reload animations was stopped mid way and there were still fake mags that weren't deleted
		v[1]:Destroy()
	end
end

function Reload()
	if Ammo.Value < (ClipSize.Value + 1) and (not Reloading) and StoredAmmo.Value > 0 then
		Firing = false
		ammoInClip = (ammoInClip == 0 and Ammo.Value or ammoInClip)
		Reloading = true
		lowerSpread()
		if Aimed then unAimGun(S.reloadSettings.Anim) end
		crossHair.Reload.Visible = true
		if Handle:FindFirstChild("ReloadSound") then Handle.ReloadSound:Play() end
		if S.reloadSettings.Anim then
			wait()
			animateReload()
		else
			local startReload = tick()
			local initialReloadTime = Ammo.Value == 0 and S.reloadSettings.Times.Empty or S.reloadSettings.Times.Loaded
			while true do
				if breakReload then break end
				if (tick() - startReload) >= initialReloadTime then break end
				RS.RenderStepped:wait()
			end
		end
		if (not breakReload) then
			newMag = false
			if StoredAmmo.Value >= ClipSize.Value then
				if ammoInClip > 0 then
					StoredAmmo.Value = StoredAmmo.Value - ((ClipSize.Value + 1) - ammoInClip)
					Ammo.Value = ClipSize.Value + 1
				else
					StoredAmmo.Value = StoredAmmo.Value - ClipSize.Value
					Ammo.Value = ClipSize.Value
				end
			elseif StoredAmmo.Value < ClipSize.Value and StoredAmmo.Value > 0 then
				Ammo.Value = StoredAmmo.Value
				StoredAmmo.Value = 0
			end
		end
		Reloading = false
		if Selected then
			ammoInClip = (breakReload and ammoInClip or 0)
			crossHair.Reload.Visible = false
		end
		breakReload = false
	end
	
	updateClipAmmo()
	updateStoredAmmo()
end

--------------------[ EXTERNAL DATA LOCATING FUNCTIONS ]-----------------------------

function removeElement(Table, Element) --removes the first instance of Element from Table
	for i, v in pairs(Table) do
		if v == Element then
			table.remove(Table, i)
			break
		end
	end
	return Table
end

function findFirstClass(Object, Class)
	local foundObject = nil
	for _, Obj in pairs(Object:GetChildren()) do
		if Obj.ClassName == Class then
			foundObject = Obj
			break
		end
	end
	return foundObject
end

function isIgnored(Obj, Table)
	for _,v in pairs(Table) do
		if Obj == v or Obj:IsDescendantOf(v) then
			return true
		end
	end
	return false
end

function GetHitSurfaceCFrame(HitPos,Obj)
	local SurfaceCF = {
		{"Back",Obj.CFrame * CF(0,0,Obj.Size.z)};
		{"Bottom",Obj.CFrame * CF(0,-Obj.Size.y,0)};
		{"Front",Obj.CFrame * CF(0,0,-Obj.Size.z)};
		{"Left",Obj.CFrame * CF(-Obj.Size.x,0,0)};
		{"Right",Obj.CFrame * CF(Obj.Size.x,0,0)};
		{"Top",Obj.CFrame * CF(0,Obj.Size.y,0)}
	}
	local ClosestDist = HUGE
	local ClosestSurface = nil
	for _,v in pairs(SurfaceCF) do
		local SurfaceDist = (HitPos - v[2].p).magnitude
		if SurfaceDist < ClosestDist then
			ClosestDist = SurfaceDist
			ClosestSurface = v
		end
	end
	return ClosestSurface[2]
end

function AdvRayCast(Origin, Direction, Dist, CustomIgnore)
	local NewIgnore = (CustomIgnore and CustomIgnore or Ignore)
	local NewRay = Ray.new(Origin, Direction * (Dist > 999 and 999 or Dist))
	local HitObj, HitPos = game.Workspace:FindPartOnRayWithIgnoreList(NewRay, NewIgnore)
	local LastPos = HitPos
	local FinalHitObj, FinalHitPos = nil, nil
	local RepTimes = math.floor(Dist / 999)
	if (not HitObj) and (Dist > 999) then
		for i = 0, RepTimes do
			local NewDist = (i == RepTimes and  (Dist - (LastPos - Origin).magnitude) or 999)
			local Ray2 = Ray.new(LastPos, Direction * NewDist)
			local HitObj2, HitPos2 = game.Workspace:FindPartOnRayWithIgnoreList(Ray2, NewIgnore)
			if i ~= RepTimes then
				if HitObj2 then
					FinalHitObj, FinalHitPos = HitObj2, HitPos2
					break
				end
			elseif i == RepTimes then
				FinalHitObj, FinalHitPos = HitObj2, HitPos2
			end
			LastPos = HitPos2
		end
		return FinalHitObj, FinalHitPos
	elseif HitObj or (Dist <= 999) then
		return HitObj, HitPos
	end
end

--------------------[ JUMPING ANIMATION ]---------------------------------------------

function onFall(initialVelocity)
	spawn(function()
		local velocityAlpha = math.max(math.min(initialVelocity / Humanoid.JumpPower, 1), 0)
		local startJumpPos = jumpAnim.Pos
		local startJumpRot = jumpAnim.Rot
		local endJumpPos = 0.04 * S.fallSettings.fallMultiplier * velocityAlpha
		local endJumpRot = RAD(4) * S.fallSettings.fallMultiplier * velocityAlpha
		local t0 = tick()
		while true do
			RS.Heartbeat:wait()
			local Alpha = math.min((tick() - t0) / 0.15, 1) * 90
			if onGround then break end
			jumpAnim.Pos = numLerp(startJumpPos, endJumpPos, Sine(Alpha))
			jumpAnim.Rot = numLerp(startJumpRot, endJumpRot, Sine(Alpha))
			if Alpha == 90 then break end
		end
		startJumpPos = endJumpPos
		startJumpRot = endJumpRot
		endJumpPos = -0.08 * S.fallSettings.fallMultiplier
		endJumpRot = -RAD(8) * S.fallSettings.fallMultiplier
		local X = 1
		while true do
			local dt = RS.Heartbeat:wait()
			X = X + (dt * 60) / X
			local Alpha = (X - 1) / 15
			if onGround then break end
			jumpAnim.Pos = numLerp(startJumpPos, endJumpPos, Alpha)
			jumpAnim.Rot = numLerp(startJumpRot, endJumpRot, Alpha)
		end
	end)
end

function onLand(fallDist)
	spawn(function()
		local animAlpha = math.min(fallDist, S.fallSettings.maxDist) * (2 / 3)
		local startJumpPos = jumpAnim.Pos
		local startJumpRot = jumpAnim.Rot
		local endJumpPos = animAlpha / 100 * S.fallSettings.landMultiplier * (runReady and 1 or 2)
		local endJumpRot = RAD(animAlpha) * S.fallSettings.landMultiplier * (runReady and 1 or 2)
		local t0 = tick()
		while true do
			RS.Heartbeat:wait()
			local Alpha = math.min((tick() - t0) / 0.2, 1)
			if (not onGround) then break end
			jumpAnim.Pos = numLerp(startJumpPos, endJumpPos, Alpha)
			jumpAnim.Rot = numLerp(startJumpRot, endJumpRot, Alpha)
			if Alpha == 1 then break end
		end
		t0 = tick()
		while true do
			RS.Heartbeat:wait()
			local Alpha = math.min((tick() - t0) / 0.3, 1) * 90
			if (not onGround) then break end
			jumpAnim.Pos = numLerp(endJumpPos, 0, Sine(Alpha))
			jumpAnim.Rot = numLerp(endJumpRot, 0, Sine(Alpha))
			if Alpha == 90 then break end
		end
	end)
end

function onHumanoidStateChanged(oldState, newState)
	if newState == Enum.HumanoidStateType.Freefall then
		onGround = false
		if S.fallAnimation then
			onFall(HRP.Velocity.Y)
			while HRP.Velocity.Y > 0 do RS.RenderStepped:wait() end
			startFallHeight = HRP.Position.Y
		end
	elseif oldState == Enum.HumanoidStateType.Freefall then
		onGround = true
		if S.fallAnimation then
			local fallDist = startFallHeight - HRP.Position.Y
			onLand(fallDist)
		end
	end
end
--------------------[ CAMERA STEADYING FUNCTIONS ]------------------------------------

function steadyCamera()
	scopeSteady.Text = "Steadying..."
	scopeSteady.TextColor3 = Color3.new(1, 1, 0)
	camSteady = true
	local originalSway = camSway
	local Increment = 1.5 / 0.6
	local X = 0
	while true do
		RS.RenderStepped:wait()
		local newX = X + Increment
		X = (newX > 90 and 90 or newX)
		if (not steadyKeyPressed) then break end
		camSway = numLerp(originalSway, 0, Sine(X))
		if X == 90 then break end
	end
	while steadyKeyPressed and Aimed do
		if currentSteadyTime > 0 then
			local NewSteadyTime = currentSteadyTime - 1
			currentSteadyTime = (NewSteadyTime < 0 and 0 or NewSteadyTime)
			camSway = 0
		elseif currentSteadyTime == 0 then
			break
		end
		RS.RenderStepped:wait()
	end
	camSteady = false
	spawn(function()
		local Increment = 1.5 / 0.25
		local X = 0
		while true do
			RS.RenderStepped:wait()
			local newX = X + Increment
			X = (newX > 90 and 90 or newX)
			if camSteady then break end
			camSway = numLerp(0, S.scopeSettings.camSwayOnBreath, 1 - COS(RAD(X)))
			if X == 90 then break end
		end
		Increment = 1.5 / S.scopeSettings.breathTime
		X = 0
		while true do
			RS.RenderStepped:wait()
			local newX = X + Increment
			X = (newX > 90 and 90 or newX)
			if camSteady then break end
			camSway = numLerp(S.scopeSettings.camSwayOnBreath, 1, Sine(X))
			if X == 90 then break end
		end
		--[[for X = 0, 90, 1.5 / 0.2 do
			local Alpha = 1 - COS(RAD(X))--math.log10(X) / math.log10(90)
			camSway = numLerp(0, 3, Alpha)
			RS.RenderStepped:wait()
		end]]
		--[[for X = 0, 90, 1.5 / S.scopeSettings.steadyTime do
			if camSteady then break end
			local Alpha = SIN(RAD(X))
			camSway = numLerp(3, 1, Alpha)
			RS.RenderStepped:wait()
		end]]
	end)
	retakeBreath()
end

function retakeBreath()
	scopeSteady.Text = "Re-taking Breath"
	scopeSteady.TextColor3 = Color3.new(1, 0, 0)
	takingBreath = true
	local Increment = S.scopeSettings.steadyTime / S.scopeSettings.breathTime
	while takingBreath do
		if currentSteadyTime < maxSteadyTime then
			local newSteadyTime = currentSteadyTime + Increment
			currentSteadyTime = (newSteadyTime > maxSteadyTime and maxSteadyTime or newSteadyTime)
		elseif currentSteadyTime >= maxSteadyTime then
			break
		end
		RS.RenderStepped:wait()
	end
	if takingBreath then
		scopeSteady.Text = "Hold "..convertKey(S.Keys.scopeSteady).." to Steady"
		scopeSteady.TextColor3 = Color3.new(1, 1, 0)
		takingBreath = false
	end
end

--------------------[ SPRINTING FUNCTIONS ]-------------------------------------------

function canRun(midRun)
	return ((Forward and (not Backward)) and
		Walking and (Stamina > 0) and Running and
		Selected and (midRun and true or onGround) and
		runReady and (S.canFireWhileRunning and true or (not Firing))
	)
end

function monitorStamina()
	Running = true
	if (not canRun(false)) then
		Running = false
		return
	end
	if Aimed then unAimGun(true) end
	if Stance == 1 or Stance == 2 then Stand() end
	if (not (Reloading and S.reloadSettings.Anim)) then
		if S.canFireWhileRunning then
			tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, 0.4)
			tweenJoint(RWeld, armC0[2], S.unAimedC1.rightArm, Sine, 0.4)
			tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, 0.4)
		else
			tweenJoint(LWeld, armC0[1], S.runningC1.leftArm, Sine, 0.4)
			tweenJoint(RWeld, armC0[2], S.runningC1.rightArm, Sine, 0.4)
			tweenJoint(Grip, nil, S.runningC1.Grip, Sine, 0.4)
		end
	end
	crossOffset = 50
	while runKeyPressed do
		if canRun(true) then
			if onGround then
				local newStamina = Stamina - 1
				Stamina = (newStamina < 0 and 0 or newStamina)
			end
		else
			break
		end
		RS.RenderStepped:wait()
	end
	Running = false
	if (not Aimed) and (not (Reloading and S.reloadSettings.Anim)) and (not S.canFireWhileRunning) then
		crossOffset = 0
		tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, 0.4)
		tweenJoint(RWeld, armC0[2], S.unAimedC1.rightArm, Sine, 0.4)
		tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, 0.4)
	end
	
	rechargeStamina()
end

function rechargeStamina()
	chargingStamina = true
	while ((not runKeyPressed) or (Stamina < maxStamina)) and (not Running) do
		if Stamina < maxStamina then
			local newStamina = Stamina + (S.sprintTime / S.staminaCoolTime)
			Stamina = (newStamina > maxStamina and maxStamina or newStamina)
		elseif Stamina >= maxStamina then
			break
		end
		RS.RenderStepped:wait()
	end
	chargingStamina = false
end

--------------------[ STANCE FUNCTIONS ]----------------------------------------------

function Stand(onDeselected)
	local LHip = Torso["Left Hip"]
	local RHip = Torso["Right Hip"]
	LLegWeld.Part1 = nil
	LHip.Part1 = LLeg
	RLegWeld.Part1 = nil
	RHip.Part1 = RLeg
	Stance = 0
	spreadStance = "Stand"
	baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	if S.stanceSettings.Anim and (not onDeselected) then
		spawn(function()
			local prevStanceSway = stanceSway
			local X = 0
			local Increment = 1.5 / S.stanceSettings.Speed
			while true do
				RS.RenderStepped:wait()
				local newX = X + Increment
				X = (newX > 90 and 90 or newX)
				if Stance ~= 0 then break end
				stanceSway = numLerp(prevStanceSway, 1, Sine(X))
				if X == 90 then break end
			end
		end)
		tweenJoint(ABWeld, CF(), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LLegWeld, legC0.Stand[1], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(RLegWeld, legC0.Stand[2], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LHip, CF(-1, -1, 0) * CFANG(0, RAD(-90), 0), CF(-0.5, 1, 0) * CFANG(0, RAD(-90), 0), Sine, S.stanceSettings.Speed)
		tweenJoint(RHip, CF(1, -1, 0) * CFANG(RAD(-180), RAD(90), 0), CF(0.5, 1, 0) * CFANG(RAD(-180), RAD(90), 0), Sine, S.stanceSettings.Speed)
		tweenJoint(Root, CFANG(RAD(-90), 0, RAD(180)), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(headWeld, CF(0, 1.5, 0), nil, Sine, S.stanceSettings.Speed)
	elseif onDeselected or (not S.stanceSettings.Anim) then
		ABWeld.C0 = CF()
		LLegWeld.C0 = legC0.Stand[1]
		RLegWeld.C0 = legC0.Stand[2]
		LHip.C0, LHip.C1 = CF(-1, -1, 0) * CFANG(0, RAD(-90), 0), CF(-0.5, 1, 0) * CFANG(0, RAD(-90), 0)
		RHip.C0, RHip.C1 = CF(1, -1, 0) * CFANG(RAD(-180), RAD(90), 0), CF(0.5, 1, 0) * CFANG(RAD(-180), RAD(90), 0)
		Root.C0 = CFANG(RAD(-90), 0, RAD(180))
		headWeld.C0 = CF(0, 1.5, 0)
	end
end

function Crouch()
	local LHip = Torso["Left Hip"]
	local RHip = Torso["Right Hip"]
	LHip.Part1 = nil
	LLegWeld.Part1 = LLeg
	RHip.Part1 = nil
	RLegWeld.Part1 = RLeg
	Stance = 1
	spreadStance = "Crouch"
	baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	if S.stanceSettings.Anim then
		spawn(function()
			local prevStanceSway = stanceSway
			local X = 0
			local Increment = 1.5 / S.stanceSettings.Speed
			while true do
				RS.RenderStepped:wait()
				local newX = X + Increment
				X = (newX > 90 and 90 or newX)
				if Stance ~= 1 then break end
				stanceSway = numLerp(prevStanceSway, 0.75, Sine(X))
				if X == 90 then break end
			end
		end)
		tweenJoint(ABWeld, CF(0, 0, -0.05), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LLegWeld, legC0.Crouch[1], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(RLegWeld, legC0.Crouch[2], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LHip, CF(-1, -0.5, 0) * CFANG(0, RAD(-90), 0), CF(-0.5, 0.5, 1) * CFANG(0, RAD(-90), RAD(-90)), Sine, S.stanceSettings.Speed)
		tweenJoint(RHip, CF(1, -0.5, 0.25) * CFANG(RAD(-180), RAD(90), 0), CF(0.5, 0.5, 1) * CFANG(RAD(-180), RAD(90), 0), Sine, S.stanceSettings.Speed)
		tweenJoint(Root, CF(0, -1, 0) * CFANG(RAD(-90), 0, RAD(180)), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(headWeld, CF(0, 1.5, 0), nil, Sine, S.stanceSettings.Speed)
	else
		ABWeld.C0 = CF(0, 0, -1 / 16)
		LLegWeld.C0 = legC0.Crouch[1]
		RLegWeld.C0 = legC0.Crouch[2]
		LHip.C0, LHip.C1 = CF(-1, -0.5, 0) * CFANG(0, RAD(-90), 0), CF(-0.5, 0.5, 1) * CFANG(0, RAD(-90), RAD(-90))
		RHip.C0, RHip.C1 = CF(1, -0.5, 0.25) * CFANG(RAD(-180), RAD(90), 0), CF(0.5, 0.5, 1) * CFANG(RAD(-180), RAD(90), 0)
		Root.C0 = CF(0, -1, 0) * CFANG(RAD(-90), 0, RAD(180))
		headWeld.C0 = CF(0, 1.5, 0)
	end
end

function Prone()
	local LHip = Torso["Left Hip"]
	local RHip = Torso["Right Hip"]
	LHip.Part1 = nil
	LLegWeld.Part1 = LLeg
	RHip.Part1 = nil
	RLegWeld.Part1 = RLeg
	Stance = 2
	spreadStance = "Prone"
	baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	if S.stanceSettings.Anim then
		spawn(function()
			local prevStanceSway = stanceSway
			local X = 0
			local Increment = 1.5 / S.stanceSettings.Speed
			while true do
				RS.RenderStepped:wait()
				local newX = X + Increment
				X = (newX > 90 and 90 or newX)
				if Stance ~= 2 then break end
				stanceSway = numLerp(prevStanceSway, 0.5, Sine(X))
				if X == 90 then break end
			end
		end)
		tweenJoint(ABWeld, CF(0, 0, -0.1), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(LLegWeld, legC0.Prone[1], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(RLegWeld, legC0.Prone[2], nil, Sine, S.stanceSettings.Speed)
		tweenJoint(Root, CF(0, -2.5, 1) * CFANG(RAD(180), 0, RAD(180)), nil, Sine, S.stanceSettings.Speed)
		tweenJoint(headWeld, CF(0, 1, 1) * CFANG(RAD(90), 0, 0), nil, Sine, S.stanceSettings.Speed)
	else
		ABWeld.C0 = CF(0, 0, -1 / 8)
		LLegWeld.C0 = legC0.Prone[1]
		RLegWeld.C0 = legC0.Prone[2]
		Root.C0 = CF(0, -2.5, 1) * CFANG(RAD(180), 0, RAD(180))
		headWeld.C0 = CF(0, 1, 1) * CFANG(RAD(90), 0, 0)
	end
end

function Dive()
	onGround = false
	local diveDirection = (HRP.CFrame * CFANG(S.diveSettings.Angle, 0, 0)).lookVector * S.walkSpeeds.Sprinting * S.diveSettings.Force
	local BF = Instance.new("BodyForce")
	BF.force = diveDirection + Vector3.new(0, playerMass * 196.2, 0)
	BF.Parent = HRP
	--[[spawn(function()
		HRP.Velocity = HRP.CFrame.lookVector * 60 + V3(0, 40, 0)
		wait(0.1)
		HRP.Velocity = HRP.CFrame.lookVector * 70 + V3(0, 30, 0)
		wait(0.4)
		HRP.Velocity = HRP.CFrame.lookVector * 30 + V3(0, -10, 0)
	end)]]
	delay(0.05, function()
		spawn(function()
			while true do
				local newRay = Ray.new(HRP.Position, V3(0, -3.1, 0))
				local H, _ = workspace:FindPartOnRayWithIgnoreList(newRay, Ignore)
				if H then
					onGround = true
					break
				end
				wait()
			end
		end)
		Prone()
		wait(0.1)
		BF:Destroy()
	end)
end

--------------------[ MOUSE FUNCTIONS ]-----------------------------------------------

function onMB1Down()
	MB1Down = true
	firstShot = true
	if fireFunction then
		fireFunction()
	end
end

function onMB1Up()
	MB1Down = false
	lowerSpread()
end

function onMB2Down()
	if S.aimSettings.holdToADS then
		if (not AimingIn) and (not Aimed) then
			AimingIn = true
			aimGun()
			AimingIn = false
		end
	else
		if Aimed then
			unAimGun()
		else
			aimGun()
		end
	end
end

function onMB2Up()
	if S.aimSettings.holdToADS then
		if (not AimingOut) and Aimed then
			AimingOut = true
			unAimGun()
			AimingOut = false
		end
	end
end

function onScrollUp()
	local newAimSensitivity = aimSensitivity + S.sensitivitySettings.Increment
	aimSensitivity = (
		newAimSensitivity < S.sensitivitySettings.Min and S.sensitivitySettings.Min or
		newAimSensitivity > S.sensitivitySettings.Max and S.sensitivitySettings.Max or
		newAimSensitivity
	)
	mouseSensitivity = (Aimed and aimSensitivity or mouseSensitivity)
	
	Sens.Text = "S: "..aimSensitivity
	if mainGUI:IsDescendantOf(game) then
		Sens.Visible = true
		local t0 = tick()
		lastSensUpdate = t0
		
		wait(0.3)
		
		if lastSensUpdate <= t0 then
			Sens.Visible = false
		end
	end
end

function onScrollDown()
	local newAimSensitivity = aimSensitivity - S.sensitivitySettings.Increment
	aimSensitivity = (
		newAimSensitivity < S.sensitivitySettings.Min and S.sensitivitySettings.Min or
		newAimSensitivity > S.sensitivitySettings.Max and S.sensitivitySettings.Max or
		newAimSensitivity
	)
	mouseSensitivity = (Aimed and aimSensitivity or mouseSensitivity)
	
	Sens.Text = "S: "..aimSensitivity
	if mainGUI:IsDescendantOf(game) then
		Sens.Visible = true
		local t0 = tick()
		lastSensUpdate = t0
		
		wait(0.3)
		
		if lastSensUpdate <= t0 then
			Sens.Visible = false
		end
	end
end

--------------------[ KEYBOARD FUNCTIONS ]--------------------------------------------

function keyDown(K)
	local Key = string.lower(K)
	
	if Key == S.Keys.lowerStance and S.canChangeStance then
		if (not Running) then
			if Stance == 0 then
				if S.stanceSettings.Stances.Crouch then
					Crouch()
				elseif S.stanceSettings.Stances.Prone then
					Prone()
				end
			elseif Stance == 1 then
				if S.stanceSettings.Stances.Prone then
					Prone()
				end
			end
		elseif S.dolphinDive then
			wait()
			if Humanoid:GetState() ~= Enum.HumanoidStateType.Freefall and (not UIS:IsKeyDown("Space")) and runReady then
				local tempConnection = Humanoid.Changed:connect(function()
					Humanoid.Jump = false
				end)
				runReady = false
				Dive()
				Running = false
				wait(S.diveSettings.rechargeTime)
				tempConnection:disconnect()
				runReady = true
			end
		end
	end
	
	if Key == S.Keys.raiseStance and S.canChangeStance then
		if (not Running) then
			if Stance == 2 then
				if S.stanceSettings.Stances.Crouch then
					Crouch()
				else
					Stand()
				end
			elseif Stance == 1 then
				Stand()
			end
		end
	end
	
	if Key == S.Keys.ADS then
		if S.aimSettings.holdToADS then
			if (not AimingIn) and (not Aimed) then
				AimingIn = true
				aimGun()
				AimingIn = false
			end
		else
			if Aimed then
				unAimGun()
			else
				aimGun()
			end
		end
	end
	
	if Key == S.Keys.selectFire and S.selectFire then
		if canSelectFire then
			canSelectFire = false
			rawFireMode = rawFireMode + 1
			modeGUI.Text = Modes[((rawFireMode - 1) % numModes) + 1]
			if modeGUI.Text == "AUTO" then
				fireFunction = autoFire
			elseif modeGUI.Text == "BURST" then
				fireFunction = burstFire
			elseif modeGUI.Text == "SEMI" then
				fireFunction = semiFire
			else
				fireFunction = nil
			end
			local speedAlpha = S.selectFireSettings.animSpeed / 0.6
			if S.selectFireSettings.GUI then
				spawn(function()
					fireSelect.Visible = true
					local prevRawFireMode = rawFireMode
					local Increment = 1.5 / (speedAlpha * 0.25)
					local X = 0
					wait(speedAlpha * 0.1)
					while true do
						RS.RenderStepped:wait()
						local newX = X + Increment
						X = (newX > 90 and 90 or newX)
						if prevRawFireMode ~= rawFireMode then break end
						updateModeLabels(rawFireMode - 1, rawFireMode, X)
						if X == 90 then break end
					end
					wait(speedAlpha * 0.25)
					fireSelect.Visible = false
				end)
			end
			if S.selectFireSettings.Animation and (not Aimed) and (not isRunning) and (not isCrawling) then
				spawn(function()
					local sequenceTable = {
						function()
							tweenJoint(RWeld2, nil, CFANG(0, RAD(5), 0), Sine, speedAlpha * 0.15)
							tweenJoint(LWeld, armC0[1], CF(0.1, 1, -0.3) * CFANG(RAD(-7), 0, RAD(-65)), Linear, speedAlpha * 0.15)
							wait(speedAlpha * 0.2)
						end;
						
						function()
							tweenJoint(LWeld, armC0[1], CF(0.1, 1, -0.3) * CFANG(RAD(-10), 0, RAD(-65)), Linear, speedAlpha * 0.1)
							wait(speedAlpha * 0.2)
						end;
						
						function()
							tweenJoint(RWeld2, nil, CF(), Sine, speedAlpha * 0.2)
							tweenJoint(LWeld, armC0[1], S.unAimedC1.leftArm, Sine, speedAlpha * 0.2)
							wait(speedAlpha * 0.2)
						end;
					}
					
					for _, F in pairs(sequenceTable) do
						if Aimed or isRunning or isCrawling or Reloading then
							break
						end
						F()
					end
				end)
			end
			if S.selectFireSettings.Animation or S.selectFireSettings.GUI then
				wait(S.selectFireSettings.animSpeed)
			end
			canSelectFire = true
		end
	end
	
	if Key == S.Keys.Reload then
		if (not Reloading) and (not isCrawling) then
			Reload()
		end
	end
	
	if Key == S.Keys.Sprint then
		runKeyPressed = true
		if runReady then
			if (not Idling) and Walking and (not Running) and (not Knifing) and (not (Aimed and S.guiScope and S.Keys.Sprint == S.Keys.scopeSteady)) then
				monitorStamina()
			end
		end
	end
	
	if Key == S.Keys.scopeSteady then
		steadyKeyPressed = true
		if Aimed and (not Aiming) then
			takingBreath = false
			steadyCamera()
		end
	end
	
	for _, PTable in pairs(Plugins.KeyDown) do
		if Key == string.lower(PTable.Key) then
			spawn(function()
				PTable.Plugin()
			end)
		end
	end
end

function keyUp(K)
	local Key = string.lower(K)
	
	if Key == S.Keys.ADS then
		if S.aimSettings.holdToADS then
			if (not AimingOut) and Aimed then
				AimingOut = true
				unAimGun()
				AimingOut = false
			end
		end
	end
	
	if Key == S.Keys.Sprint then
		runKeyPressed = false
		Running = false
		if (not chargingStamina) then
			rechargeStamina()
		end
	end
	
	if Key == S.Keys.scopeSteady then
		steadyKeyPressed = false
	end
	
	for _, PTable in pairs(Plugins.KeyUp) do
		if Key == string.lower(PTable.Key) then
			spawn(function()
				PTable.Plugin()
			end)
		end
	end
end

--------------------[ END FUNCTIONS ]-------------------------------------------------

--------------------------------------------------------------------------------------
--------------------[ PRE-CONNECTIONS ]-----------------------------------------------
--------------------------------------------------------------------------------------

local function updateAnimVars()
	wait()
	Forward = (UIS:IsKeyDown("W") or UIS:IsKeyDown("Up"))
	Backward = (UIS:IsKeyDown("S") or UIS:IsKeyDown("Down"))
	local Right = UIS:IsKeyDown("D")
	local Left = UIS:IsKeyDown("A")
	
	local walkingForward = (Forward and (not Backward))
	local walkingBackward = ((not Forward) and Backward)
	local walkingRight = (Right and (not Left))
	local walkingLeft = ((not Right) and Left)
	
	if (Forward or Backward or Right or Left) then
		Walking, Idling = true, false
		if (not Running) and (not Aimed) then
			spreadMotion = "Moving"
			baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
		end
	elseif (not (Forward and Backward and Right and Left)) then
		Walking, Idling = false, true
		if (not Aimed) then
			spreadMotion = "Idling"
			baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
		end
	end
	
	local newArmTilt = (
		((walkingForward or walkingBackward) and walkingRight) and 2.5 or
		((walkingForward or walkingBackward) and walkingLeft) and -2.5 or
		((not (walkingForward and walkingBackward)) and walkingRight) and 5 or
		((not (walkingForward and walkingBackward)) and walkingLeft) and -5 or 0
	)
	local newMoveAng = (
		(walkingForward and (not (walkingRight or walkingLeft))) and 0 or
		(walkingForward and walkingRight) and RAD(-45) or
		((not (walkingForward or walkingBackward)) and walkingRight) and RAD(-90) or
		(walkingBackward and walkingRight) and RAD(-135) or
		(walkingBackward and (not (walkingRight or walkingLeft))) and (moveAng < 0 and RAD(-180) or RAD(180)) or
		(walkingBackward and walkingLeft) and RAD(135) or
		((not (walkingForward or walkingBackward)) and walkingLeft) and RAD(90) or
		(walkingForward and walkingLeft) and RAD(45) or 0
	)
	
	local newAnimCode = math.random(-1e9, 1e9)
	animCode = newAnimCode
	local startTilt = armTilt
	local startAng = (ABS(moveAng) == RAD(180)) and (newMoveAng > 0 and RAD(180) or RAD(-180)) or moveAng
	local Increment = (startTilt == newArmTilt and 1.5 / 0.7 or 1.5 / (0.35 * ABS(startTilt - newArmTilt) / 5))
	local X = 0
	while true do
		RS.RenderStepped:wait()
		local newX = X + Increment
		X = (newX > 90 and 90 or newX)
		if animCode ~= newAnimCode then break end
		armTilt = numLerp(startTilt, newArmTilt, Sine(X))
		moveAng = numLerp(startAng, newMoveAng, Sine(X))
		if X == 90 then break end
	end
end

M2.KeyDown:connect(updateAnimVars)
M2.KeyUp:connect(updateAnimVars)
updateAnimVars()

--------------------------------------------------------------------------------------
--------------------[ TOOL SELECTION AND DESELECTION ]--------------------------------
--------------------------------------------------------------------------------------

function onEquipped()
	wait()
	if Humanoid.Health ~= 0 and (not Selected) and Gun.Parent == Char then
		Selected = true
		breakReload = false
		equipAnimPlaying = true
		
		math.randomseed(tick()) --This sets a new seed for the random function each time you select the gun
		
		--------------------[ FAILSAFE RESETING ]-------------------------------------
		
		for _, GM in pairs(ignoreModel:GetChildren()) do
			if GM.Name == "gunIgnore_"..Player.Name then
				GM:Destroy()
			end
		end
		
		for _, c in pairs(Connections) do
			c:disconnect()
		end
		
		Connections = {}
		
		--------------------[ REMOTE GUN SETUP ]--------------------------------------
		
		--[[local Vars = {
			ignoreModel = ignoreModel;
			Humanoid = Humanoid;
			Shoulders = Shoulders;
			Torso = Torso;
			Head = Head;
			armC0 = armC0;
			leftArmC1 = S.equipSettings.leftArmC1;
			rightArmC1 = S.equipSettings.rightArmC1;
			LArm = LArm;
			RArm = RArm;
			gunParts = gunParts;
			Handle = Handle;
		}
		gunIgnore, playerFolder, headWeld, headWeld2, animWeld, ABWeld, LWeld, RWeld, LWeld2, RWeld2, LLegWeld, RLegWeld, gunParts2 = gunSetup:InvokeServer(Vars)]]
		
		--------------------[ CREATING IGNORE MODELS ]--------------------------------
		
		gunIgnore = Instance.new("Model")
		gunIgnore.Name = "gunIgnore_"..Player.Name
		gunIgnore.Parent = ignoreModel
		
		--------------------[ MODIFYING THE PLAYER ]----------------------------------
		
		Player.CameraMode = Enum.CameraMode.LockFirstPerson
		Cam.CameraType = Enum.CameraType.Scriptable
		Cam.FieldOfView = 80
		UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
		UIS.MouseIconEnabled = false
		
		local initialX, initialY = getYawPitch(Cam.CoordinateFrame)
		camAng = -VEC2(initialX, initialY)
		
		mainGUI.Parent = Player.PlayerGui
		
		setUpGUI()
		updateHealth()
		
		if S.selectFire then
			local currentMode = Modes[((rawFireMode - 1) % numModes) + 1]
			if currentMode == "AUTO" then
				fireFunction = autoFire
			elseif currentMode == "BURST" then
				fireFunction = burstFire
			elseif currentMode == "SEMI" then
				fireFunction = semiFire
			else
				fireFunction = nil
			end
		else
			if S.gunType.Semi then
				fireFunction = semiFire
			elseif S.gunType.Auto then
				fireFunction = autoFire
			elseif S.gunType.Burst then
				fireFunction = burstFire
			else
				fireFunction = nil
			end
		end
		
		changePlayerTrans(Char, 1)
		
		Humanoid.AutoRotate = false
		
		Shoulders.Right.Part1 = nil
		Shoulders.Left.Part1 = nil

		playerFolder = Instance.new("Model")
		playerFolder.Name = "playerFolder"
		playerFolder.Parent = gunIgnore
		
		local headBase = Instance.new("Part")
		headBase.Transparency = 1
		headBase.Name = "headBase"
		headBase.CanCollide = false
		headBase.FormFactor = Enum.FormFactor.Custom
		headBase.Size = V3(0.2, 0.2, 0.2)
		headBase.BottomSurface = Enum.SurfaceType.Smooth
		headBase.TopSurface = Enum.SurfaceType.Smooth
		headBase.Parent = playerFolder
		
		headWeld = Instance.new("Weld")
		headWeld.Part0 = Torso
		headWeld.Part1 = headBase
		headWeld.C0 = CF(0, 1.5, 0)
		headWeld.Parent = Torso
		
		headWeld2 = Instance.new("Weld")
		headWeld2.Part0 = headBase
		headWeld2.Part1 = Head
		headWeld2.Parent = headBase
		
		neckClone = Neck:Clone()
		
		--[[local stanceBase = Instance.new("Part")
		stanceBase.Transparency = 1
		stanceBase.Name = "stanceBase"
		stanceBase.CanCollide = false
		stanceBase.FormFactor = Enum.FormFactor.Custom
		stanceBase.Size = V3(0.2, 0.2, 0.2)
		stanceBase.BottomSurface = Enum.SurfaceType.Smooth
		stanceBase.TopSurface = Enum.SurfaceType.Smooth
		stanceBase.Parent = playerFolder
		
		stanceWeld = Instance.new("Weld")
		stanceWeld.Part0 = stanceBase
		stanceWeld.Part1 = Torso
		stanceWeld.Parent = stanceBase]]
		
		local animBase = Instance.new("Part")
		animBase.Transparency = 1
		animBase.Name = "animBase"
		animBase.CanCollide = false
		animBase.FormFactor = Enum.FormFactor.Custom
		animBase.Size = V3(0.2, 0.2, 0.2)
		animBase.BottomSurface = Enum.SurfaceType.Smooth
		animBase.TopSurface = Enum.SurfaceType.Smooth
		animBase.Parent = playerFolder
		
		animWeld = Instance.new("Weld")
		animWeld.Part0 = animBase
		animWeld.Part1 = headBase
		animWeld.Parent = animBase
		
		local ArmBase = Instance.new("Part")
		ArmBase.Transparency = 1
		ArmBase.Name = "ArmBase"
		ArmBase.CanCollide = false
		ArmBase.FormFactor = Enum.FormFactor.Custom
		ArmBase.Size = V3(0.2, 0.2, 0.2)
		ArmBase.BottomSurface = Enum.SurfaceType.Smooth
		ArmBase.TopSurface = Enum.SurfaceType.Smooth
		ArmBase.Parent = playerFolder
		
		ABWeld = Instance.new("Weld")
		ABWeld.Part0 = ArmBase
		ABWeld.Part1 = animBase
		ABWeld.Parent = ArmBase
		
		local LArmBase = Instance.new("Part")
		LArmBase.Transparency = 1
		LArmBase.Name = "LArmBase"
		LArmBase.CanCollide = false
		LArmBase.FormFactor = Enum.FormFactor.Custom
		LArmBase.Size = V3(0.2, 0.2, 0.2)
		LArmBase.BottomSurface = Enum.SurfaceType.Smooth
		LArmBase.TopSurface = Enum.SurfaceType.Smooth
		LArmBase.Parent = playerFolder
		
		local RArmBase = Instance.new("Part")
		RArmBase.Transparency = 1
		RArmBase.Name = "RArmBase"
		RArmBase.CanCollide = false
		RArmBase.FormFactor = Enum.FormFactor.Custom
		RArmBase.Size = V3(0.2, 0.2, 0.2)
		RArmBase.BottomSurface = Enum.SurfaceType.Smooth
		RArmBase.TopSurface = Enum.SurfaceType.Smooth
		RArmBase.Parent = playerFolder
		
		LWeld = Instance.new("Weld")
		LWeld.Name = "LWeld"
		LWeld.Part0 = ArmBase
		LWeld.Part1 = LArmBase
		LWeld.C0 = armC0[1]
		LWeld.C1 = S.equipSettings.leftArmC1
		LWeld.Parent = ArmBase
		
		RWeld = Instance.new("Weld")
		RWeld.Name = "RWeld"
		RWeld.Part0 = ArmBase
		RWeld.Part1 = RArmBase
		RWeld.C0 = armC0[2]
		RWeld.C1 = S.equipSettings.rightArmC1
		RWeld.Parent = ArmBase
		
		LWeld2 = Instance.new("Weld")
		LWeld2.Name = "LWeld"
		LWeld2.Part0 = LArmBase
		LWeld2.Part1 = LArm
		LWeld2.Parent = LArmBase
		
		RWeld2 = Instance.new("Weld")
		RWeld2.Name = "RWeld"
		RWeld2.Part0 = RArmBase
		RWeld2.Part1 = RArm
		RWeld2.Parent = RArmBase
		
		LLegWeld = Instance.new("Weld")
		LLegWeld.Name = "LLegWeld"
		LLegWeld.Part0 = Torso
		LLegWeld.Part1 = nil
		LLegWeld.C0 = CF(-0.5, -2, 0)
		LLegWeld.Parent = Torso
		
		RLegWeld = Instance.new("Weld")
		RLegWeld.Name = "RLegWeld"
		RLegWeld.Part0 = Torso
		RLegWeld.Part1 = nil
		RLegWeld.C0 = CF(0.5, -2, 0)
		RLegWeld.Parent = Torso
		
		if S.playerArms then
			armModel = Instance.new("Model", workspace.FilteringEnabled and playerFolder or Cam)
			
			fakeLArm = LArm:Clone()
			fakeLArm.Parent = armModel
			fakeLArm.Transparency = S.fakeArmSettings.Transparency
			fakeLArm.CanCollide = false
			fakeLArm.Size = S.fakeArmSettings.armSize
			fakeLArm:BreakJoints()
			
			--LArm.Transparency = 1
			
			local fakeLWeld = Instance.new("Weld")
			fakeLWeld.Part0 = fakeLArm
			fakeLWeld.Part1 = LArm
			fakeLWeld.Parent = fakeLArm
			
			fakeRArm = RArm:Clone()
			fakeRArm.Parent = armModel
			fakeRArm.Transparency = S.fakeArmSettings.Transparency
			fakeRArm.CanCollide = false
			fakeRArm.Size = S.fakeArmSettings.armSize
			fakeRArm:BreakJoints()
			
			--RArm.Transparency = 1
			
			local fakeRWeld = Instance.new("Weld")
			fakeRWeld.Part0 = fakeRArm
			fakeRWeld.Part1 = RArm
			fakeRWeld.Parent = fakeRArm
			
			Instance.new("Humanoid", armModel)
			
			if S.fakeArmSettings.characterMeshes then
				for _,Obj in pairs(Char:GetChildren()) do
					if Obj:IsA("CharacterMesh") then
						Obj:Clone().Parent = armModel
					end
				end
			end
			for _,Obj in pairs(Char:GetChildren()) do
				if Obj:IsA("Shirt") then
					Obj:Clone().Parent = armModel
				end
			end
		else
			armTable = createArms()
			if workspace.FilteringEnabled then
				armTable[1].Model.Parent = playerFolder
				armTable[2].Model.Parent = playerFolder
			else
				armTable[1].Model.Parent = Cam--playerFolder
				armTable[2].Model.Parent = Cam--playerFolder
			end
			
			fakeLArm = armTable[1].armPart
			
			--LArm.Transparency = 1
			
			local fakeLWeld = Instance.new("Weld")
			fakeLWeld.Part0 = fakeLArm
			fakeLWeld.Part1 = LArm
			fakeLWeld.Parent = fakeLArm
			
			fakeRArm = armTable[2].armPart
			
			--RArm.Transparency = 1
			
			local fakeRWeld = Instance.new("Weld")
			fakeRWeld.Part0 = fakeRArm
			fakeRWeld.Part1 = RArm
			fakeRWeld.Parent = fakeRArm
		end
		
		--------------------[ MODIFYING THE GUN ]-------------------------------------
		
		for _, Tab in pairs(gunParts) do
			local Weld = Instance.new("Weld")
			Weld.Name = "MainWeld"
			Weld.Part0 = Handle
			Weld.Part1 = Tab.Obj
			Weld.C0 = Tab.Obj.weldCF.Value
			Weld.Parent = Handle
			Tab.Weld = Weld
		end
		
		Grip = RArm:WaitForChild("RightGrip")
		
		local handleCF = Torso.CFrame * CF(0, 0.5, 0) * armC0[2] * S.aimedC1.rightArm:inverse() * Grip.C0
		local handleOffset = AimPart.CFrame:toObjectSpace(Handle.CFrame)
		aimedGripCF = ((Torso.CFrame * CF(headOffset.X, headOffset.Y, 0)) * handleOffset):toObjectSpace(handleCF)
		
		Grip.C1 = S.equipSettings.GripC1
		
		--------------------[ RUNNING PLUGINS ]---------------------------------------
		
		for _, Plugin in pairs(Plugins.OnEquipped) do
			spawn(function()
				Plugin()
			end)
		end
		
		--------------------[ GETTING PLAYER MASS ]-----------------------------------
		
		local connectedParts = HRP:GetConnectedParts(true)
		for _, v in pairs(connectedParts) do
			if v:IsA("BasePart") then
				playerMass = playerMass + v:GetMass()
			end
		end
		
		--------------------[ CONNECTIONS ]-------------------------------------------
		
		INSERT(Connections, Humanoid.Died:connect(function()
			onUnequipped(true)
		end))
		
		INSERT(Connections, Humanoid.Jumping:connect(function()
			if Stance ~= 0 then
				Stand()
			end
		end))
		
		INSERT(Connections, Humanoid.StateChanged:connect(onHumanoidStateChanged))
		
		INSERT(Connections, Humanoid.HealthChanged:connect(updateHealth))
		
		INSERT(Connections, M2.Button1Down:connect(onMB1Down))
		
		INSERT(Connections, M2.Button1Up:connect(onMB1Up))
		
		INSERT(Connections, M2.Button2Down:connect(onMB2Down))
		
		INSERT(Connections, M2.Button2Up:connect(onMB2Up))
		
		INSERT(Connections, M2.KeyDown:connect(keyDown))
		
		INSERT(Connections, M2.KeyUp:connect(keyUp))
		
		if S.sensitivitySettings.scrollToChange then
			INSERT(Connections, M2.WheelForward:connect(onScrollUp))
			INSERT(Connections, M2.WheelBackward:connect(onScrollDown))
		end
		
		if S.AutoKnife then
			INSERT(Connections, RS.Stepped:connect(function()
				local H, P = AdvRayCast(Head.CFrame.p, Head.CFrame.lookVector, S.AutoKnifeDist, nil)
				if H then
					local HitHuman = findFirstClass(H.Parent, "Humanoid")
					if HitHuman and isEnemy(HitHuman) and HitHuman.Health ~= 0 then
						Knife()
					end
				end
			end))
		end
		
		INSERT(Connections, UIS.InputChanged:connect(function(inputObj)
			if inputObj.UserInputType == Enum.UserInputType.MouseMovement then
				local rawCamAng = camAng - (VEC2(RAD(inputObj.Delta.x), RAD(inputObj.Delta.y)) * mouseSensitivity * 0.25)
				camAng = VEC2(rawCamAng.x, (rawCamAng.y > RAD(80) and RAD(80) or rawCamAng.y < RAD(-80) and RAD(-80) or rawCamAng.y))
				
				desiredXOffset = math.min(math.max(inputObj.Delta.x, -S.momentumSettings.maxInput), S.momentumSettings.maxInput)
				desiredYOffset = math.min(math.max(inputObj.Delta.y, -S.momentumSettings.maxInput), S.momentumSettings.maxInput)
			end
		end))
		
		INSERT(Connections, M2.Idle:connect(function(inputObj)
			desiredXOffset = 0
			desiredYOffset = 0
		end))
		
		INSERT(Connections, RS.Stepped:connect(function()
			if tick() - lastBeat > (Humanoid.Health / 75) then
				lastBeat = tick()
				HUD.Health.Tray.Beat:TweenPosition(
					UDim2.new(0, -21, 0, 0),
					Enum.EasingDirection.Out,
					Enum.EasingStyle.Linear,
					0.7 - ((100 - Humanoid.Health) / 400),
					false,
					function()
						HUD.Health.Tray.Beat.Position = UDim2.new(1, 0, 0, 0)
					end
				)
			end
		end))
		
		INSERT(Connections, RS.RenderStepped:connect(function()
			--Main animation
			local animC0, animC1 = getAnimCF()
			animWeld.C0 = animC0
			animWeld.C1 = animC1
			
			--Camera updating
			renderCamera()
		end))
		
		--------------------[ ANIMATE GUN ]-------------------------------------------
		
		tweenJoint(LWeld, nil, S.unAimedC1.leftArm, Sine, S.equipSettings.Time)
		tweenJoint(RWeld, nil, S.unAimedC1.rightArm, Sine, S.equipSettings.Time)
		tweenJoint(Grip, nil, S.unAimedC1.Grip, Sine, S.equipSettings.Time)
		spawn(function()
			local T = tick()
			while true do
				if tick() - T > S.equipSettings.Time then break end
				if (not Selected) then break end
				wait()
			end
			equipAnimPlaying = false
		end)
		
		Animate()
	end
end

function onUnequipped(deleteTool)
	if Selected then
		Selected = false
		
		breakReload = true
		
		--------------------[ RUNNING PLUGINS ]---------------------------------------
		
		for _, Plugin in pairs(Plugins.OnUnEquipped) do
			spawn(function()
				Plugin()
			end)
		end
		
		--------------------[ MODIFYING THE PLAYER ]----------------------------------
		
		Cam.FieldOfView = 70
		Cam.CameraType = Enum.CameraType.Custom
		
		UIS.MouseBehavior = Enum.MouseBehavior.Default
		UIS.MouseIconEnabled = true
		
		Player.CameraMode = Enum.CameraMode.Classic
		
		if armTable then
			armTable[1].Model:Destroy()
			armTable[2].Model:Destroy()
		elseif armModel then
			armModel:Destroy()
		end
		
		LLegWeld:Destroy()
		RLegWeld:Destroy()
		
		changePlayerTrans(Char, 0)
		
		mainGUI.Parent = script
		
		Shoulders.Right.Part1 = RArm
		Shoulders.Left.Part1 = LArm
		
		neckClone.Parent = Torso
		headWeld:Destroy()
		
		Humanoid.WalkSpeed = 16
		Humanoid.AutoRotate = true
		
		--------------------[ RESETING THE TOOL ]-------------------------------------
		
		gunIgnore:Destroy()
		
		mouseSensitivity = S.sensitivitySettings.Default
		
		MB1Down = false
		
		playerMass = 0
		
		Aimed = false
		
		camOffsets = {
			guiScope = {
				Rot = V3();
			};
			Reload = {
				Rot = V3();
				Code = nil;
			};
			Recoil = {
				Rot = V3();
				Code = nil;
			};
		}
		
		recoilAnim = {
			Pos = V3();
			Rot = V3();
			Code = nil;
		}

		--Setting the aim variables to unaimed
		spreadZoom = "unAimed"
		scopeMain.Visible = false
		scopeSteady.Visible = false
		aimAlpha = 0
		aimHeadOffset = 0
		jumpAnimMultiplier = 1
		translationDivisor = 7
		rotationMultiplier = S.momentumSettings.Amplitude.unAimed
		armTiltMultiplier = 1
		Scope.BackgroundTransparency = 1
		if S.guiScope then
			spawn(function()
				for _, Obj in pairs(Gun:GetChildren()) do
					if Obj:IsA("BasePart") then
						Obj.LocalTransparencyModifier = 0
					end
				end
			end)
		end
		
		onGround = true
		
		for _, Tab in pairs(gunParts) do
			Tab.Weld:Destroy()
			Tab.Weld = nil
		end
		
		for _,c in pairs(Connections) do
			c:disconnect()
		end
		
		Connections = {}
		
		if deleteTool then
			Cam:ClearAllChildren()
			Gun:Destroy()
		end
		
		wait() --This is here in case you dolphin dived and deselected the tool instantly
		
		if S.stanceSettings.standOnDeselect and Stance ~= 0 then
			crawlCamRot = 0
			isCrawling = false
			stanceSway = 1
			spreadStance = "Stand"
			Stand(true)
		end
		baseSpread = S.spreadSettings[spreadZoom][spreadStance][spreadMotion]
	end
end

Gun.Equipped:connect(onEquipped)
Gun.Unequipped:connect(function() onUnequipped(false) end)

--------------------------------------------------------------------------------------
--------------------[ END PROGRAM ]---------------------------------------------------
--------------------------------------------------------------------------------------

